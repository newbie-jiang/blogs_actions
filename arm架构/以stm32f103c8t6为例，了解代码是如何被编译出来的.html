
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>以stm32f103c8t6为例，了解代码是如何被编译出来的</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h2 id="stm32f103c8t6">以stm32f103c8t6为例，了解代码是如何被编译出来的</h2>
<p><a href="https://github.com/newbie-jiang/stm32c8t6-mini-start">project download</a></p>
<p><img alt="image-20250703151007791" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250703151007791.png" /></p>
<h2 id="starts">其中 start.s（汇编文件）的预处理产物</h2>
<p>有两种情况要区分：</p>
<p>（A）<strong>GNU 风格 .S 文件（注意后缀大写）</strong></p>
<ul>
<li><strong><code>.S</code>（大写 S）</strong>：是<strong>需要预处理的汇编文件</strong></li>
<li>可以用 C 语言的预处理功能，比如 <code>#define</code>、<code>#include</code>，这样编译器会先进行预处理（比如头文件展开、宏替换），输出为<strong>纯汇编代码文件</strong>（例如 <code>start.s</code> 经过预处理后生成 <code>start.s</code>/<code>start.i</code>/<code>start.spp</code> 视具体命令而定）</li>
</ul>
<p>（B）<strong>.s（小写 s）文件</strong></p>
<ul>
<li>纯汇编，不做预处理，直接交给汇编器</li>
</ul>
<p>这里以点灯为例,使用cubemx生成一个hal库最小点灯 keil工程，再将工程裁剪，使其不依赖hal库，得到最精简的代码，让led闪烁</p>
<ul>
<li>cubemx配置HSE外部时钟，使能LED时钟及其配置</li>
<li>验证led是否正常闪烁</li>
<li>精简代码不依赖hal库,全部使用寄存器配置并验证</li>
</ul>
<h2 id="keil">keil工程</h2>
<p>精简后最终得到如下文件   见project:   2.minimum_program\mini-stm32-f103c8t6</p>
<pre><code class="language-c">|-- core_cm3.h
|-- main.c
|-- startup_stm32f103xb.s
|-- stm32f103xb.h
</code></pre>
<ul>
<li>其中core_cm3.h  与 stm32f103xb.h 定义了寄存器的结构体以及配置宏,  全写main.c里太多了，这里分开</li>
<li>实际上只需要一个.s启动文件与 mian函数所在的文件.c  此外还有一个隐藏的文件，链接脚本，就可以让代码跑起来了(.s .c link_file)</li>
<li>链接脚本查看如下</li>
<li>keil的链接脚本也叫做分散加载文件，是以sct结尾的文件，语法参考链接 https://developer.arm.com/documentation/dui0474/m/scatter-file-syntax/syntax-of-a-scatter-file?lang=en</li>
</ul>
<p><img alt="image-20250703153156078" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250703153156078.png" /></p>
<p><img alt="image-20250703153408593" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250703153408593.png" /></p>
<p><img alt="image-20250703154337632" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250703154337632.png" /></p>
<h2 id="arm-none-eabi-gcc">arm-none-eabi-gcc编译工具链手工编译</h2>
<p>准备文件</p>
<pre><code>|-- core_cm3.h
|-- main.c
|-- startup_stm32f103xb.s
|-- stm32f103xb.h
|-- STM32F103XX_FLASH.ld
</code></pre>
<ul>
<li>对于arm-none-eabi-gcc 编译工具链，启动文件.s的语法不一样，以及链接脚本的语法也不一样为 后缀为 ld 一般称为链接脚本</li>
<li>直接使用cubemx生成的cmake 工程   startup_stm32f103xb.s 和 STM32F103XX_FLASH.ld 拿过来直接用</li>
</ul>
<p>准备好上述一共五个文件，安装好arm-none-eabi-gcc编译工具链</p>
<h3 id="1-c-o">1. <strong>编译 C 文件为目标文件（.o）</strong></h3>
<p>此处直接编译成目标文件，（实际上可以体验 预处理，编译，汇编的过程）</p>
<pre><code>arm-none-eabi-gcc -mcpu=cortex-m3 -fdata-sections -ffunction-sections -O0 -g3 -std=gnu11 -c main.c -o main.c.o
</code></pre>
<ul>
<li><strong>作用</strong>：把 <code>main.c</code> 编译成目标文件 <code>main.c.o</code>，用于后续链接。</li>
<li><strong>常用参数：</strong></li>
<li><code>-mcpu=cortex-m3</code>：指定目标 CPU 架构为 Cortex-M3。</li>
<li><code>-fdata-sections -ffunction-sections</code>：让每个数据/函数单独成段，便于后续去除未用部分。</li>
<li><code>-O0</code>：关闭优化，便于调试。</li>
<li><code>-g3</code>：生成完整的调试信息。</li>
<li><code>-std=gnu11</code>：C 标准选择 GNU C11。</li>
<li><code>-c</code>：只编译，不链接。</li>
<li><code>-o main.c.o</code>：指定输出目标文件。</li>
</ul>
<hr />
<h3 id="2-o">2. <strong>汇编启动文件为目标文件（.o）</strong></h3>
<pre><code>arm-none-eabi-gcc -mcpu=cortex-m3 -x assembler-with-cpp -MMD -MP -g -c startup_stm32f103xb.s -o startup_stm32f103xb.s.o
</code></pre>
<ul>
<li><strong>作用</strong>：把启动文件 <code>startup_stm32f103xb.s</code> 汇编成目标文件 <code>startup_stm32f103xb.s.o</code>。</li>
<li><strong>常用参数：</strong></li>
<li><code>-x assembler-with-cpp</code>：启用汇编文件的 C 预处理能力。</li>
<li><code>-MMD -MP</code>：生成依赖文件，方便增量编译（Makefile 用）。</li>
<li>其余参数同上。</li>
</ul>
<hr />
<h3 id="3-elf">3. <strong>链接所有目标文件为可执行文件（.elf）</strong></h3>
<pre><code>arm-none-eabi-gcc -mcpu=cortex-m3 \
  -T STM32F103XX_FLASH.ld --specs=nano.specs \
  -Wl,-Map=103c8-cmake.map -Wl,--gc-sections \
  -Wl,--start-group main.c.o startup_stm32f103xb.s.o -lc -lm -Wl,--end-group \
  -Wl,--print-memory-usage -o 103c8-cmake.elf
</code></pre>
<ul>
<li><strong>作用</strong>：把所有 <code>.o</code> 文件链接成 <code>103c8-cmake.elf</code>，带调试信息的可执行文件。</li>
<li><strong>关键参数：</strong></li>
<li><code>-T STM32F103XX_FLASH.ld</code>：指定链接脚本，决定代码/数据段的实际内存分布。</li>
<li><code>--specs=nano.specs</code>：使用精简的 newlib-nano C 库。</li>
<li><code>-Wl,xxx</code>：传递参数给链接器（ld）。<ul>
<li><code>-Map=103c8-cmake.map</code>：生成映射文件。</li>
<li><code>--gc-sections</code>：自动去除未引用的段（配合 <code>-fdata-sections</code>）。</li>
<li><code>--start-group ... --end-group</code>：解决多库依赖问题。</li>
<li><code>-lc -lm</code>：链接 C 标准库和数学库。</li>
<li><code>--print-memory-usage</code>：链接后打印 RAM/FLASH 使用情况。</li>
</ul>
</li>
<li><code>-o 103c8-cmake.elf</code>：指定输出的 ELF 文件。</li>
</ul>
<hr />
<h3 id="4-hexbin">4. <strong>格式转换为 HEX/BIN（烧录文件）</strong></h3>
<pre><code>arm-none-eabi-objcopy -O ihex 103c8-cmake.elf 103c8-cmake.hex
arm-none-eabi-objcopy -O binary 103c8-cmake.elf 103c8-cmake.bin
</code></pre>
<ul>
<li><strong>作用</strong>：把 ELF 文件转换为更适合烧录/传输的镜像格式。</li>
<li><code>-O ihex</code>：生成 Intel HEX 文件（文本，广泛兼容于烧录工具）。</li>
<li><code>-O binary</code>：生成裸二进制 BIN 文件（直接烧录到 Flash）。</li>
<li><strong>用途</strong>：</li>
<li><code>.hex</code> 和 <code>.bin</code> 都是实际烧录 MCU 常用的格式，依据烧录工具和厂商不同选用。</li>
</ul>
<hr />
<h3 id="_1"><strong>总结/流程一览</strong></h3>
<ol>
<li><strong>编译</strong>：.c → .o</li>
<li><strong>汇编</strong>：.s → .o</li>
<li><strong>链接</strong>：所有 .o → .elf（开发/调试用，带符号）</li>
<li><strong>格式转换</strong>：.elf → .hex/.bin（烧录/量产用）</li>
</ol>
<h3 id="_2">当然也可以一条命令直接得到全部</h3>
<pre><code>arm-none-eabi-gcc -mcpu=cortex-m3 -fdata-sections -ffunction-sections -O0 -g3 -std=gnu11 \
  -T STM32F103XX_FLASH.ld --specs=nano.specs \
  -Wl,-Map=103c8-cmake.map -Wl,--gc-sections \
  -Wl,--start-group main.c startup_stm32f103xb.s -lc -lm -Wl,--end-group \
  -Wl,--print-memory-usage -o 103c8-cmake.elf \
  &amp;&amp; arm-none-eabi-objcopy -O ihex 103c8-cmake.elf 103c8-cmake.hex \
  &amp;&amp; arm-none-eabi-objcopy -O binary 103c8-cmake.elf 103c8-cmake.bin
</code></pre>
<p><img alt="image-20250703160303958" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250703160303958.png" /></p>
<h2 id="cmake">此外还更改了cmake工程</h2>
<ul>
<li>其中mini-stm32-f103c8t6-cmake 将链接脚本放在src目录，可体验手工编译</li>
</ul>
<pre><code class="language-bash">|-- 1.original_program         
|   |-- stm32-f103c8t6          //cubemx生成原始keil工程
|   `-- stm32-f103c8t6-cmake    //cubemx生成原始cmake工程
|-- 2.minimum_program
|   |-- mini-stm32-f103c8t6       //精简后的keil工程
|   `-- mini-stm32-f103c8t6-cmake //精简后的cmake工程

</code></pre>
<p>个人感想：</p>
<p>大学时直接学stm32,一上来就一大堆文件，无从下手，对这一部分一知半解，现在有空梳理下这部分知识</p>
<ul>
<li>这种开发方式应该是很多年前的开发方式吧，直接配置寄存器，现在各个厂商都封装好了库直接用，不用看底层的寄存器，读库的说明也可以开发了，可移植性提高了，门槛也降低了，</li>
<li>当然一些低端小内存芯片还是用原始的寄存器开发，见过台湾九齐OTP芯片,ram就几个字节，没听错，几个字节</li>
<li>手工编译，makefile,  cmake，工程管理也在变得更加自动化</li>
</ul>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul>
<li><a href="#stm32f103c8t6">以stm32f103c8t6为例，了解代码是如何被编译出来的</a></li>
<li><a href="#starts">其中 start.s（汇编文件）的预处理产物</a></li>
<li><a href="#keil">keil工程</a></li>
<li><a href="#arm-none-eabi-gcc">arm-none-eabi-gcc编译工具链手工编译</a><ul>
<li><a href="#1-c-o">1. 编译 C 文件为目标文件（.o）</a></li>
<li><a href="#2-o">2. 汇编启动文件为目标文件（.o）</a></li>
<li><a href="#3-elf">3. 链接所有目标文件为可执行文件（.elf）</a></li>
<li><a href="#4-hexbin">4. 格式转换为 HEX/BIN（烧录文件）</a></li>
<li><a href="#_1">总结/流程一览</a></li>
<li><a href="#_2">当然也可以一条命令直接得到全部</a></li>
</ul>
</li>
<li><a href="#cmake">此外还更改了cmake工程</a></li>
</ul>
</div>

</div>
</body>
</html>

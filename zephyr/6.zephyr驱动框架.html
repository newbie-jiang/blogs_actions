
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>6.zephyré©±åŠ¨æ¡†æ¶</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h2 id="gpio">GPIOé©±åŠ¨æ¡†æ¶åˆ†æï¼Œé¡¶å±‚åˆ°åº•å±‚</h2>
<p>gpioç¤ºä¾‹åˆ†æ      zephyr\samples\basic\blinky\src\main.c        ä½¿ç”¨stm32</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;zephyr/kernel.h&gt;
#include &lt;zephyr/drivers/gpio.h&gt;

/* 1000 msec = 1 sec */
#define SLEEP_TIME_MS   1000

/* The devicetree node identifier for the &quot;led0&quot; alias. */
#define LED0_NODE DT_ALIAS(led0)

/*
 * A build error on this line means your board is unsupported.
 * See the sample documentation for information on how to fix this.
 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

int main(void)
{
    int ret;
    bool led_state = true;

    if (!gpio_is_ready_dt(&amp;led)) {
        return 0;
    }

    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);
    if (ret &lt; 0) {
        return 0;
    }

    while (1) {
        ret = gpio_pin_toggle_dt(&amp;led);
        if (ret &lt; 0) {
            return 0;
        }

        led_state = !led_state;
        printf(&quot;LED state: %s\n&quot;, led_state ? &quot;ON&quot; : &quot;OFF&quot;);
        k_msleep(SLEEP_TIME_MS);  
    }
    return 0;
}
</code></pre>
<p>ä½¿ç”¨ä¸Šè¿°ä¸­çš„ç¤ºä¾‹ï¼Œåˆ†æGPIOçš„é©±åŠ¨æ¡†æ¶</p>
<h2 id="_1">ç¬¬ä¸€å±‚</h2>
<p>zephyr\samples\basic\blinky\src\main.c</p>
<pre><code>gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE); 
</code></pre>
<p>åº”ç”¨å±‚æŠ½è±¡ (Devicetree å°è£…)</p>
<ul>
<li>
<p>æŠŠ <strong>è®¾å¤‡æ ‘ï¼ˆDevicetreeï¼‰ä¸­å®šä¹‰çš„ GPIO æ§åˆ¶å™¨ã€å¼•è„šå·ã€æ ‡å¿—ä½</strong> ç»„åˆä¸ºä¸€ä¸ª <code>gpio_dt_spec</code> å¯¹è±¡</p>
</li>
<li>
<p>è°ƒç”¨ <code>gpio_pin_configure()</code>ï¼Œä¼ å…¥ç»“æ„ä½“ä¸­æå–çš„ <code>port</code>ã€<code>pin</code>ã€<code>flags</code></p>
</li>
<li>
<p>å®ç°å¹³å°æ— å…³ã€å¼•è„šæŠ½è±¡ã€åº”ç”¨é€»è¾‘æ¸…æ™°</p>
</li>
</ul>
<pre><code class="language-c">struct gpio_dt_spec {
    /** GPIO device controlling the pin */
    const struct device *port;
    /** The pin's number on the device */
    gpio_pin_t pin;
    /** The pin's configuration flags as specified in devicetree */
    gpio_dt_flags_t dt_flags;
};

static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
                    gpio_flags_t extra_flags)
{
    return gpio_pin_configure(spec-&gt;port,
                  spec-&gt;pin,
                  spec-&gt;dt_flags | extra_flags);
}
</code></pre>
<h2 id="_2">ç¬¬äºŒå±‚</h2>
<p>zephyr\build\zephyr\include\generated\zephyr\syscalls\gpio.h</p>
<pre><code class="language-c">static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
</code></pre>
<p>é€šç”¨å­ç³»ç»Ÿæ¥å£ (GPIO API å±‚)</p>
<ul>
<li>
<p>é€šè¿‡ <code>z_impl_gpio_pin_configure()</code> å®ç° <strong>é€»è¾‘æ ¡éªŒã€å‚æ•°è§„èŒƒåŒ–å¤„ç†</strong></p>
</li>
<li>
<p>æ˜¯æ‰€æœ‰ GPIO å­ç³»ç»Ÿçš„ç»Ÿä¸€æ¥å£ï¼Œæä¾›ä¸€è‡´æ€§ï¼ˆæ— è®ºä½ æ˜¯ STM32 è¿˜æ˜¯ Nordicï¼‰</p>
</li>
<li>
<h4 id="_3">ç‰¹æ€§ï¼š</h4>
<p>æ£€æŸ¥ flag åˆæ³•æ€§ï¼ˆä¸èƒ½åŒæ—¶ä¸Šæ‹‰å’Œä¸‹æ‹‰ã€ä¸èƒ½æ—¢è¾“å‡ºé«˜åˆè¾“å‡ºä½ç­‰ï¼‰</p>
<p>å¤„ç† <code>GPIO_ACTIVE_LOW</code> / <code>GPIO_OUTPUT_INIT_LOGICAL</code> ç­‰ç‰¹æ®Šæƒ…å†µ</p>
<p>è®¾ç½®è¿è¡Œæ—¶æ•°æ®ç»“æ„ <code>invert</code> ä½</p>
<p>è°ƒç”¨ç¬¬ä¸‰å±‚é©±åŠ¨æ¥å£è¡¨ä¸­çš„å‡½æ•°æŒ‡é’ˆ</p>
</li>
</ul>
<pre><code class="language-c">/**
 * @brief Runtime device structure (in ROM) per driver instance
 */
struct device {
    /** Name of the device instance */
    const char *name;
    /** Address of device instance config information */
    const void *config;
    /** Address of the API structure exposed by the device instance */
    const void *api;
    /** Address of the common device state */
    struct device_state *state;
    /** Address of the device instance private data */
    void *data;
    /** Device operations */
    struct device_ops ops;
    /** Device flags */
    device_flags_t flags;
#if defined(CONFIG_DEVICE_DEPS) || defined(__DOXYGEN__)
    /**
     * Optional pointer to dependencies associated with the device.
     *
     * This encodes a sequence of sets of device handles that have some
     * relationship to this node. The individual sets are extracted with
     * dedicated API, such as device_required_handles_get(). Only available
     * if @kconfig{CONFIG_DEVICE_DEPS} is enabled.
     */
    Z_DEVICE_DEPS_CONST device_handle_t *deps;
#endif /* CONFIG_DEVICE_DEPS */
#if defined(CONFIG_PM_DEVICE) || defined(__DOXYGEN__)
    /**
     * Reference to the device PM resources (only available if
     * @kconfig{CONFIG_PM_DEVICE} is enabled).
     */
    union {
        struct pm_device_base *pm_base;
        struct pm_device *pm;
        struct pm_device_isr *pm_isr;
    };
#endif
#if defined(CONFIG_DEVICE_DT_METADATA) || defined(__DOXYGEN__)
    const struct device_dt_metadata *dt_meta;
#endif /* CONFIG_DEVICE_DT_METADATA */
};


typedef uint8_t gpio_pin_t;
typedef uint32_t gpio_flags_t;

#define compiler_barrier() do { \
    __asm__ __volatile__ (&quot;&quot; ::: &quot;memory&quot;); \
} while (false)


__syscall int gpio_pin_configure(const struct device *port,
                 gpio_pin_t pin,
                 gpio_flags_t flags);


static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
{
#ifdef CONFIG_USERSPACE
    if (z_syscall_trap()) {
        union { uintptr_t x; const struct device * val; } parm0 = { .val = port };
        union { uintptr_t x; gpio_pin_t val; } parm1 = { .val = pin };
        union { uintptr_t x; gpio_flags_t val; } parm2 = { .val = flags };
        return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_GPIO_PIN_CONFIGURE);
    }
#endif
    compiler_barrier();
    return z_impl_gpio_pin_configure(port, pin, flags);
}
</code></pre>
<h2 id="_4">ç¬¬ä¸‰å±‚</h2>
<p>zephyr\include\zephyr\drivers\gpio.h</p>
<pre><code class="language-c">static inline int z_impl_gpio_pin_configure(const struct device *port,
                        gpio_pin_t pin,
                        gpio_flags_t flags)
</code></pre>
<p>é©±åŠ¨ç»‘å®šæ¥å£ï¼ˆé©±åŠ¨å‡½æ•°è¡¨ï¼‰</p>
<ul>
<li>
<p>å®šä¹‰ <code>gpio_driver_api</code> çš„ç»“æ„ä½“ï¼ŒæŠŠåº•å±‚é©±åŠ¨å‡½æ•°å¡«è¿›å»</p>
</li>
<li>
<p>æ³¨å†Œé©±åŠ¨å‡½æ•°è¡¨ï¼ˆå‡½æ•°æŒ‡é’ˆè¡¨ï¼‰ä¾›ç³»ç»Ÿç»Ÿä¸€è°ƒåº¦</p>
</li>
<li>
<p>è®©ä¸åŒèŠ¯ç‰‡å‚å•†çš„ GPIO é©±åŠ¨ï¼Œéƒ½èƒ½ç»Ÿä¸€æ¥å…¥ Zephyr API</p>
</li>
</ul>
<pre><code class="language-c">__subsystem struct gpio_driver_api {
    int (*pin_configure)(const struct device *port, gpio_pin_t pin,
                 gpio_flags_t flags);
#ifdef CONFIG_GPIO_GET_CONFIG
    int (*pin_get_config)(const struct device *port, gpio_pin_t pin,
                  gpio_flags_t *flags);
#endif
    int (*port_get_raw)(const struct device *port,
                gpio_port_value_t *value);
    int (*port_set_masked_raw)(const struct device *port,
                   gpio_port_pins_t mask,
                   gpio_port_value_t value);
    int (*port_set_bits_raw)(const struct device *port,
                 gpio_port_pins_t pins);
    int (*port_clear_bits_raw)(const struct device *port,
                   gpio_port_pins_t pins);
    int (*port_toggle_bits)(const struct device *port,
                gpio_port_pins_t pins);
    int (*pin_interrupt_configure)(const struct device *port,
                       gpio_pin_t pin,
                       enum gpio_int_mode mode,
                       enum gpio_int_trig trig);
    int (*manage_callback)(const struct device *port,
                   struct gpio_callback *cb,
                   bool set);
    uint32_t (*get_pending_int)(const struct device *dev);
#ifdef CONFIG_GPIO_GET_DIRECTION
    int (*port_get_direction)(const struct device *port, gpio_port_pins_t map,
                  gpio_port_pins_t *inputs, gpio_port_pins_t *outputs);
#endif /* CONFIG_GPIO_GET_DIRECTION */
};


static DEVICE_API(gpio, gpio_stm32_driver) = {
    .pin_configure = gpio_stm32_config,
#if defined(CONFIG_GPIO_GET_CONFIG) &amp;&amp; !defined(CONFIG_SOC_SERIES_STM32F1X)
    .pin_get_config = gpio_stm32_get_config,
#endif /* CONFIG_GPIO_GET_CONFIG */
    .port_get_raw = gpio_stm32_port_get_raw,
    .port_set_masked_raw = gpio_stm32_port_set_masked_raw,
    .port_set_bits_raw = gpio_stm32_port_set_bits_raw,
    .port_clear_bits_raw = gpio_stm32_port_clear_bits_raw,
    .port_toggle_bits = gpio_stm32_port_toggle_bits,
    .pin_interrupt_configure = gpio_stm32_pin_interrupt_configure,
    .manage_callback = gpio_stm32_manage_callback,
};

static inline int z_impl_gpio_pin_configure(const struct device *port,
                        gpio_pin_t pin,
                        gpio_flags_t flags)
{
    const struct gpio_driver_api *api =
        (const struct gpio_driver_api *)port-&gt;api;
    __unused const struct gpio_driver_config *const cfg =
        (const struct gpio_driver_config *)port-&gt;config;
    struct gpio_driver_data *data =
        (struct gpio_driver_data *)port-&gt;data;
    int ret;

    SYS_PORT_TRACING_FUNC_ENTER(gpio_pin, configure, port, pin, flags);

    __ASSERT((flags &amp; GPIO_INT_MASK) == 0,
         &quot;Interrupt flags are not supported&quot;);

    __ASSERT((flags &amp; (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
         (GPIO_PULL_UP | GPIO_PULL_DOWN),
         &quot;Pull Up and Pull Down should not be enabled simultaneously&quot;);

    __ASSERT(!((flags &amp; GPIO_INPUT) &amp;&amp; !(flags &amp; GPIO_OUTPUT) &amp;&amp; (flags &amp; GPIO_SINGLE_ENDED)),
         &quot;Input cannot be enabled for 'Open Drain', 'Open Source' modes without Output&quot;);

    __ASSERT_NO_MSG((flags &amp; GPIO_SINGLE_ENDED) != 0 ||
            (flags &amp; GPIO_LINE_OPEN_DRAIN) == 0);

    __ASSERT((flags &amp; (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
         || (flags &amp; GPIO_OUTPUT) != 0,
         &quot;Output needs to be enabled to be initialized low or high&quot;);

    __ASSERT((flags &amp; (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
         != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
         &quot;Output cannot be initialized low and high&quot;);

    if (((flags &amp; GPIO_OUTPUT_INIT_LOGICAL) != 0)
        &amp;&amp; ((flags &amp; (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
        &amp;&amp; ((flags &amp; GPIO_ACTIVE_LOW) != 0)) {
        flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    }

    flags &amp;= ~GPIO_OUTPUT_INIT_LOGICAL;

    __ASSERT((cfg-&gt;port_pin_mask &amp; (gpio_port_pins_t)BIT(pin)) != 0U,
         &quot;Unsupported pin&quot;);

    if ((flags &amp; GPIO_ACTIVE_LOW) != 0) {
        data-&gt;invert |= (gpio_port_pins_t)BIT(pin);
    } else {
        data-&gt;invert &amp;= ~(gpio_port_pins_t)BIT(pin);
    }

    ret = api-&gt;pin_configure(port, pin, flags);
    SYS_PORT_TRACING_FUNC_EXIT(gpio_pin, configure, port, pin, ret);
    return ret;
}
</code></pre>
<p>è°ƒç”¨  <strong>ret = api-&gt;pin_configure(port, pin, flags);</strong>   è¿›å…¥ä¸‹ä¸€å±‚</p>
<h2 id="_5">ç¬¬å››å±‚</h2>
<p>zephyr\drivers\gpio\gpio_stm32.c</p>
<pre><code class="language-c">static int gpio_stm32_config(const struct device *dev,
                 gpio_pin_t pin, gpio_flags_t flags)
</code></pre>
<ul>
<li>ç¡¬ä»¶é©±åŠ¨å®ç°ï¼ˆèŠ¯ç‰‡å‚å•†ç›¸å…³ä»£ç ï¼‰</li>
</ul>
<pre><code class="language-c">/**
 * @brief Configure pin or port
 */
static int gpio_stm32_config(const struct device *dev,
                 gpio_pin_t pin, gpio_flags_t flags)
{
    int err;
    uint32_t pincfg;
    struct gpio_stm32_data *data = dev-&gt;data;

    /* figure out if we can map the requested GPIO
     * configuration
     */
    err = gpio_stm32_flags_to_conf(flags, &amp;pincfg);
    if (err != 0) {
        return err;
    }

    /* Enable device clock before configuration (requires bank writes) */
    if ((((flags &amp; GPIO_OUTPUT) != 0) || ((flags &amp; GPIO_INPUT) != 0)) &amp;&amp;
        !(data-&gt;pin_has_clock_enabled &amp; BIT(pin))) {
        err = pm_device_runtime_get(dev);
        if (err &lt; 0) {
            return err;
        }
        data-&gt;pin_has_clock_enabled |= BIT(pin);
    }

    if ((flags &amp; GPIO_OUTPUT) != 0) {
        if ((flags &amp; GPIO_OUTPUT_INIT_HIGH) != 0) {
            gpio_stm32_port_set_bits_raw(dev, BIT(pin));
        } else if ((flags &amp; GPIO_OUTPUT_INIT_LOW) != 0) {
            gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
        }
    }

    gpio_stm32_configure_raw(dev, pin, pincfg, 0);

#ifdef CONFIG_STM32_WKUP_PINS
    if (flags &amp; STM32_GPIO_WKUP) {
#ifdef CONFIG_POWEROFF
        struct gpio_dt_spec gpio_dt_cfg = {
            .port = dev,
            .pin = pin,
            .dt_flags = (gpio_dt_flags_t)flags,
        };

        if (stm32_pwr_wkup_pin_cfg_gpio((const struct gpio_dt_spec *)&amp;gpio_dt_cfg)) {
            LOG_ERR(&quot;Could not configure GPIO %s pin %d as a wake-up source&quot;,
                    gpio_dt_cfg.port-&gt;name, gpio_dt_cfg.pin);
        }
#else
        LOG_DBG(&quot;STM32_GPIO_WKUP flag has no effect when CONFIG_POWEROFF=n&quot;);
#endif /* CONFIG_POWEROFF */
    }
#endif /* CONFIG_STM32_WKUP_PINS */

    /* Decrement GPIO usage count only if pin is now disconnected after being connected */
    if (((flags &amp; GPIO_OUTPUT) == 0) &amp;&amp; ((flags &amp; GPIO_INPUT) == 0) &amp;&amp;
        (data-&gt;pin_has_clock_enabled &amp; BIT(pin))) {
        err = pm_device_runtime_put(dev);
        if (err &lt; 0) {
            return err;
        }
        data-&gt;pin_has_clock_enabled &amp;= ~BIT(pin);
    }

    return 0;
}
</code></pre>
<h2 id="syscall">syscall æœºåˆ¶</h2>
<p>å‚è€ƒé“¾æ¥ï¼šhttps://www.cnblogs.com/ttwards/p/18449137</p>
<p>ä¸Šè¿°ä¸­å‘ç°ï¼Œå‡½æ•°  gpio_pin_configure   è·¯å¾„ä¸º    zephyr\build\zephyr\include\generated\zephyr\syscalls\gpio.h</p>
<pre><code class="language-c">static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
</code></pre>
<p>zephyr\build è¿™ä¸ªè·¯å¾„æ˜¯ç¼–è¯‘åçš„è·¯å¾„ï¼Œéš¾é“æ˜¯ç¼–è¯‘å…ˆç”Ÿæˆ gpio.hæ–‡ä»¶   å†ç»§ç»­ç¼–è¯‘ ï¼Ÿ</p>
<ul>
<li>
<p>å‡½æ•° <strong>ä¸æ˜¯ç”±å†™çš„ä»£ç è‡ªåŠ¨ç”Ÿæˆçš„</strong>ï¼Œè€Œæ˜¯ç”± Zephyr çš„ syscall æœºåˆ¶ <strong>ç”Ÿæˆäº†ä¸€ä¸ªå°è£…ç‰ˆæœ¬</strong></p>
</li>
<li>
<p>Zephyr æ”¯æŒç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„åˆ†ç¦»ï¼Œç”¨æˆ·ç©ºé—´ä»£ç ä¸èƒ½ç›´æ¥è°ƒç”¨å†…æ ¸ç©ºé—´çš„å‡½æ•°ã€‚</p>
</li>
</ul>
<p>ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼ŒZephyr ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æœºåˆ¶ï¼Œå…è®¸ç”¨æˆ·ç©ºé—´ä»£ç é€šè¿‡ç‰¹å®šçš„æ¥å£è°ƒç”¨å†…æ ¸ç©ºé—´çš„å‡½æ•°ã€‚è¿™æ ·ä¹Ÿæå‡äº†ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚</p>
<p><code>__syscall</code> å…³é”®å­—ç”¨äºæ ‡è®°ä¸€ä¸ªå‡½æ•°ä¸ºç³»ç»Ÿè°ƒç”¨å‡½æ•°ã€‚å®ƒå‘Šè¯‰ç¼–è¯‘å™¨å’Œ <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/scripts/build/gen_syscalls.py"><code>gen_syscalls.py</code></a> è„šæœ¬ï¼Œè¿™ä¸ªå‡½æ•°éœ€è¦ç”Ÿæˆç³»ç»Ÿè°ƒç”¨æ¥å£</p>
<p><code>gen_syscalls.py</code> è„šæœ¬ä¼šç”Ÿæˆä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºåœ¨ç”¨æˆ·ç©ºé—´è°ƒç”¨è¯¥ç³»ç»Ÿè°ƒç”¨å‡½æ•°ã€‚
è¿™ä¸ªå†…è”å‡½æ•°ä¼šæ£€æŸ¥æ˜¯å¦åœ¨ç”¨æˆ·ç©ºé—´ç¯å¢ƒä¸‹è¿è¡Œï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é€šè¿‡ç³»ç»Ÿè°ƒç”¨æœºåˆ¶è½¬å‘åˆ°å†…æ ¸ç©ºé—´çš„å‡½æ•°ã€‚</p>
<p>Zephyr çš„ syscall æœºåˆ¶å¦‚ä½•å·¥ä½œï¼Ÿ</p>
<p>å½“åœ¨ Zephyr ä¸­å†™ä¸‹ï¼š</p>
<pre><code>__syscall int gpio_pin_configure(const struct device *port, gpio_pin_t pin, gpio_flags_t flags);
</code></pre>
<p>è¿™æ¡å£°æ˜å‘Šè¯‰ Zephyrï¼š</p>
<blockquote>
<p>â€œè¿™æ˜¯ä¸€ä¸ªæ”¯æŒ<strong>ç”¨æˆ·ç©ºé—´è°ƒç”¨</strong>çš„ APIï¼Œæˆ‘å¸Œæœ›å®ƒèƒ½åœ¨ç”¨æˆ·æ€æˆ–å†…æ ¸æ€éƒ½å®‰å…¨è¿è¡Œã€‚â€</p>
</blockquote>
<p>ç„¶åæ„å»ºç³»ç»Ÿï¼ˆå€ŸåŠ© Python è„šæœ¬ã€CMake å’Œ devicetree ç¼–è¯‘å™¨ï¼‰ä¼šï¼š</p>
<ol>
<li><strong>ç”Ÿæˆ syscall è·³è½¬ä»£ç </strong></li>
<li><strong>ç”Ÿæˆ <code>z_impl_gpio_pin_configure()</code> çš„è°ƒç”¨å°è£…</strong></li>
<li><strong>ç”Ÿæˆä¸€ä¸ªå°è£…çš„ inline å‡½æ•°ï¼Œæ”¾å…¥ <code>build/zephyr/include/generated/zephyr/syscalls/gpio.h</code></strong></li>
</ol>
<hr />
<p>ğŸ§  æ‰€ä»¥ä½ çœ‹åˆ°çš„è¿™ä¸ªå‡½æ•°ï¼š</p>
<pre><code>static inline int gpio_pin_configure(const struct device *port,
                     gpio_pin_t pin,
                     gpio_flags_t flags)
{
    return z_impl_gpio_pin_configure(port, pin, flags);
}
</code></pre>
<p><strong>è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå±äºâ€œsyscall wrapperâ€</strong>ï¼Œå®ƒçš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ª <strong>dispatcher å‡½æ•°</strong>ã€‚</p>
<hr />
<p>ğŸ” è‡ªåŠ¨ç”Ÿæˆçš„è·¯å¾„ç»“æ„å¦‚ä¸‹ï¼š</p>
<pre><code>build/
â””â”€â”€ zephyr/
    â””â”€â”€ include/
        â””â”€â”€ generated/
            â””â”€â”€ zephyr/
                â””â”€â”€ syscalls/
                    â””â”€â”€ gpio.h    â† â˜…çœ‹åˆ°çš„é‚£ä¸ª
</code></pre>
<p>é‡Œé¢åŒ…å«æ‰€æœ‰å¸¦æœ‰ <code>__syscall</code> çš„ API çš„è‡ªåŠ¨å°è£…ã€‚</p>
<hr />
<p>âœ… ä¸ºä»€ä¹ˆ Zephyr è¦è¿™ä¹ˆåšï¼Ÿ</p>
<p>è¿™æ˜¯ä¸ºäº†æ”¯æŒè¿™ä¸¤ä¸ªæ ¸å¿ƒèƒ½åŠ›ï¼š</p>
<table>
<thead>
<tr>
<th>åœºæ™¯</th>
<th>è¡Œä¸º</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>å†…æ ¸çº¿ç¨‹</strong>è°ƒç”¨ API</td>
<td>ç›´æ¥ inline è°ƒç”¨ <code>z_impl_gpio_pin_configure()</code>ï¼ˆé«˜æ•ˆï¼‰</td>
</tr>
<tr>
<td><strong>ç”¨æˆ·çº¿ç¨‹</strong>è°ƒç”¨ API</td>
<td>è‡ªåŠ¨é€šè¿‡ <code>arch_syscall_invokeX()</code> è¿›å…¥å†…æ ¸ï¼ˆéš”ç¦»ã€å®‰å…¨ï¼‰</td>
</tr>
</tbody>
</table>
<p>æ‰€ä»¥è‡ªåŠ¨ç”Ÿæˆçš„è¿™ä¸ªå°è£…å‡½æ•°ï¼Œå…¶ä½œç”¨å°±æ˜¯ç»Ÿä¸€å°è£…è·¯å¾„ï¼Œ<strong>ç¡®ä¿ syscall è°ƒåº¦æœºåˆ¶æ­£ç¡®æ— è¯¯ä¸”é«˜æ•ˆè¿è¡Œ</strong>ã€‚</p>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">ç›®å½•</div>
    <div class="toc">
<ul>
<li><a href="#gpio">GPIOé©±åŠ¨æ¡†æ¶åˆ†æï¼Œé¡¶å±‚åˆ°åº•å±‚</a></li>
<li><a href="#_1">ç¬¬ä¸€å±‚</a></li>
<li><a href="#_2">ç¬¬äºŒå±‚</a><ul>
<li><a href="#_3">ç‰¹æ€§ï¼š</a></li>
</ul>
</li>
<li><a href="#_4">ç¬¬ä¸‰å±‚</a></li>
<li><a href="#_5">ç¬¬å››å±‚</a></li>
<li><a href="#syscall">syscall æœºåˆ¶</a></li>
</ul>
</div>

</div>
</body>
</html>

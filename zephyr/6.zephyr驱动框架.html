
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>6.zephyr驱动框架</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h2 id="gpio">GPIO驱动框架分析，顶层到底层</h2>
<p>gpio示例分析      zephyr\samples\basic\blinky\src\main.c        使用stm32</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;zephyr/kernel.h&gt;
#include &lt;zephyr/drivers/gpio.h&gt;

/* 1000 msec = 1 sec */
#define SLEEP_TIME_MS   1000

/* The devicetree node identifier for the &quot;led0&quot; alias. */
#define LED0_NODE DT_ALIAS(led0)

/*
 * A build error on this line means your board is unsupported.
 * See the sample documentation for information on how to fix this.
 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

int main(void)
{
    int ret;
    bool led_state = true;

    if (!gpio_is_ready_dt(&amp;led)) {
        return 0;
    }

    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);
    if (ret &lt; 0) {
        return 0;
    }

    while (1) {
        ret = gpio_pin_toggle_dt(&amp;led);
        if (ret &lt; 0) {
            return 0;
        }

        led_state = !led_state;
        printf(&quot;LED state: %s\n&quot;, led_state ? &quot;ON&quot; : &quot;OFF&quot;);
        k_msleep(SLEEP_TIME_MS);  
    }
    return 0;
}
</code></pre>
<p>使用上述中的示例，分析GPIO的驱动框架</p>
<h2 id="_1">第一层</h2>
<p>zephyr\samples\basic\blinky\src\main.c</p>
<pre><code>gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE); 
</code></pre>
<p>应用层抽象 (Devicetree 封装)</p>
<ul>
<li>
<p>把 <strong>设备树（Devicetree）中定义的 GPIO 控制器、引脚号、标志位</strong> 组合为一个 <code>gpio_dt_spec</code> 对象</p>
</li>
<li>
<p>调用 <code>gpio_pin_configure()</code>，传入结构体中提取的 <code>port</code>、<code>pin</code>、<code>flags</code></p>
</li>
<li>
<p>实现平台无关、引脚抽象、应用逻辑清晰</p>
</li>
</ul>
<pre><code class="language-c">struct gpio_dt_spec {
    /** GPIO device controlling the pin */
    const struct device *port;
    /** The pin's number on the device */
    gpio_pin_t pin;
    /** The pin's configuration flags as specified in devicetree */
    gpio_dt_flags_t dt_flags;
};

static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
                    gpio_flags_t extra_flags)
{
    return gpio_pin_configure(spec-&gt;port,
                  spec-&gt;pin,
                  spec-&gt;dt_flags | extra_flags);
}
</code></pre>
<h2 id="_2">第二层</h2>
<p>zephyr\build\zephyr\include\generated\zephyr\syscalls\gpio.h</p>
<pre><code class="language-c">static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
</code></pre>
<p>通用子系统接口 (GPIO API 层)</p>
<ul>
<li>
<p>通过 <code>z_impl_gpio_pin_configure()</code> 实现 <strong>逻辑校验、参数规范化处理</strong></p>
</li>
<li>
<p>是所有 GPIO 子系统的统一接口，提供一致性（无论你是 STM32 还是 Nordic）</p>
</li>
<li>
<h4 id="_3">特性：</h4>
<p>检查 flag 合法性（不能同时上拉和下拉、不能既输出高又输出低等）</p>
<p>处理 <code>GPIO_ACTIVE_LOW</code> / <code>GPIO_OUTPUT_INIT_LOGICAL</code> 等特殊情况</p>
<p>设置运行时数据结构 <code>invert</code> 位</p>
<p>调用第三层驱动接口表中的函数指针</p>
</li>
</ul>
<pre><code class="language-c">/**
 * @brief Runtime device structure (in ROM) per driver instance
 */
struct device {
    /** Name of the device instance */
    const char *name;
    /** Address of device instance config information */
    const void *config;
    /** Address of the API structure exposed by the device instance */
    const void *api;
    /** Address of the common device state */
    struct device_state *state;
    /** Address of the device instance private data */
    void *data;
    /** Device operations */
    struct device_ops ops;
    /** Device flags */
    device_flags_t flags;
#if defined(CONFIG_DEVICE_DEPS) || defined(__DOXYGEN__)
    /**
     * Optional pointer to dependencies associated with the device.
     *
     * This encodes a sequence of sets of device handles that have some
     * relationship to this node. The individual sets are extracted with
     * dedicated API, such as device_required_handles_get(). Only available
     * if @kconfig{CONFIG_DEVICE_DEPS} is enabled.
     */
    Z_DEVICE_DEPS_CONST device_handle_t *deps;
#endif /* CONFIG_DEVICE_DEPS */
#if defined(CONFIG_PM_DEVICE) || defined(__DOXYGEN__)
    /**
     * Reference to the device PM resources (only available if
     * @kconfig{CONFIG_PM_DEVICE} is enabled).
     */
    union {
        struct pm_device_base *pm_base;
        struct pm_device *pm;
        struct pm_device_isr *pm_isr;
    };
#endif
#if defined(CONFIG_DEVICE_DT_METADATA) || defined(__DOXYGEN__)
    const struct device_dt_metadata *dt_meta;
#endif /* CONFIG_DEVICE_DT_METADATA */
};


typedef uint8_t gpio_pin_t;
typedef uint32_t gpio_flags_t;

#define compiler_barrier() do { \
    __asm__ __volatile__ (&quot;&quot; ::: &quot;memory&quot;); \
} while (false)


__syscall int gpio_pin_configure(const struct device *port,
                 gpio_pin_t pin,
                 gpio_flags_t flags);


static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
{
#ifdef CONFIG_USERSPACE
    if (z_syscall_trap()) {
        union { uintptr_t x; const struct device * val; } parm0 = { .val = port };
        union { uintptr_t x; gpio_pin_t val; } parm1 = { .val = pin };
        union { uintptr_t x; gpio_flags_t val; } parm2 = { .val = flags };
        return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_GPIO_PIN_CONFIGURE);
    }
#endif
    compiler_barrier();
    return z_impl_gpio_pin_configure(port, pin, flags);
}
</code></pre>
<h2 id="_4">第三层</h2>
<p>zephyr\include\zephyr\drivers\gpio.h</p>
<pre><code class="language-c">static inline int z_impl_gpio_pin_configure(const struct device *port,
                        gpio_pin_t pin,
                        gpio_flags_t flags)
</code></pre>
<p>驱动绑定接口（驱动函数表）</p>
<ul>
<li>
<p>定义 <code>gpio_driver_api</code> 的结构体，把底层驱动函数填进去</p>
</li>
<li>
<p>注册驱动函数表（函数指针表）供系统统一调度</p>
</li>
<li>
<p>让不同芯片厂商的 GPIO 驱动，都能统一接入 Zephyr API</p>
</li>
</ul>
<pre><code class="language-c">__subsystem struct gpio_driver_api {
    int (*pin_configure)(const struct device *port, gpio_pin_t pin,
                 gpio_flags_t flags);
#ifdef CONFIG_GPIO_GET_CONFIG
    int (*pin_get_config)(const struct device *port, gpio_pin_t pin,
                  gpio_flags_t *flags);
#endif
    int (*port_get_raw)(const struct device *port,
                gpio_port_value_t *value);
    int (*port_set_masked_raw)(const struct device *port,
                   gpio_port_pins_t mask,
                   gpio_port_value_t value);
    int (*port_set_bits_raw)(const struct device *port,
                 gpio_port_pins_t pins);
    int (*port_clear_bits_raw)(const struct device *port,
                   gpio_port_pins_t pins);
    int (*port_toggle_bits)(const struct device *port,
                gpio_port_pins_t pins);
    int (*pin_interrupt_configure)(const struct device *port,
                       gpio_pin_t pin,
                       enum gpio_int_mode mode,
                       enum gpio_int_trig trig);
    int (*manage_callback)(const struct device *port,
                   struct gpio_callback *cb,
                   bool set);
    uint32_t (*get_pending_int)(const struct device *dev);
#ifdef CONFIG_GPIO_GET_DIRECTION
    int (*port_get_direction)(const struct device *port, gpio_port_pins_t map,
                  gpio_port_pins_t *inputs, gpio_port_pins_t *outputs);
#endif /* CONFIG_GPIO_GET_DIRECTION */
};


static DEVICE_API(gpio, gpio_stm32_driver) = {
    .pin_configure = gpio_stm32_config,
#if defined(CONFIG_GPIO_GET_CONFIG) &amp;&amp; !defined(CONFIG_SOC_SERIES_STM32F1X)
    .pin_get_config = gpio_stm32_get_config,
#endif /* CONFIG_GPIO_GET_CONFIG */
    .port_get_raw = gpio_stm32_port_get_raw,
    .port_set_masked_raw = gpio_stm32_port_set_masked_raw,
    .port_set_bits_raw = gpio_stm32_port_set_bits_raw,
    .port_clear_bits_raw = gpio_stm32_port_clear_bits_raw,
    .port_toggle_bits = gpio_stm32_port_toggle_bits,
    .pin_interrupt_configure = gpio_stm32_pin_interrupt_configure,
    .manage_callback = gpio_stm32_manage_callback,
};

static inline int z_impl_gpio_pin_configure(const struct device *port,
                        gpio_pin_t pin,
                        gpio_flags_t flags)
{
    const struct gpio_driver_api *api =
        (const struct gpio_driver_api *)port-&gt;api;
    __unused const struct gpio_driver_config *const cfg =
        (const struct gpio_driver_config *)port-&gt;config;
    struct gpio_driver_data *data =
        (struct gpio_driver_data *)port-&gt;data;
    int ret;

    SYS_PORT_TRACING_FUNC_ENTER(gpio_pin, configure, port, pin, flags);

    __ASSERT((flags &amp; GPIO_INT_MASK) == 0,
         &quot;Interrupt flags are not supported&quot;);

    __ASSERT((flags &amp; (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
         (GPIO_PULL_UP | GPIO_PULL_DOWN),
         &quot;Pull Up and Pull Down should not be enabled simultaneously&quot;);

    __ASSERT(!((flags &amp; GPIO_INPUT) &amp;&amp; !(flags &amp; GPIO_OUTPUT) &amp;&amp; (flags &amp; GPIO_SINGLE_ENDED)),
         &quot;Input cannot be enabled for 'Open Drain', 'Open Source' modes without Output&quot;);

    __ASSERT_NO_MSG((flags &amp; GPIO_SINGLE_ENDED) != 0 ||
            (flags &amp; GPIO_LINE_OPEN_DRAIN) == 0);

    __ASSERT((flags &amp; (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
         || (flags &amp; GPIO_OUTPUT) != 0,
         &quot;Output needs to be enabled to be initialized low or high&quot;);

    __ASSERT((flags &amp; (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
         != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
         &quot;Output cannot be initialized low and high&quot;);

    if (((flags &amp; GPIO_OUTPUT_INIT_LOGICAL) != 0)
        &amp;&amp; ((flags &amp; (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
        &amp;&amp; ((flags &amp; GPIO_ACTIVE_LOW) != 0)) {
        flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    }

    flags &amp;= ~GPIO_OUTPUT_INIT_LOGICAL;

    __ASSERT((cfg-&gt;port_pin_mask &amp; (gpio_port_pins_t)BIT(pin)) != 0U,
         &quot;Unsupported pin&quot;);

    if ((flags &amp; GPIO_ACTIVE_LOW) != 0) {
        data-&gt;invert |= (gpio_port_pins_t)BIT(pin);
    } else {
        data-&gt;invert &amp;= ~(gpio_port_pins_t)BIT(pin);
    }

    ret = api-&gt;pin_configure(port, pin, flags);
    SYS_PORT_TRACING_FUNC_EXIT(gpio_pin, configure, port, pin, ret);
    return ret;
}
</code></pre>
<p>调用  <strong>ret = api-&gt;pin_configure(port, pin, flags);</strong>   进入下一层</p>
<h2 id="_5">第四层</h2>
<p>zephyr\drivers\gpio\gpio_stm32.c</p>
<pre><code class="language-c">static int gpio_stm32_config(const struct device *dev,
                 gpio_pin_t pin, gpio_flags_t flags)
</code></pre>
<ul>
<li>硬件驱动实现（芯片厂商相关代码）</li>
</ul>
<pre><code class="language-c">/**
 * @brief Configure pin or port
 */
static int gpio_stm32_config(const struct device *dev,
                 gpio_pin_t pin, gpio_flags_t flags)
{
    int err;
    uint32_t pincfg;
    struct gpio_stm32_data *data = dev-&gt;data;

    /* figure out if we can map the requested GPIO
     * configuration
     */
    err = gpio_stm32_flags_to_conf(flags, &amp;pincfg);
    if (err != 0) {
        return err;
    }

    /* Enable device clock before configuration (requires bank writes) */
    if ((((flags &amp; GPIO_OUTPUT) != 0) || ((flags &amp; GPIO_INPUT) != 0)) &amp;&amp;
        !(data-&gt;pin_has_clock_enabled &amp; BIT(pin))) {
        err = pm_device_runtime_get(dev);
        if (err &lt; 0) {
            return err;
        }
        data-&gt;pin_has_clock_enabled |= BIT(pin);
    }

    if ((flags &amp; GPIO_OUTPUT) != 0) {
        if ((flags &amp; GPIO_OUTPUT_INIT_HIGH) != 0) {
            gpio_stm32_port_set_bits_raw(dev, BIT(pin));
        } else if ((flags &amp; GPIO_OUTPUT_INIT_LOW) != 0) {
            gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
        }
    }

    gpio_stm32_configure_raw(dev, pin, pincfg, 0);

#ifdef CONFIG_STM32_WKUP_PINS
    if (flags &amp; STM32_GPIO_WKUP) {
#ifdef CONFIG_POWEROFF
        struct gpio_dt_spec gpio_dt_cfg = {
            .port = dev,
            .pin = pin,
            .dt_flags = (gpio_dt_flags_t)flags,
        };

        if (stm32_pwr_wkup_pin_cfg_gpio((const struct gpio_dt_spec *)&amp;gpio_dt_cfg)) {
            LOG_ERR(&quot;Could not configure GPIO %s pin %d as a wake-up source&quot;,
                    gpio_dt_cfg.port-&gt;name, gpio_dt_cfg.pin);
        }
#else
        LOG_DBG(&quot;STM32_GPIO_WKUP flag has no effect when CONFIG_POWEROFF=n&quot;);
#endif /* CONFIG_POWEROFF */
    }
#endif /* CONFIG_STM32_WKUP_PINS */

    /* Decrement GPIO usage count only if pin is now disconnected after being connected */
    if (((flags &amp; GPIO_OUTPUT) == 0) &amp;&amp; ((flags &amp; GPIO_INPUT) == 0) &amp;&amp;
        (data-&gt;pin_has_clock_enabled &amp; BIT(pin))) {
        err = pm_device_runtime_put(dev);
        if (err &lt; 0) {
            return err;
        }
        data-&gt;pin_has_clock_enabled &amp;= ~BIT(pin);
    }

    return 0;
}
</code></pre>
<h2 id="syscall">syscall 机制</h2>
<p>参考链接：https://www.cnblogs.com/ttwards/p/18449137</p>
<p>上述中发现，函数  gpio_pin_configure   路径为    zephyr\build\zephyr\include\generated\zephyr\syscalls\gpio.h</p>
<pre><code class="language-c">static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
</code></pre>
<p>zephyr\build 这个路径是编译后的路径，难道是编译先生成 gpio.h文件   再继续编译 ？</p>
<ul>
<li>
<p>函数 <strong>不是由写的代码自动生成的</strong>，而是由 Zephyr 的 syscall 机制 <strong>生成了一个封装版本</strong></p>
</li>
<li>
<p>Zephyr 支持用户空间和内核空间的分离，用户空间代码不能直接调用内核空间的函数。</p>
</li>
</ul>
<p>为了实现这一点，Zephyr 使用系统调用机制，允许用户空间代码通过特定的接口调用内核空间的函数。这样也提升了稳定性和可维护性。</p>
<p><code>__syscall</code> 关键字用于标记一个函数为系统调用函数。它告诉编译器和 <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/scripts/build/gen_syscalls.py"><code>gen_syscalls.py</code></a> 脚本，这个函数需要生成系统调用接口</p>
<p><code>gen_syscalls.py</code> 脚本会生成一个内联函数，用于在用户空间调用该系统调用函数。
这个内联函数会检查是否在用户空间环境下运行，如果是，则通过系统调用机制转发到内核空间的函数。</p>
<p>Zephyr 的 syscall 机制如何工作？</p>
<p>当在 Zephyr 中写下：</p>
<pre><code>__syscall int gpio_pin_configure(const struct device *port, gpio_pin_t pin, gpio_flags_t flags);
</code></pre>
<p>这条声明告诉 Zephyr：</p>
<blockquote>
<p>“这是一个支持<strong>用户空间调用</strong>的 API，我希望它能在用户态或内核态都安全运行。”</p>
</blockquote>
<p>然后构建系统（借助 Python 脚本、CMake 和 devicetree 编译器）会：</p>
<ol>
<li><strong>生成 syscall 跳转代码</strong></li>
<li><strong>生成 <code>z_impl_gpio_pin_configure()</code> 的调用封装</strong></li>
<li><strong>生成一个封装的 inline 函数，放入 <code>build/zephyr/include/generated/zephyr/syscalls/gpio.h</code></strong></li>
</ol>
<hr />
<p>🧠 所以你看到的这个函数：</p>
<pre><code>static inline int gpio_pin_configure(const struct device *port,
                     gpio_pin_t pin,
                     gpio_flags_t flags)
{
    return z_impl_gpio_pin_configure(port, pin, flags);
}
</code></pre>
<p><strong>自动生成的，属于“syscall wrapper”</strong>，它的本质就是一个 <strong>dispatcher 函数</strong>。</p>
<hr />
<p>🔍 自动生成的路径结构如下：</p>
<pre><code>build/
└── zephyr/
    └── include/
        └── generated/
            └── zephyr/
                └── syscalls/
                    └── gpio.h    ← ★看到的那个
</code></pre>
<p>里面包含所有带有 <code>__syscall</code> 的 API 的自动封装。</p>
<hr />
<p>✅ 为什么 Zephyr 要这么做？</p>
<p>这是为了支持这两个核心能力：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内核线程</strong>调用 API</td>
<td>直接 inline 调用 <code>z_impl_gpio_pin_configure()</code>（高效）</td>
</tr>
<tr>
<td><strong>用户线程</strong>调用 API</td>
<td>自动通过 <code>arch_syscall_invokeX()</code> 进入内核（隔离、安全）</td>
</tr>
</tbody>
</table>
<p>所以自动生成的这个封装函数，其作用就是统一封装路径，<strong>确保 syscall 调度机制正确无误且高效运行</strong>。</p>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul>
<li><a href="#gpio">GPIO驱动框架分析，顶层到底层</a></li>
<li><a href="#_1">第一层</a></li>
<li><a href="#_2">第二层</a><ul>
<li><a href="#_3">特性：</a></li>
</ul>
</li>
<li><a href="#_4">第三层</a></li>
<li><a href="#_5">第四层</a></li>
<li><a href="#syscall">syscall 机制</a></li>
</ul>
</div>

</div>
</body>
</html>

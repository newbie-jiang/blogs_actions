## 日志



2024/11/7

- [x] RTL8735B 调整视频流与音频流，将视频流H264与音频流合并，通过RTSP串流到VLC一个通道，

- [x] 在VLC软件中,调整缓存时间为10ms(降低缓存时间会降低延迟)，我的电脑测试传输最大延迟范围在700ms左右，李经理笔记本测试延迟在500ms左右，两者不一致可能与网卡有关

- [ ] 原分辨率为1920 * 1080 30fps 更改为 640 * 480 30fps  未实现，更改参数无效，打印报错缓存不够？由于使用静态库封装，无法查找到打印信息，错误信息如下

  [VID Wrn]VOE CH0 ENC queue full (queue/used/out/rsvd) 0/0KB2085KB37KB

  表示编码器的队列已满，编码器的缓冲队列空间已用尽，无法接收新的数据



2024/11/11

- [x]  JPEG + H264双通道串流实现
- [ ] 动态检测demo测试ok ，**h264串流ok 且可以完成动态检测，jpeg串流失败**
- [ ] osd (on screen display) 测试sntp获取网络时间ok，串流显示到屏幕还未实现

   OSD实现思路：

- 监控设备的处理器**周期性读取时间**（每秒更新一次）。
- 然后使用**图形叠加**（Graphics Overlay）将时间信息渲染到视频画面上。在视频帧生成或编码之前进行时间叠加，以便时间成为视频画面的一部分。
- 监控系统会在每一帧的顶部区域生成一个文本图层，显示时间戳。
- 生成的时间戳信息可以直接叠加到每一帧图像中，通过软件算法，将时间文本绘制在帧的左上角。
- 一旦时间叠加完成，视频帧就会进入编码阶段，生成 H.264或 MJPEG 等格式，并通过 RTSP 协议输出。
- **OSD 叠加的时间信息成为视频帧的一部分**，因此最终的流媒体中已经包含了左上角的时间显示。



## 2024/11/12

- [x] RTL8735  OSD（on screen display）实现

![480483da2a6ef854dd6508580518605](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/480483da2a6ef854dd6508580518605.png)



- [x] 富芮坤 ADC io确定 **PD6**，在富芮坤demo板改变电压采集adc值验证ok

![image-20241112180004968](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241112180004968.png)



## 2024/11/13

- [x] 多圈旋转电位器 AD检测， 数据小幅抖动，使用   **中值滤波**，6个窗口值    实际检测效果理想

![image-20241113170135263](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241113170135263.png)

- [x] 检测电机是否阻塞完成
  - 实现原理：（线性状态：电机转动时ad值减小） 五个缓冲区存储历史数据，**最新数据** 与 **最旧数据**作比较，最新数值无变化或比原来的值大则判定发生阻塞，下一次来数据时，数据左移再次判断

![image-20241113170248154](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241113170248154.png)



## 2024/11/15

- [x] 完成电机阻塞报警
- [x] 完成低电量报警
- [x] 完成输注完成报警（无药量时）

- [ ] 完成电池待机时长理论计算(睡眠时间：1分钟      唤醒时间：500毫秒  电池遵循IEC标准，可运行15天

   ，还未定下来实际速度，需结合速度再次计算理论值并实际测试，测试按照30mA/h电流消耗，预计需花费一整天

- [x] 输注速度匹配实验

  参数：

  - 胰岛素泵 管内壁直径为3mm,
  - 胰岛素泵的速度为 0.5u - 30u / h    (1u = 0.01ml = 10ul )
  - 电机齿轮转一圈的长度为18mm

  

  齿轮转动一周走的体积为 = 1.5 x 1.5 x 3.14 x 18mm = 0.12723ml =  12.72u  

  ## 实验1：

  停止2s，运动50ms    运动一圈用时1min 16s 

  运动一圈步数为   76 / 2.05 =  37步   

  一步的量    12.72 / 37 =  0.344u / 步    

  按照0.5u-30u /h 对应的步数为  0.5u

  0.5 - 30u        0.5/0.334 = 2步     30/0.334 = 90步  

  实验结论：按照0.5u /h 时，精度较差

  

  ## 实验2：

  停止1s 运动10ms,运动一圈用时5min 53 s  = 353s   

  运动一圈步数为 353 /  1.01 = 349.5 步

  一步的量  12.72u / 349.5 = 0.0363 U

  按照0.5u-30u /h  对应步数为 0.5/0.0363 =  13.8 步   ---    30/0.0363 = 826步

  按照最大量计算1h 需要运动 826步 平均 4s 走一步，对功耗要求较大，该实验的运动时间不可靠

  实验结论：按照30u /h时，唤醒频繁，功耗较大

  

  **上述两个实验，实验1 运行50ms 步数偏大，实验2运行10ms步数偏小，理想的数据在 一次运动30ms左右**

  

  ## 实验3：
  
  停止1s 运动30ms，运动一圈用时1min  7s = 67s
  
  运动一圈的步数为 67/1.03 = 65步
  
  一步的量 12.72 / 65 = 0.1957u
  
  按照   0.5u-30u /h  对应步数为 0.5/0.1957 =  2.5 步   ---    30/0.1957 = 153.3步
  
  按照最小计算量  1h 走2.5步    按照最大计算量1h走153步，23.5 s走一步
  
  当前情况下不能精准做到0.5U/h,对于最大剂量很少用到，为保证准确度，继续降低时间，
  
  
  
  ## 实验4：
  
  停止1s，运动20ms，运动一圈用时  2min
  
  运动一圈的步数为120/1.02 = 117步
  
  一步的量 12.72 / 117 = 0.1087U
  
  按照   0.5u-30u /h  对应步数为 0.5/0.1087 =  5 步   ---    30/0.1087 = 276 步
  
  按照 最小基础率的速度为 20min 一次    按照最大基础率的速率为13s   一次
  
  当前参数下，基础率对应电机关系
  
  0.5 U         20min/次
  
  1 U            10min/次
  
  2u              5 min/次
  
  
  
  **实际测试下，运动20ms一步适合当下情况**
  
  
  
  - [x] CR2450 纽扣电池电压变化曲线理论分析：
  
  ![a440fc135fd48c90eb765b0090b97c8](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/a440fc135fd48c90eb765b0090b97c8.png)
  
  负载在7.5k时，此时电流在0.4mA,  电压在3.3V - 3.0V 下降很快，之后在 3.0V- 2.8V 趋于稳定，
  
  实际测试：使用过程带负载的情况下，

**实验5**

电压3v时测试，停止1s，运动20ms，运动一圈用时  2min

电压2.8v时测试，停止1s，运动20ms，运动一圈用时  2min 15s

实际测试：电压在降低时，电机的转速会降低，   **检测电压降低时，使用补偿的方式对电机速度进**行补偿**



移植cjson: 

- [x] 为方便数据的统一管理，蓝牙使用cjson格式数据进行收发，移植已完成，基础测试通过

  ![](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241118180535173.png)

定义cjson格式数据，还未完全定义好（初步实现）

**运行状态（发送）**

```c
{
   "running":
   {
    "states":"run"              // "run"  
    "remainder drug":"xx.x"     // 剩余药量 xx.x 整数部分两位数，小数部分一位数
    "have finished drug":"xx.x" // 已入药量 xx.x 整数部分两位数，小数部分一位数
    "basal rate":"basal rate 1" // 基础率1  / 基础率2  / 基础率3 
   }
}
```

**停止状态（发送）**

```c
{
   "stop":
   {
    "states":"stop"             // "stop"
    "remainder drug":"xx.x"     // 剩余药量 xx.x 整数部分两位数，小数部分一位数
    "have finished drug":"xx.x" // 已入药量 xx.x 整数部分两位数，小数部分一位数
    "basal rate":"basal rate 1" // 基础率1  / 基础率2  / 基础率3 
    "history infusion":
    {
      "01":"xx.x"
      "02":"xx.x"
      "03":"xx.x"
      "04":"xx.x"
      "05":"xx.x"
    }
   }
}
```



## 2024//11/19



**接收数据：**

- [x] 蓝牙接收数据解析实现部分（数据存储方式为结构体，使用时访问结构体成员）

```
 typedef struct basal_rate_information{
	
	char  basal_rate_num; //基础率段数
	float basal_rate_speed;//基础率速度 扩大十倍
	
	char basal_rate_start_tim_hh;  //起始时间hh
	char basal_rate_start_tim_min; //起始时间min
	
	char basal_rate_end_tim_hh;    //结束时间hh
	char basal_rate_end_tim_min;   //结束时间min
	
}basal_rate_information;
  

//同步时间
 typedef struct sync_tim{
	 char sync_tim_hh;
	 char sync_tim_min;
	 char sync_tim_s;
}sync_tim;
 

//大剂量设定
typedef struct large_dose{
  	float large_dose_liquid; //大剂量液量
	float large_dose_speed;  //大剂量速度
}large_dose_information;
```

**基础率指令**

```json
{
  "basal_rate": {
    "basal_rate_num": "2", //第几段基础率
    "speed": "8.5",        //基础率速度
    "basal_rate_tim": "01:03:28-20:30:30" //当前段的基础率  起始时间 - 结束时间
  }
}   

测试指令
{
  "basal_rate": {
    "basal_rate_num": "1",
    "speed": "8.5",        
    "basal_rate_tim": "00:00:00-20:30:00"
  }
}   
```

**时间同步指令**

```json
{
  "sync_tim": {      
    "now_tim": "12:20:30"   //当前同步时间
  }
}  

测试指令
{
  "sync_tim": {      
    "now_tim": "12:20:30"
  }
}  
```

**大剂量指令**

```json
  {
   "large_dose": 
   {      
     "large_dose_liquid": "2.5", //大剂量液量设置
     "large_dose_speed": "2.5"   //大剂量速度设置
   }
  }
  
  测试指令
   {
   "large_dose": 
   {      
     "large_dose_liquid": "2.5",
     "large_dose_speed": "2.5"
   }
  }
```



**ack指令：**

- [ ] 接收到数据后应答指令   从机发送出去  (未完全实现 未验证)：

```
//基础率
{
  "basal_rate": {
    "basal_rate_num": "2", //第几段基础率
    "speed": "8.5",        //基础率速度
    "basal_rate_tim": "01:03:28-20:30:30" //当前段的基础率  起始时间 - 结束时间
  }
} 

//时间同步
{
  "sync_tim": {      
    "now_tim": "12:20:30"   //当前同步时间
  }
} 
//大剂量
 {
   "large_dose": 
   {      
     "large_dose_liquid": "2.5", //大剂量液量设置
     "large_dose_speed": "2.5"   //大剂量速度设置
   }
  }
```



## 2024/11/20

- [x] 实现ack指令并测试通过

- 基础率ack
- 时间同步ack
- 大剂量ack

当ack的关键数据与发送的数据一致时，判定为一个成功的数据包

![b987d460c7f6ca3a09dd2eff8c563f0](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/b987d460c7f6ca3a09dd2eff8c563f0.jpg)



**RTC 时间同步**

- [x] 实现RTC实时时间显示，蓝牙指令可更改当前时间,在使用过程中，连接到手机可自动获取时间更新到设备上

  可同步的参数      年，月，日    时，分，秒

  ![image-20241120150656442](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241120150656442.png)

通过蓝牙指令可更改当前时间

```
{
  "sync_tim": {      
    "now_tim": "2024-08-29 12:22:00"
  }
} 
```



**基础率设定**

基础率 控制睡眠的时间，启动时间为20ms，之后进入休眠，基础率的速度 直接影响睡眠时间

基础率--->睡眠时间



**基础率与休眠时间的关系式：**  

20ms  一步的量 0.1087U

0.5  / 0.1087  =   5步 （1h）

3600 / 5 =  720s



基础率 x 

tim（ 秒） = 3600 /  (x / 0.1087)步





停止1s，运动20ms，运动一圈用时  2min

运动一圈的步数为120/1.02 = 117步

一步的量 12.72 / 117 = 0.1087U



基础率段数 --->当前的基础率段数（起始时间，结束时间）





功能： 20min睡眠  1s 唤醒

如何打开手机与蓝牙设备的数据收发

如何打开手机与蓝牙设备的收发？1



## 2024/11/21

- [x] 理解蓝牙工作模式 ，与 胡工 讨论胰岛素泵  ，确定胰岛素泵与手机app的连接过程



1.系统启动时，进入低功耗广播，等待设备连接，

2.设备连接，胰岛素泵发出响声，按键确认后 建立连接（后续连接无需按 按键，保存连接设备信息）

3.建立连接后手机可配置胰岛素泵，与查看胰岛素泵的信息

4.退出app时(app在后台运行)，主动断开蓝牙连接，睡眠与广播交替，等待再次建立连接

5.打开app时(app在后台运行)，主动扫描已存在的设备并建立连接

6.app在后台运行时，间隔30min主动扫描胰岛素泵设备建立连接，获取交互数据，完成后主动断开连接



**BLE设备的主要状态**

1. **待机状态（Standby State）**

- 描述
  - BLE设备默认处于待机状态，所有无线通信模块都关闭以节省能耗。
  - 只有外部事件（如定时器、外部中断）或应用程序请求才能将设备从待机状态唤醒。
- **功耗**：最低。
- **使用场景**：无操作时的默认状态。

2. **广播状态（Advertising State）**

- 描述
  - 从机通过广播信道（37、38、39）发送广播包，向主机发出存在信号。
  - 广播包中可以包含设备的基本信息（如名称、服务UUID等）。
- 类型
  - 可连接广播（Connectable Advertising）
    - 主机可以扫描到广播并请求连接。
  - 不可连接广播（Non-connectable Advertising）
    - 仅用于发送广播信息，不接受连接请求。
  - 定向广播（Directed Advertising）
    - 广播仅针对特定的主机地址。
  - 扫描响应广播（Scannable Advertising）
    - 可被主机扫描，主机收到广播后可以请求额外信息（扫描响应数据）。
- **功耗**：广播间隔较短时功耗较高，间隔长时功耗较低。
- **使用场景**：设备待连接、周期性广播数据等。

3. **扫描状态（Scanning State）**

- 描述
  - 主机设备在广播信道上扫描，从广播包中发现附近的BLE设备。
  - 如果扫描到目标设备，可以请求额外信息（扫描响应）。
- 类型
  - 主动扫描（Active Scanning）
    - 主机不仅接收广播包，还发送扫描请求，以获取扫描响应数据。
  - 被动扫描（Passive Scanning）
    - 主机仅接收广播包，不发送任何请求，功耗更低。
- **功耗**：取决于扫描间隔和扫描窗口的设置。
- **使用场景**：主机寻找目标设备。

4. **连接状态（Connection State）**

- 描述
  - 主机与从机建立连接后，双方通过已建立的连接信道进行数据通信。
  - 进入此状态后，从机会停止广播，主机会停止扫描。
- 特性
  - 数据传输使用加密和校验，连接更可靠。
  - 可以通过连接参数（如连接间隔、数据包大小）优化功耗。
- 功耗
  - 功耗由通信频率（连接间隔）和数据传输量决定，间隔较长时功耗较低。
- **使用场景**：文件传输、实时数据交互（如传感器数据）。



**BLE工作状态切换图**

以下是典型的状态切换路径：

1. 从机（Slave Device）

   - **待机** → **广播** → （主机连接请求） → **连接** → （断开连接） → **广播或待机**。

2. 主机（Master Device）

   - **待机** → **扫描** → （发现设备） → **连接请求** → **连接** → （断开连接） → **扫描或待机**。

   

------

**BLE状态优化功耗的关键**

1. **广播优化**：
   - 增大广播间隔（如100ms到几秒）。
   - 选择不可连接广播以降低功耗。
2. **扫描优化**：
   - 使用被动扫描。
   - 增大扫描间隔并缩短扫描窗口。
3. **连接优化**：
   - 增大连接间隔（如100ms以上）。
   - 减少数据传输量。
4. **待机优化**：
   - 尽可能让设备保持待机状态，使用低功耗定时器唤醒。



- [x] 实现低功耗广播,广播时间间隔6s，广播时长10ms，

  

设置广播的间隔时间 6s

sp_start_adv函数中

	adv_param.adv_intv_min = 6000;
	adv_param.adv_intv_max = 6000;

睡眠模式时，电流为10uA,唤醒时瞬间最大电流为0.5mA,

gap_start_advertising(); 函数设置广告事件持续时间



## 2024/11/22



电机运行逻辑，蓝牙连接上参数设置（基础率 大剂量  同步时间），将网络时间同步至胰岛素泵，胰岛素泵依据设定基础率与大剂量，自动计算唤醒时间，主动唤醒电机运行，并将日志存储下来，等待下一次连接时将日志数据同步至手机

问题拆解： 

- [x] 进入睡眠时系统rtc应该处于运行状态，蓝牙连接时自动同步系统时间,保证系统时间的准确性 
- [x] 蓝牙连接时候正常工作，蓝牙断开时低功耗广播
- [ ] 依据设定的各个基础率段，自动计算唤醒时间点，唤醒 电机运行后主动休眠
- [ ] 依据设定的大剂量(延长双波大剂量)，更新大剂量所处时间段的唤醒时间，唤醒 电机运行后主动休眠
- [ ] 指定时间唤醒设备运行电机
- [ ] 每一次唤醒电机，电机运行后将时间，以及输注剂量存储在flash内部, flash的大小至少保证日志存储10天



目前存在问题：

第一次休眠时，低功耗正常，启动task后再进入睡眠状态功耗较高，应该是某部分外设未解初始化，



- 获取连接状态

**bool gap_get_connect_status(uint8_t conidx)**；

![image-20241122084538658](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122084538658.png)



- [x] 实现低功耗逻辑，连接到蓝牙设备时候时mcu进入正常工作模式，此时可进行数据的收发，检测到断开蓝牙的连接时，进入低功耗广播状态， 电流表测量电流正常工作时电流为8.5mA, 断开连接，低功耗状态为10uA,广播时功耗为0.7mA

- 进入睡眠前检测蓝牙是否处于连接状态，蓝牙已连接则关闭睡眠

![image-20241122100005897](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122100005897.png)

- 检测到蓝牙断开连接，则开启睡眠模式

![image-20241122100125104](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122100125104.png)



- 蓝牙建立连接后启动任务

void app_gap_evt_cb(gap_event_t *p_event)

![image-20241122173338237](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122173338237.png)



## 2024/11/23

- [x] 解决昨天的 第一次休眠时，低功耗正常，启动task后再进入睡眠状态功耗较高，应该是某部分外设未解初始化，

  - 原因是在销毁task之前未解初始化adc，在进入睡眠前调用 adc_disable(); 即可关闭adc的调用，实际测试过程中，正常工作模式开启adc的功能会比较耗电，电流为2mA/h左右

  

依据设定的各个基础率段，自动计算唤醒时间点，唤醒 电机运行后主动休眠

输入数据： 时间段，基础率  --->    输出功能为    自动计算唤醒时间点，唤醒后电机再次休眠

- 依据输入时间段自动计算唤醒时间点
- 在唤醒时间点自动唤醒，启动电机后进入休眠状态   (电机启动时完成一次数据交互，包括时间同步，数据获取，电池电量，剩余液量)



- [ ] 依据输入时间段自动计算时间点代码完成，测试时 计算时间较长会导致系统卡死

问题所在

//唤醒时间点
typedef struct weak_up_tim{
   uint16_t hh;
   uint16_t min;
   uint16_t s;
}weak_up_tim;

定义结构体数组未指定大小  weak_up_tim  wake_up_times[ ] = {0};

 weak_up_tim  wake_up_times[7000 ] = {0};

指定大小后 其数组较大，存储在静态区，没有溢出但系统频繁重启，可能是静态库中的限制

考虑不一次性存储所有时间，每次启动时，只要计算出下一个启动时间即可，（优点，占用ram较少，缺点，每次唤醒启动时都要计算时间，额外增加功耗）



## 2024/11/25

- [x] 完成单段基础率并实际测试成功，蓝牙连接状态下，蓝牙非连接状态下都可

应用：开机时未设置基础率，电机不会运行，开机首先自动同步时间至系统(由APP端完成)，再发送基础率指令，系统开始运行

{
  "sync_tim": {      
    "now_tim": "2024-11-20 20:20:10"
  }
} 



{
     "basal_rate":   
    {
     "basal_rate_num": "1",
     "speed": "0.5",          
     "basal_rate_tim": "01:30-02:30" 
    }
   }   



- [x] 使用C语言实现串口数据的接收，并将原本倒置的数据反过来，并在接收的数据前加上时间戳

- 由于电子秤使用连续发送指令，发过来的数据较快，使用串口上位机接收数据会导致上位机卡死或识别不到串口，更换电子秤的为指令发送较为理想

![](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241125172638976.png)

- 发送数据较快，打开不了该串口同时数据不好处理

![image-20241125171907614](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241125171907614.png)

- [ ] 已安装虚拟串口助手，明天调试指令发送的程序，并将数据加上时间戳，保存至日志文件中，换货的电子秤到手就可以用

## 2024/11/26

- [x] 使用C语言虚拟电子秤作为从机串口通信，

- 发送R时返回一个数据

![image-20241126103208232](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126103208232.png)

- [x] PC作为主机，主动发送R获取数据，并将接收数据加上时间戳写入日志文件

![image-20241126103349041](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126103349041.png)

- 日志文件

![image-20241126103441844](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126103441844.png)

- [ ] 使用python实现数据可视化

安装python解释器   https://www.python.org/downloads/

安装依赖库：打开cmd窗口使用命令行安装

E:/software/python3.13/python.exe -m pip install matplotlib    (其中software/python3.13为python解释器的路径，需依据自己的环境更改)

可视化数据分析，横轴应该为时间，纵轴应该为数据，同时显示的数据应该可以设置显示时间间隔，与在screen显示的时间段

- 横轴时间   
- 纵轴数据
- 时间间隔调整 
- 显示时间段调整  

该启动程序在master目录下

![image-20241126140715302](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126140715302.png)





## 2024/11/27

- [x] 昨天电子秤上位机bug更改完成
- [x] 新增动态数据更新，可实时显示串口数据，新增时间动态调整，左右滑动时网格有动态效果

![image-20241127181213622](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241127181213622.png)



## 2024/11/28

- [x] 上午：产线拆机

​       下午：

- [x] 多段基础率设置成功 初步测试通过

开机启动时，时间为12:00:00，蓝牙连接输入以下指令，将按照不同时间段不同速度运行

  { "basal_rate": { "basal_rate_num": "1", "speed": "30", "basal_rate_tim": "00:00-12:00" } } 
  { "basal_rate": { "basal_rate_num": "2", "speed": "25", "basal_rate_tim": "12:00-12:05" } } 
  { "basal_rate": { "basal_rate_num": "3", "speed": "30", "basal_rate_tim": "12:05-12:10" } } 
  { "basal_rate": { "basal_rate_num": "4", "speed": "25", "basal_rate_tim": "12:10-23:59" } } 



![image-20241128173457537](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241128173457537.png)

![image-20241128173632668](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241128173632668.png)

## 2024/11/29

- [x] 了解胰岛素泵中的 “方波” 和 “双波” 

方波和双波模式主要与**餐后追加胰岛素（Bolus insulin）相关，而非基础率（Basal rate）。它们用于在进餐后根据具体饮食情况调整胰岛素的释放模式，属于额外释放**的剂量，与基础率无直接关系。

1. **基础率（Basal rate）**

基础率是胰岛素泵**持续释放**的微量胰岛素，用于维持身体的基本代谢需求。基础率的作用是覆盖非进餐时间的胰岛素需求，例如夜间和空腹状态下的血糖控制。它是一个背景释放量，并不随着进餐变化而改变。

------

2. **方波和双波的作用**

方波和双波模式属于**追加剂量（Bolus insulin）\**的释放方式，专门针对进餐后血糖的波动设计，用来处理餐后血糖上升的问题。它们是餐前根据食物类型和量计算的\**额外剂量**，与基础率分开管理。

- **方波（Square Wave Bolus）**： 在进餐后的一段时间内**持续增加释放量**，但这种释放是缓慢且均匀的。适合慢消化、高脂高蛋白的食物。
- **双波（Dual Wave Bolus）**： 在进餐后，先释放一部分胰岛素（快速处理碳水化合物引起的血糖快速上升），随后再以方波方式缓慢释放剩余胰岛素。适合混合饮食或复杂的进餐场景。



**是否在基础率上叠加？**

不是在基础率上直接叠加，而是**独立计算并额外释放**的剂量。这些模式的设定不会改变基础率，但与基础率的释放是同时进行的：

- **基础率**始终运行，提供背景胰岛素。
- **方波或双波模式的释放**是针对进餐后短时间内的需求，并由使用者或医生根据具体餐后血糖特点决定。

示例场景

假设：

- **基础率**设置为每小时0.5单位胰岛素。
- 根据进餐食物计算，餐后需要追加10单位的胰岛素。
- 使用**普通模式**：一次性释放10单位。
- 使用**方波模式**：10单位在4小时内均匀释放，每小时增加2.5单位，合计每小时释放3单位（0.5基础率 + 2.5方波释放）。
- 使用**双波模式**：5单位立即释放，剩余5单位以方波方式在4小时内均匀释放，每小时额外增加1.25单位，合计每小时释放1.75单位（0.5基础率 + 1.25方波释放）。

总结：大剂量设定的方波，双波与基础率设定无关，与基础率的释放是同时进行的



- [x] 同类产品的大剂量功能参考

**参考1**

参考链接 https://endo.dxy.cn/specials/hsnfm/article/530629

下图中可以看到，方波设置的参数有  **剂量**  **持续时间**

![image-20241129105428127](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129105428127.png)

下图中可以看到，双波设置的参数有  **剂量**   方波大剂量

双波设定  首先输入总剂量，一半立马释放，剩下的一半作为方波缓慢释放

![image-20241129105731607](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129105731607.png)

上述可以看到，双波立马会释放一半的量，剩下的一半为方波缓慢释放，双波立马输注的量总是一半么？

查询资料，大剂量的分配可以根据饮食和个体需求调整，以下是常见的比例设定：

1. **50% / 50% 分配**
   - **50%立即释放**（快速波），**50%缓慢释放**（方波）。
   - 适用于大多数**混合饮食**（含碳水、脂肪和蛋白质）或不确定消化速度的情况。
2. **60% / 40% 分配**
   - **60%立即释放**，**40%缓慢释放**。
   - 适用于以碳水化合物为主的饮食，快速升高血糖，但有部分延迟消化的成分。
3. **30% / 70% 分配**
   - **30%立即释放**，**70%缓慢释放**。
   - 适用于脂肪含量高、蛋白质比例大的食物（如披萨、芝士蛋糕），这些食物通常导致更缓慢的血糖上升。

**参考2**

参考链接:https://www.sohu.com/a/353194903_621323

上述文章中指出了，有一些型号的胰岛素泵的大剂量输注有3种方式（以福尼亚新二代胰岛素泵为例），分为“**常规大剂量**”、“**方波大剂量”、“双波大剂量”。**

“**方波大剂量”、“双波大剂量”。**上述中有说明

常规大剂量适用于餐前立马输注，相当于双波的前一段，该输注方式的特点是在短时间内释放特定的剂量，当你马上需要胰岛素时可以发挥最佳作用。（100%的胰岛素餐前立即注射）

**参考3**

参考链接：https://zhuanlan.zhihu.com/p/386703926

文章中指出了丹娜胰岛素泵的三种模式，常规，方波，双波，  

![img](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/v2-40893fe585bcad25fe3649c1c4319234_1440w.jpg)

**参考4**

https://zhuanlan.zhihu.com/p/81942889

Medtronic 是一家总部位于**美国**的全球医疗技术公司，成立于 1949 年，专注于心脏病学、糖尿病管理、神经科学和其他医疗领域。

文章中指出 Medtronic MiniMed 胰岛素泵的 大剂量有 方波和双波的功能，**与其他胰岛素泵不同之处在于**，**双波可以自定义比例**



![image-20241129112726138](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129112726138.png)



**总结：**

上述参考，胰岛素泵的大剂量功能可分为三种模式

- 常规大剂量（餐前立马100%输注）

- 方波大剂量（一定时间内均匀输注）
- 双波形大剂量（立马输注+均匀输注，也可以看作是常规大剂量+方波大剂量，其中双波大剂量的输注比例可调节）



- [x] 三种大剂量模式的参数定义与数据解析实现

- 常规大剂量指令

```json
  { 
  "normal_large_dose": {        //常规大剂量
  "large_dose_liquid": "xx.x"   //液量
  }} 


-----example

{"normal_large_dose": {"large_dose_liquid": "9.5"}} 
 
```

![image-20241129145804460](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129145804460.png)





- 方波大剂量指令

```json
  { 
  "square_wave_large_dose": {   //方波大剂量 
  "large_dose_liquid": "xx.x",  //液量
  "tim_hh":"xx",                //时间 h
  "tim_min":"xx"                //时间 min
  }}  

-----example

{"square_wave_large_dose":{"large_dose_liquid":"10.5","tim_hh":"02","tim_min":"30"}}  

```

![image-20241129145901952](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129145901952.png)



- 双波大剂量指令

```json
{
 "double_wave_large_dose":{      //双波大剂量
 "all_liquid":"xx.x",            //总液量
 "proportion":"xx",              //比例
 "tim_hh":"xx",                  //时间 h
 "tim_min":"xx"                  //时间 min 
}}

-----example

{"double_wave_large_dose":{"all_liquid":"15","proportion":"50", "tim_hh":"1", "tim_min":"10"}}  

```

![image-20241129145941961](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129145941961.png)



## 2024/12/2

![image-20241202094244724](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202094244724.png)

**1.烧录程序步骤**

程序使用串口烧录，Micro usb烧录, 板载 USB转 TTL  CH340,

烧录时首先按住 UART_DOWNLOAD 按钮，然后按下并释放 RESET 按钮，最后释放 UART_DOWNLOAD 按钮。

![image-20241202094720340](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202094720340.png)

**2.打印串口**

- 打印串口信息使用 micro usb  与下载使用同一个 uart

**3.烧录程序目前可以用（usb/uart/SWD）**

目前可以使用的是 通过micro_usb烧录(usb转TTL)

**4.cmos sensor 型号**

JXF37P

![image-20241202100244817](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202100244817.png)

![image-20241202104739478](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202104739478.png)



- 支持cmos sensor

```c
#define SENSOR_DUMMY        0x00     //For dummy sensor, no support fast camera start
#define SENSOR_SC2336       0x01
#define SENSOR_GC2053       0x02
#define SENSOR_GC4653 		0x03
#define SENSOR_F37			0x04
#define SENSOR_IMX327		0x05
#define SENSOR_F51			0x06
#define SENSOR_PS5258       0x07     //It don't support the multi sensor for PS5258 now.If you want to use the sensor,please remove it.
#define SENSOR_SC301		0x08
#define SENSOR_IMX307		0x09
#define SENSOR_SC2333		0x0A
#define SENSOR_GC4023		0x0B
#define SENSOR_PS5420		0x0C
#define SENSOR_PS5270		0x0D
#define SENSOR_GC5035		0x0E
#define SENSOR_PS5268		0x0F
#define SENSOR_SC2310		0x10
#define SENSOR_PS5420_HDR		0x11
#define SENSOR_PS5270_HDR		0x12

static const struct sensor_params_t sensor_params[] = {
	{1920, 1080, 30}, //DUMMY
	{1920, 1080, 30}, //SC2336
	{1920, 1080, 30}, //GC2053
	{2560, 1440, 15}, //GC4653
	{1920, 1080, 30}, //F37
	{1920, 1080, 30}, //IMX327
	{1536, 1536, 30}, //F51
	{1920, 1080, 30}, //PS5258
	{2048, 1536, 20}, //SC301
	{1920, 1080, 30}, //IMX307
	{1920, 1080, 30}, //SC2333
	{2560, 1440, 15}, //GC4023
	{1952, 1944, 30}, //PS5420
	{1536, 1536, 30}, //PS5270
	{2592, 1944, 30}, //GC5035
	{1920, 1080, 30}, //PS5268
	{1920, 1080, 30}, //SC2310
	{1952, 1944, 30}, //PS5420_HDR
	{1536, 1536, 30}, //PS5270_HDR
};
```





**5.WPS_KEY**

![](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202105906635.png)

WPS（Wi-Fi Protected Setup）是一种简化无线网络配置的协议，旨在让用户更轻松地将设备连接到无线网络，而不需要手动输入复杂的网络密码。WPS特别适用于普通用户，通过几种便捷的方式实现快速、安全的无线网络连接。

在这个上下文中：

1. **WPS 功能的主要用途**
   WPS 的主要目的是通过一种用户友好的方式将设备（如手机、电脑、智能家居设备）加入到 Wi-Fi 网络中。

   - **典型应用场景**：用户购买了新设备，希望快速连接到家中的路由器，而无需输入复杂的密码。

2. **支持的 WPS 配置方法**
   文档中提到的配置方法主要有以下几种：

   - **WPS_CONFIG_DISPLAY**: 在设备显示屏上显示一个 PIN，用户需要在路由器管理页面输入此 PIN。
   - **WPS_CONFIG_KEYPAD**: 用户在设备上手动输入路由器的 PIN。
   - **WPS_CONFIG_PUSHBUTTON**: 用户按下路由器和设备上的 WPS 按钮以自动建立连接（不需要输入密码）。

3. **WPS 的函数解释**

   - wps_start

      启动 WPS 加入流程。用户可以选择 PIN 输入方式（Display/Keypad）或按钮触发方式（PushButton）。

     - Parameters
       - `wps_config`: 设置 WPS 配置方法。
       - `pin`: 如果使用 PIN 方式，需要提供对应的 PIN（PushButton 时为 NULL）。
       - `channel`: 当前未使用，可设置为 0。
       - `ssid`: 可指定目标网络的 SSID，如果为 NULL，表示不指定网络（由设备自动选择）。
     - Return
       - `0`: 表示成功启动 WPS。
       - 非 0: 表示启动失败。
     - 注意：调用 wps_start 之前需要先确保 Wi-Fi 已启用，并在配置中打开 CONFIG_ENABLE_WPS。

   - wps_stop

     停止 WPS 加入流程。

     - 无参数，直接调用即可。

4. **WPS 使用的注意事项**

   - 最大会话时间为 120 秒，WPS 流程需要在此时间内完成。
   - 如果用户不想继续 WPS，可以随时调用 `wps_stop` 中止流程。

5. **WPS 的安全性问题**
   尽管 WPS 提供了便利性，但需要注意其潜在的安全隐患：

   - **PIN 攻击**：一些早期路由器的 WPS 功能对 PIN 攻击较为脆弱，攻击者可能通过暴力破解 PIN 获取网络密码。
   - **建议**：如果设备支持，最好选择更安全的方式（如 WPA3）来保护网络。

在实践中，使用 WPS 能够简化某些设备的连接步骤，但应权衡便利性与安全性的关系。



- 在sdk中查询，未找到api直接调用demo,测试报错





**6.增加LED PWM**

选择使用**PF13** 作为LED PWM  已验证可行

![get-start-2](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/P02.png)

![image-20241202134439476](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202134439476.png)

- 支持cmos sensor

```
#define SENSOR_DUMMY        0x00     //For dummy sensor, no support fast camera start
#define SENSOR_SC2336       0x01
#define SENSOR_GC2053       0x02
#define SENSOR_GC4653 		0x03
#define SENSOR_F37			0x04
#define SENSOR_IMX327		0x05
#define SENSOR_F51			0x06
#define SENSOR_PS5258       0x07     //It don't support the multi sensor for PS5258 now.If you want to use the sensor,please remove it.
#define SENSOR_SC301		0x08
#define SENSOR_IMX307		0x09
#define SENSOR_SC2333		0x0A
#define SENSOR_GC4023		0x0B
#define SENSOR_PS5420		0x0C
#define SENSOR_PS5270		0x0D
#define SENSOR_GC5035		0x0E
#define SENSOR_PS5268		0x0F
#define SENSOR_SC2310		0x10
#define SENSOR_PS5420_HDR		0x11
#define SENSOR_PS5270_HDR		0x12

static const struct sensor_params_t sensor_params[] = {
	{1920, 1080, 30}, //DUMMY
	{1920, 1080, 30}, //SC2336
	{1920, 1080, 30}, //GC2053
	{2560, 1440, 15}, //GC4653
	{1920, 1080, 30}, //F37
	//{640, 480, 30},//F37
	{1920, 1080, 30}, //IMX327
	{1536, 1536, 30}, //F51
	{1920, 1080, 30}, //PS5258
	{2048, 1536, 20}, //SC301
	{1920, 1080, 30}, //IMX307
	{1920, 1080, 30}, //SC2333
	{2560, 1440, 15}, //GC4023
	{1952, 1944, 30}, //PS5420
	{1536, 1536, 30}, //PS5270
	{2592, 1944, 30}, //GC5035
	{1920, 1080, 30}, //PS5268
	{1920, 1080, 30}, //SC2310
	{1952, 1944, 30}, //PS5420_HDR
	{1536, 1536, 30}, //PS5270_HDR
};

```



胰岛素泵

- [x] 实现常规大剂量模式 并实际测试通过



## 2024/12/3

ubuntu中加密库的使用mbedtls

动态库方式实现

首先确保系统的工具是最新的

```
sudo apt update
sudo apt install build-essential cmake libssl-dev
```

下载mbedtls,使用cmake进行编译，进入mbedtls的目录，在当前目录下创建一个build文件

```
touch build
cd build
cmake .. -G "Unix Makefiles"
make

安装
sudo make install

配置系统动态链接库
sudo ldconfig
```

测试库是否可以正常使用 

aes.c

```c
#include <stdio.h>
#include <string.h>
#include "mbedtls/aes.h"

int main() {
    // AES 密钥（128位）
    unsigned char key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 
                              0xab, 0xf7, 0x97, 0x75, 0x46, 0x7e, 0x46, 0x40};  // 128-bit 密钥

    // 明文
    unsigned char input[16] = "Hello, AES Test!";  // 必须是 16 字节（128 位）的数据块

    // 密文输出
    unsigned char encrypted[16] = {0};

    // 解密后的明文输出
    unsigned char decrypted[16] = {0};

    // 初始化 AES 上下文
    mbedtls_aes_context aes;
    mbedtls_aes_init(&aes);

    // 设置加密密钥
    if (mbedtls_aes_setkey_enc(&aes, key, 128) != 0) {
        printf("设置加密密钥失败\n");
        return -1;
    }

    // 执行 AES 加密
    if (mbedtls_aes_crypt_ecb(&aes, MBEDTLS_AES_ENCRYPT, input, encrypted) != 0) {
        printf("加密失败\n");
        return -1;
    }

    // 输出加密后的数据
    printf("加密后的密文：\n");
    for (int i = 0; i < 16; i++) {
        printf("%02x ", encrypted[i]);
    }
    printf("\n");

    // 设置解密密钥
    if (mbedtls_aes_setkey_dec(&aes, key, 128) != 0) {
        printf("设置解密密钥失败\n");
        return -1;
    }

    // 执行 AES 解密
    if (mbedtls_aes_crypt_ecb(&aes, MBEDTLS_AES_DECRYPT, encrypted, decrypted) != 0) {
        printf("解密失败\n");
        return -1;
    }

    // 输出解密后的数据
    printf("解密后的明文：\n");
    for (int i = 0; i < 16; i++) {
        printf("%c", decrypted[i]);
    }
    printf("\n");

    // 清理 AES 上下文
    mbedtls_aes_free(&aes);

    return 0;
}
```

**编译:**

```
gcc -o aes aes.c -lmbedtls -lmbedx509 -lmbedcrypto
```



**sha256验证**

```
#include <stdio.h>
#include <string.h>
#include <mbedtls/sha256.h>
#include <mbedtls/error.h>
#include <stdlib.h>

#define BUFFER_SIZE 1024  // 缓冲区大小

// 计算文件的 SHA-256 校验值
int calculate_sha256(const char *filename, unsigned char *output_hash) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("无法打开文件");
        return -1;
    }

    // 初始化 SHA-256 上下文
    mbedtls_sha256_context sha256_ctx;
    mbedtls_sha256_init(&sha256_ctx);
    mbedtls_sha256_starts(&sha256_ctx, 0);  // 0 表示进行标准的 SHA-256 计算

    // 逐块读取文件并计算哈希
    unsigned char buffer[BUFFER_SIZE];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        mbedtls_sha256_update(&sha256_ctx, buffer, bytes_read);
    }

    // 完成哈希计算
    mbedtls_sha256_finish(&sha256_ctx, output_hash);

    // 清理 SHA-256 上下文
    mbedtls_sha256_free(&sha256_ctx);
    fclose(file);

    return 0;
}

// 打印 SHA-256 哈希值
void print_sha256_hash(unsigned char *hash) {
    for (int i = 0; i < 32; i++) {
        printf("%02x", hash[i]);
    }
    printf("\n");
}

int main() {
    const char *filename = "test.bin";  // 输入文件名
    unsigned char hash[32];  // SHA-256 哈希值是 32 字节

    // 计算文件的 SHA-256 校验值
    if (calculate_sha256(filename, hash) == 0) {
        printf("SHA-256 校验值：");
        print_sha256_hash(hash);
    } else {
        printf("文件处理失败\n");
        return -1;
    }

    return 0;
}
```

**编译**

```
gcc -o sha256 sha256.c  -lmbedtls -lmbedx509 -lmbedcrypto
```



我想使用mbedtls 库，理解rsa 非对称加密 使用2048 位秘钥长度，我有一个固件test.bin，帮我做一个固件可信 

**生成 RSA 密钥对的步骤：**

1. **安装 OpenSSL**（如果尚未安装）：

   ```
   sudo apt update
   sudo apt install openssl
   ```

2. **生成 2048 位 RSA 私钥**： 使用以下命令生成一个私钥文件 `private_key.pem`：

   ```
   openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
   ```

3. **从私钥提取公钥**： 使用以下命令从生成的私钥中提取公钥，保存为 `public_key.pem`：

   ```
   openssl rsa -pubout -in private_key.pem -out public_key.pem
   ```



```
public key:

MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp+8UK6KaexLhXjM0D9jm
nKgIpvOFc0xS9V3Ue7AJsmnM5E/YuwTG8yIPiUkzL97IjX6IJA9S6rNbW/h1E5S2
pEfIZL8SWFGNw7fKmXiYcEERxwKt/lvZsih1Gb+W7B7h0guKMoLJiMMxlQbT5JLz
ZUPuTQHRwedPWDrcAjGCyeyoJGYKu7pk5olvNkMizJdczVSNqabQkDSwCrSPP337
7wV8lMg6FLB+j/esDf0N1oHwZpfSwD+OJMNOTq5AbMDZvWcQ21MrEN/i3ZtTS9Xk
T2scMtc8OVKAbTQ+/+DY3KhVHi6iLcfe/SDRm35CztcJXxGdj+KtZKwbd+XIt74q
xQIDAQAB

private key:

MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCn7xQropp7EuFe
MzQP2OacqAim84VzTFL1XdR7sAmyaczkT9i7BMbzIg+JSTMv3siNfogkD1Lqs1tb
+HUTlLakR8hkvxJYUY3Dt8qZeJhwQRHHAq3+W9myKHUZv5bsHuHSC4oygsmIwzGV
BtPkkvNlQ+5NAdHB509YOtwCMYLJ7KgkZgq7umTmiW82QyLMl1zNVI2pptCQNLAK
tI8/ffvvBXyUyDoUsH6P96wN/Q3WgfBml9LAP44kw05OrkBswNm9ZxDbUysQ3+Ld
m1NL1eRPaxwy1zw5UoBtND7/4NjcqFUeLqItx979INGbfkLO1wlfEZ2P4q1krBt3
5ci3virFAgMBAAECggEAB4WGdRXersMqY5pjgI+JygZ0rMBHf+Hb7VrQg4xfmCVz
pIjhqi637SKKE5oQYtqAR7tybuWzebOi1JG3nLLnzfUxHTdkTkmzfHVPlmQiX79q
WRbeTYA2VevIouiZN+Ys3cg1M7dL6NuP7Z7VVW2Hh/JCSsyuum1DzoMvC3dwO4mo
A7iHNV3KWebtUKmQ+P5Egg0v7FEY3Ha2iedVdKtGazOj+k8fw+TbtsJNebWMbI/J
rP/wVpdt76ZaaWPyg6EzNSXInmF5+cdhU89SWRrlT7AR/agwpCYgffaUfvS80Kyt
Z0n1iO84KwDxQgP2JuWtzjhfQ0R1U4iq4lDcFPChmQKBgQC8uoNibakyL63icfEr
DMKUzfZRA0/HBZo85D7aJ/UB/rxnDsImqZL7ohVR6ukBYciAaUdlnV34xWf0taGS
CWMyHzJFgF9NEx1KR607xcwNpxZfPB1yQ4vlZiP2sicrhpFCHtc7K89uQQ9eEf9E
Y65KOCSNULyo4AWBI8wi6wxSnwKBgQDjyw1AtG00IvLgAQ9eYS8Pt5bPvA3ocE1S
8Z6jIDFRv/bTiVunl5kKJKcVs+Eav9NZIQwM+yHXvCBjcjzF6hsu8VI8FCCMIkV+
byaXobjPZaNCEzMbCfE53TlZUlPGGRXJzKOODzggTfdhfNS9KpP1LMhrvFpaGqh8
Lula3y4MGwKBgQCc12PYqMmzq2wWhBqobDJI9+F78gSaoU1MzWJuakZzIf/wpZM0
DjjYZhrRuSdqvpiiHtv21pEB7Qw3kbp0YtjNDp/4onaQ1xHAaVDOG9M4hWNSQeM2
0muwePHqUqO6yFpvWLIFuqLoPalHxC0f6Lcvdvjpd+9RaNsqN1WuryfOgQKBgQDf
kCkxl+KViLdVobSzrC3D/yrENoxv08gP35MSBkZhNUXJ1sVddit9CPvzENecqSeE
EisBkndkg/5Fm5iJpXmIWM+cpyRKZFhP/kaiCtaWtenEr5M4tklJwRTH1UTi5zu7
Elxyz/0Ft39S7nDcNy1/MrSBCBqk1AUH3AKqbN+EgQKBgQC6c3+CB2JRviu4yLi7
tetaAMi337SWaFRcIGhc3KrbOqxhok7JeRW5SfxSSSgfX32BzbpX6qYUoHGg1be7
vlEsYmrB6RFm+zILSO4YlICnEJxONkFgyeAgdjWx4YvwKHU3IdlTiEvIU0cutmj8
n00y1GxdZzcHjCIddCC5Wr0kMg==
```



使用上述生成的公钥与私钥做rsa固件可信

gcc -o sign_firmware sign_firmware.c  -lmbedtls -lmbedx509 -lmbedcrypto



 ./sign_firmware







- [ ] 上午实现大剂量模式中的 方波模式大剂量

基础率运行的情况下，输入以下指令，将设置 输液量15个单位，在2.5h内均匀输注完成

```
{"square_wave_large_dose":{"large_dose_liquid":"15","tim_hh":"02","tim_min":"30"}}
```

- [ ]  下午 ameba pro2的 wps 连接模式，依据用户指南的api，调用函数后出现堆栈错误，未排查出错误原因

![image-20241203173156530](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241203173156530.png)

**err :**

地址，R0  R3   LR跳转链接地址存在明显错误

![image-20241203173737036](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241203173737036.png)



## 2024/12/4

- [x] 实现AmebaPro2的的WPS，第一次连接时需要长按路由器的wps按钮，记住密码后续将自动连接，无需手动操作  

example 编译文件 wlan_scenario 

![image-20241204172915206](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241204172915206.png)

![image-20241204173044445](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241204173044445.png)

![image-20241204173102960](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241204173102960.png)



## 2024/12/5

**wps 配置**

```c
void _wps_thread(void *pvParameters)
{
	char *id = pvParameters;
	printf("\nExample: wlan_scenario \n");
#if defined(configENABLE_TRUSTZONE) && (configENABLE_TRUSTZONE == 1)
	rtw_create_secure_context(configMINIMAL_SECURE_STACK_SIZE);
#endif
	// Wait for other task stable.
	vTaskDelay(4000);

    printf("\n\n[WLAN_SCENARIO_EXAMPLE] Wi-Fi example for authentication...\n");
	rtw_network_info_t connect_param = {0};

	/*********************************************************************************
	*	1. Enable Wi-Fi with STA mode
	*********************************************************************************/
	printf("\n\r[WLAN_SCENARIO_EXAMPLE] Enable Wi-Fi\n");
	if (wifi_on(RTW_MODE_STA) < 0) {
		printf("\n\r[WLAN_SCENARIO_EXAMPLE] ERROR: wifi_on failed\n");
		return;
	}
	/*********************************************************************************
	*	2. Connect to AP by different authentications
	*********************************************************************************/
	printf("\n\r[WLAN_SCENARIO_EXAMPLE] Connect to AP\n");
	
	// By WPS-PBC.
	char *argv[2];
	argv[1] = (char *)"pbc";
	cmd_wps(2, argv);
	
	/*********************************************************************************
	*	3. Show Wi-Fi information
	*********************************************************************************/
	printf("\n\r[WLAN_SCENARIO_EXAMPLE] Show Wi-Fi information\n");
	rtw_wifi_setting_t setting;
	wifi_get_setting(WLAN0_IDX, &setting);
	print_wifi_setting(WLAN0_NAME, &setting);
}


void wps_test(char *id)
{
	if (xTaskCreate(_wps_thread, ((const char *)"_wps_thread"), 1024, (void *const) id, tskIDLE_PRIORITY + 1, NULL) != pdPASS) {
		printf("\n\r%s xTaskCreate failed\n", __FUNCTION__);
	}
}
```



**监控功能分析**



TP-link摄像头功能

**视频画质调整**

- 流畅
- 超清

**摄像头声音捕获**

- 开启
- 关闭

**云台**

- 云台调节，摄像头的上下左右移动

**录像回放**

- 时间调整，日期调整
- 筛选  连续录制，移动录制
- 截屏，录像，倍速，开启关闭声音
- 录像保存
- 录像计划（显示sd卡状态，选择是否启用sd卡录像，sd卡录像计划(全天连续录像，全天活动录像)）

**对讲**

- 开启麦克风对讲功能

- 按住对讲

- 音量调节（摄像机收音，摄像机扬声）

**截图**

- 将当前视频画面截图并保存至相册

**录制**

- 将当前视屏录制保存至并保存至相册

**镜头遮蔽**

- 关闭当前摄像头

**画面翻转**

- 不翻转，上下翻转，适用于摄像头正装或者倒装的场景

**手动报警**

- 测试报警声(喇叭)是否正常

**补光模式**

- 仅白光照明

- 仅红外照明

- 移动侦测全彩

**视频参数设置(主码流参数设置，设置清晰度为超清时的参数，子码流参数设置，设置清晰度为流畅时的参数)**

- 分辨率设置  (**2304x1296**   **2048 x 1280**    **1920x1280**  **1280*720**）

- 视频帧率  ( **1 ,10 ,15** )

- 码率类型（**变码率，定码率**）

- 图像质量（**低，中，高**）

- 码率上限（**256 512 1024 2048 Kbps**）

- 视频编码选择（**H.264,H.265**）



- [x] 实现双波大剂量，接收指令后，立刻输注一定的量，然后剩下的量按照方波进行

```
{"double_wave_large_dose":{"all_liquid":"60","proportion":"50", "tim_hh":"1", "tim_min":"00"}}  
```

上述指令设置 总输注量为60，立马输注量百分比为50%，剩余的量在1h输完



明日任务

- [ ] Ameba pro 实现将视频流全天录像,以及活动录像 至sd卡 
- [ ] 胰岛素泵添加日志功能，记录电机运行状态



## 2024/12/7



双通道串流 动态检测  H264 + mjpeg + osd + wps实现

```c
static void md_process(void *md_result)
{
	md_result_t *md_res = (md_result_t *) md_result;

#if MD_DRAW
	  //mp4 only draw text
	  	int motion = md_res->motion_cnt;
	    canvas_create_bitmap(V1_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
   
      //显示时间
       struct tm now_tim = sntp_gen_system_time_s(8 * 3600);
       snprintf(mp4_filename, sizeof(mp4_filename), "%04d-%02d-%02d %02d:%02d:%02d", now_tim.tm_year, now_tim.tm_mon, now_tim.tm_mday, now_tim.tm_hour, now_tim.tm_min,
					 now_tim.tm_sec);
	  // 使用 canvas_set_text 在指定位置绘制时间字符串
      canvas_set_text(V1_CHANNEL, 0, 5, 5, mp4_filename, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置


	if (md_res->event_cnt >= event_threshold) {
		 
	}

	if (motion) {
		int xmin = (int)(md_res->md_pos[0].xmin * V2_WIDTH);
		int ymin = (int)(md_res->md_pos[0].ymin * V2_HEIGHT);
		int xmax = (int)(md_res->md_pos[0].xmax * V2_WIDTH);
		int ymax = (int)(md_res->md_pos[0].ymax * V2_HEIGHT);

		canvas_set_rect(V1_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
	}
	canvas_update(V1_CHANNEL, 0, 1);


	canvas_create_bitmap(V2_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
	if (md_res->event_cnt >= event_threshold) {
		// canvas_set_text(V2_CHANNEL, 0, 5, 5, (char *)"Motion Detect", COLOR_GREEN);   
	}
        canvas_set_text(V2_CHANNEL, 0, 5, 5, mp4_filename, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置
	
	if (motion) {
		int xmin = (int)(md_res->md_pos[0].xmin * V2_WIDTH);
		int ymin = (int)(md_res->md_pos[0].ymin * V2_HEIGHT);
		int xmax = (int)(md_res->md_pos[0].xmax * V2_WIDTH);
		int ymax = (int)(md_res->md_pos[0].ymax * V2_HEIGHT);

		canvas_set_rect(V2_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
		canvas_set_rect(V1_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
	}
	canvas_update(V2_CHANNEL, 0, 1);

#endif
}



void mmf2_video_example_md_mp4_init(void)
{
  atcmd_userctrl_init();

#if defined(ENABLE_META_INFO)
	unsigned char uuid[16] = {0xc7, 0x98, 0x2c, 0x28, 0x0a, 0xfc, 0x49, 0xe6, 0xaa, 0xe4, 0x7f, 0x8f, 0x64, 0xee, 0x65, 0x01};
	video_pre_init_params_t init_params;
	memset(&init_params, 0x00, sizeof(video_pre_init_params_t));
	init_params.meta_enable = 1;
	init_params.meta_size = VIDEO_META_USER_SIZE;
	memcpy(init_params.video_meta_uuid, uuid, VIDEO_META_UUID_SIZE);
	video_pre_init_setup_parameters(&init_params);//It only setup one time.
	video_v1_params.meta_enable = 1;
	video_v2_params.meta_enable = 1;
	for (int i = 0; i < 64; i++) {
		meta_user_buf[i] = i;
	}
#endif

	/*sensor capacity check & video parameter setting*/
	video_v1_params.resolution = VIDEO_VGA;
	video_v1_params.width = 1280;
	video_v1_params.height = 720;
    video_v1_params.fps = sensor_params[USE_SENSOR].sensor_fps/2 ;
	video_v1_params.gop = sensor_params[USE_SENSOR].sensor_fps/2 ;

	video_v2_params.resolution = VIDEO_VGA;
	video_v2_params.width = 1280;
	video_v2_params.height = 720;
	video_v2_params.fps = 15;
	video_v2_params.gop = 15;

	video_v4_params.width = MD_WIDTH;
	video_v4_params.height = MD_HEIGHT;
	video_v4_params.fps = MD_FPS;
	video_v4_params.gop = MD_FPS;
	video_v4_params.roi.xmax = sensor_params[USE_SENSOR].sensor_width;
	video_v4_params.roi.ymax = sensor_params[USE_SENSOR].sensor_height;

	/* rtsp parameter setting */
    rtsp2_v1_params.u.v.fps = sensor_params[USE_SENSOR].sensor_fps / 2;
	rtsp2_v2_params.u.v.fps = sensor_params[USE_SENSOR].sensor_fps;

	int voe_heap_size = video_voe_presetting(1, video_v1_params.width, video_v1_params.height, V1_BPS, 0,
						1, video_v2_params.width, video_v2_params.height, V2_BPS, 0,
						0, 0, 0, 0, 0,
						1, MD_WIDTH, MD_HEIGHT);  

	printf("\r\n voe heap size = %d\r\n", voe_heap_size);
	if (voe_boot_fsc_status()) {
		video_v1_params.fcs = 1;
	}

	// ------ Channel 1--------------
	video_v1_ctx = mm_module_open(&video_module);
	if (video_v1_ctx) {
		mm_module_ctrl(video_v1_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v1_params);
		mm_module_ctrl(video_v1_ctx, MM_CMD_SET_QUEUE_LEN, video_v1_params.fps * 3);
		mm_module_ctrl(video_v1_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
#if defined(ENABLE_META_INFO)
		if (video_v1_params.meta_enable) {
			mm_module_ctrl(video_v1_ctx, CMD_VIDEO_META_CB, (int)video_meta_cb);
		}
#endif
	} else {
		rt_printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	// ------ Channel 2--------------
	video_v2_ctx = mm_module_open(&video_module);
	if (video_v2_ctx) {
		mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v2_params);
		mm_module_ctrl(video_v2_ctx, MM_CMD_SET_QUEUE_LEN, video_v2_params.fps * 3);
		mm_module_ctrl(video_v2_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
#if defined(ENABLE_META_INFO)
		if (video_v2_params.meta_enable) {
			mm_module_ctrl(video_v2_ctx, CMD_VIDEO_META_CB, (int)video_meta_cb2);
		}
#endif
	} else {
		rt_printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	//------ Channel 4--------------
	video_rgb_ctx = mm_module_open(&video_module);
	if (video_rgb_ctx) {
		mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v4_params);
		mm_module_ctrl(video_rgb_ctx, MM_CMD_SET_QUEUE_LEN, 2);
		mm_module_ctrl(video_rgb_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
	} else {
		printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	md_ctx  = mm_module_open(&eip_module);
	if (md_ctx) {
		md_config_t md_config;
		mm_module_ctrl(md_ctx, CMD_EIP_GET_MD_CONFIG, (int)&md_config); //get default md config
		md_config.md_obj_sensitivity = md_sensitivity;
		mm_module_ctrl(md_ctx, CMD_EIP_SET_PARAMS, (int)&md_param);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_DISPPOST, (int)md_process);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_CONFIG, (int)&md_config);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_EN, 1);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_STATUS, EIP_STATUS_START);
	} else {
		printf("md_ctx open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	sntp_init();

	//--------------Audio --------------
	audio_ctx = mm_module_open(&audio_module);
	if (audio_ctx) {
#if !USE_DEFAULT_AUDIO_SET
		mm_module_ctrl(audio_ctx, CMD_AUDIO_SET_PARAMS, (int)&audio_params);
#endif
		mm_module_ctrl(audio_ctx, MM_CMD_SET_QUEUE_LEN, 6);
		mm_module_ctrl(audio_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_STATIC);
		mm_module_ctrl(audio_ctx, CMD_AUDIO_APPLY, 0);
	} else {
		rt_printf("audio open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	aac_ctx = mm_module_open(&aac_module);
	if (aac_ctx) {
		mm_module_ctrl(aac_ctx, CMD_AAC_SET_PARAMS, (int)&aac_params);
		mm_module_ctrl(aac_ctx, MM_CMD_SET_QUEUE_LEN, 16);
		mm_module_ctrl(aac_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
		mm_module_ctrl(aac_ctx, CMD_AAC_INIT_MEM_POOL, 0);
		mm_module_ctrl(aac_ctx, CMD_AAC_APPLY, 0);
	} else {
		rt_printf("AAC open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	//--------------RTSP---------------
	rtsp2_v1_ctx = mm_module_open(&rtsp2_module);
	if (rtsp2_v1_ctx) {
		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SELECT_STREAM, 0);
		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_v1_params);
		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_APPLY, 0);

		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SELECT_STREAM, 1);
		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_a_params);
		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_APPLY, 0);

		mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_STREAMMING, ON);
	} else {
		rt_printf("RTSP2 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}


	rtsp2_v2_ctx = mm_module_open(&rtsp2_module);
	if (rtsp2_v2_ctx) {
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 0);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_v2_params);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);
	    mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);

        //mjpeg audio --> rtsp2
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 1);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_a_params);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);

		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);
	} else {
		rt_printf("RTSP2 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}


	//--------------Link---------------------------
	siso_audio_aac = siso_create();
	if (siso_audio_aac) {
		siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_INPUT, (uint32_t)audio_ctx, 0);
		siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_OUTPUT, (uint32_t)aac_ctx, 0);
		siso_ctrl(siso_audio_aac, MMIC_CMD_SET_STACKSIZE, 44 * 1024, 0);
		siso_start(siso_audio_aac);
	} else {
		rt_printf("siso1 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	rt_printf("siso started\n\r");

	mimo_2v_1a_rtsp = mimo_create();
	if (mimo_2v_1a_rtsp) {
#if defined(configENABLE_TRUSTZONE) && (configENABLE_TRUSTZONE == 1)
		mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
		mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_INPUT0, (uint32_t)video_v1_ctx, 0);
		mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_INPUT1, (uint32_t)video_v2_ctx, 0);
		mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_INPUT2, (uint32_t)aac_ctx, 0);
		mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_OUTPUT0, (uint32_t)rtsp2_v1_ctx, MMIC_DEP_INPUT0 | MMIC_DEP_INPUT2);
		mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_OUTPUT1, (uint32_t)rtsp2_v2_ctx, MMIC_DEP_INPUT1 | MMIC_DEP_INPUT2);
		mimo_start(mimo_2v_1a_rtsp);
	} else {
		rt_printf("mimo open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	mm_module_ctrl(video_v1_ctx, CMD_VIDEO_APPLY, V1_CHANNEL);
	mm_module_ctrl(video_v2_ctx, CMD_VIDEO_APPLY, V2_CHANNEL);
    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SNAPSHOT, 2); 
	rt_printf("mimo started\n\r");

// ------------siso rgb md-----------------
	siso_rgb_md = siso_create();
	if (siso_rgb_md) {
#if defined(configENABLE_TRUSTZONE) && (configENABLE_TRUSTZONE == 1)
		siso_ctrl(siso_rgb_md, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
		siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_INPUT, (uint32_t)video_rgb_ctx, 0);
		siso_ctrl(siso_rgb_md, MMIC_CMD_SET_STACKSIZE, (uint32_t)1024 * 64, 0);
		siso_ctrl(siso_rgb_md, MMIC_CMD_SET_TASKPRIORITY, 3, 0);
		siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_OUTPUT, (uint32_t)md_ctx, 0);
		siso_start(siso_rgb_md);
	} else {
		printf("siso_rgb_md open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}
	printf("siso_rgb_md started\n\r");
	mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_APPLY, MD_CHANNEL);	// start channel 4
	mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_YUV, 2);


	#if MD_DRAW
	 int ch_enable[3] = {1, 1, 0};
	 int char_resize_w[3] = {16, 16, 0}, char_resize_h[3] = {32, 32, 0};
	 int ch_width[3] = {video_v1_params.width, video_v2_params.width, 0};
	 int ch_height[3] = {video_v1_params.height, video_v2_params.height, 0};
	 osd_render_dev_init(ch_enable, char_resize_w, char_resize_h);
	 osd_render_task_start(ch_enable, ch_width, ch_height);
    #endif


	return;
mmf2_video_example_md_mp4_fail:

	return;
}

```

  



- [x] 运行检测视频保存至sd卡完成

- [x] WPS + 双通道串流 + 运动检测 + 运行视频保存  合并完成

四个通道使用情况如下： 

```
channel_1   video_save        
channel_2   H264              
channel_3   MJPEG             
channel_4   motion detection  
```

两个视频流 端口号 554 ---->h264      555 ---->mjpeg

- [ ] bug，在串流的视频上显示时间，保存视频将受到影响

![image-20241206175907779](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241206175907779.png)



## 2024/12/7

- [x] 昨天bug 解决，
- [ ] 实测试  在V3通道上显示osd会造成  canvas_send_msg: idx larger than available block

昨天bug解决了保存视频至sd卡的问题，但串流显示







## 2024/12/9

- [x] 双通道串流实现 + osd + 动态检测实现

```c
/******************************************************************************
*
* Copyright(c) 2007 - 2023 Realtek Corporation. All rights reserved.
*
******************************************************************************/
#include "mmf2_link.h"
#include "mmf2_siso.h"
#include "mmf2_mimo.h"

#include "module_video.h"
#include "module_rtsp2.h"
#include "module_audio.h"
#include "module_aac.h"
#include "module_mp4.h"
#include "module_eip.h"
#include "module_queue.h"
#include "mmf2_pro2_video_config.h"
#include "video_example_media_framework.h"
#include "log_service.h"
#include "sensor.h"
#include <sntp/sntp.h>

/*****************************************************************************
* ISP channel : 0,1
* Video type  : H264/HEVC
*****************************************************************************/

#define V1_CHANNEL 0
#define V1_BPS 2*1024*1024
#define V1_RCMODE 2 // 1: CBR, 2: VBR
#define V1_FPS 15

#define V2_CHANNEL 1
#define V2_BPS 2*1024*1024
#define V2_RCMODE 2 // 1: CBR, 2: VBR
#define V2_FPS 15
#define V2_WIDTH	1280
#define V2_HEIGHT	720

#define V3_CHANNEL 2
#define V3_BPS     2*1024*1024
#define V3_RCMODE  2 // 1: CBR, 2: VBR
#define V3_FPS     15
#define V3_WIDTH   1280
#define V3_HEIGHT  720

#define MD_CHANNEL 4
#define MD_GOP MD_FPS
#define MD_BPS 1024*1024
#define MD_TYPE VIDEO_RGB
#define MD_WIDTH	640
#define MD_HEIGHT	480

#define USE_H265 0
#if USE_H265
#include "sample_h265.h"
#define VIDEO_TYPE VIDEO_HEVC
#define VIDEO_CODEC AV_CODEC_ID_H265
#else
#include "sample_h264.h"
#define VIDEO_TYPE VIDEO_H264
#define VIDEO_CODEC AV_CODEC_ID_H264
#endif

static void atcmd_userctrl_init(void);
static mm_context_t *video_v1_ctx			= NULL;
static mm_context_t *video_v2_ctx			= NULL;
static mm_context_t *video_v3_ctx			= NULL;


static mm_context_t *video_rgb_ctx			= NULL;

static mm_context_t *rtsp2_v1_ctx			= NULL;
static mm_context_t *rtsp2_v2_ctx			= NULL;
static mm_context_t *rtsp2_v3_ctx			= NULL;

static mm_context_t *audio_ctx				= NULL;
static mm_context_t *aac_ctx				= NULL;
static mm_context_t *mp4_ctx				= NULL;
static mm_context_t *queue_ctx				= NULL;
static mm_context_t *md_ctx            		= NULL;

static mm_siso_t *siso_audio_aac			= NULL;
static mm_mimo_t *mimo_2v_1a_rtsp_queue		= NULL;
static mm_siso_t *siso_queue_mp4			= NULL;
static mm_siso_t *siso_rgb_md         		= NULL;
static mm_mimo_t *mimo_2v_1a_rtsp			= NULL;

static video_params_t video_v1_params = {
	.stream_id = V1_CHANNEL,
	.type = VIDEO_TYPE,
	.bps = V1_BPS,
	.rc_mode = V1_RCMODE,
	.use_static_addr = 1,
};

static video_params_t video_v2_params = {
	.stream_id = V2_CHANNEL,
	.type = VIDEO_JPEG,
	.use_static_addr = 1
};



static video_params_t video_v3_params = {
	.stream_id = V3_CHANNEL,
	.type = VIDEO_TYPE,
	.bps = V1_BPS,
	.rc_mode = V1_RCMODE,
	.use_static_addr = 1,
};

static video_params_t video_v4_params = {
	.stream_id 		= MD_CHANNEL,
	.type 			= MD_TYPE,
	.fps 			= MD_FPS,
	.gop 			= MD_GOP,
	.direct_output 	= 0,
	.use_static_addr = 1,
	.use_roi = 1,
	.roi = {
		.xmin = 0,
		.ymin = 0,
	}
};

#if !USE_DEFAULT_AUDIO_SET
static audio_params_t audio_params = {
	.sample_rate = ASR_8KHZ,
	.word_length = WL_16BIT,
	.mic_gain    = MIC_0DB,
	.dmic_l_gain    = DMIC_BOOST_24DB,
	.dmic_r_gain    = DMIC_BOOST_24DB,
	.use_mic_type   = USE_AUDIO_AMIC,
	.channel     = 1,
	.enable_aec  = 0//1
};
#endif

static aac_params_t aac_params = {
	.sample_rate = 8000,
	.channel = 1,
	.trans_type = AAC_TYPE_ADTS,
	.object_type = AAC_AOT_LC,
	.bitrate = 32000,

	.mem_total_size = 10 * 1024,
	.mem_block_size = 128,
	.mem_frame_size = 1024
};



static rtsp2_params_t rtsp2_v1_params = {
	.type = AVMEDIA_TYPE_VIDEO,
	.u = {
		.v = {
			.codec_id = VIDEO_CODEC,
			.bps      = V1_BPS
		}
	}
};



static rtsp2_params_t rtsp2_v2_params = {
	.type = AVMEDIA_TYPE_VIDEO,
	.u = {
		.v = {
			.codec_id = AV_CODEC_ID_MJPEG,
		}
	}
};


static rtsp2_params_t rtsp2_v3_params = {
	.type = AVMEDIA_TYPE_VIDEO,
	.u = {
		.v = {
			.codec_id = VIDEO_CODEC,
			.bps      = V1_BPS
		}
	}
};

static rtsp2_params_t rtsp2_a_params = {
	.type = AVMEDIA_TYPE_AUDIO,
	.u = {
		.a = {
			.codec_id   = AV_CODEC_ID_MP4A_LATM,
			.channel    = 1,
			.samplerate = 8000
		}
	}
};

static mp4_params_t mp4_v1_params = {
	.sample_rate = 8000,
	.channel = 1,
	.record_length = 305, //5 min 5sec
	.record_type = STORAGE_ALL,
	.record_file_num = 1,
	.record_file_name = "AmebaPro_recording",
	.fatfs_buf_size = 224 * 1024, /* 32kb multiple */
};

#define MD_COL 32
#define MD_ROW 32

static eip_param_t md_param = {
	.image_width = MD_WIDTH,
	.image_height = MD_HEIGHT,
	.eip_row = MD_ROW,
	.eip_col = MD_COL
};

//--------------------------------------------
// Draw Rect
//--------------------------------------------
#define MD_DRAW 1

#if MD_DRAW
#include "osd_render.h"
#endif

static int event_threshold = 7;
static int md_sensitivity = 75;
static char mp4_filename[128];

static char osd_tim[128];

static TimerHandle_t mp4_stop_record_timer = NULL;

static void mp4_stop_record_callback(TimerHandle_t xTimer)
{
	(void)xTimer;
	printf("no motion for 10 seconds\r\n");
	mm_module_ctrl(mp4_ctx, CMD_MP4_STOP, 0);
}


static void md_process(void *md_result)
{
	md_result_t *md_res = (md_result_t *) md_result;

   	if (md_res->event_cnt >= event_threshold) {
		int record_status = 0;
		mm_module_ctrl(mp4_ctx, CMD_MP4_GET_STATUS, (int)&record_status);
		if (record_status) {
			xTimerReset(mp4_stop_record_timer, 10);
		} else {
			struct tm tm_now = sntp_gen_system_time_s(8 * 3600);
			snprintf(mp4_filename, sizeof(mp4_filename), "%04d%02d%02d%02d%02d%02d", tm_now.tm_year, tm_now.tm_mon, tm_now.tm_mday, tm_now.tm_hour, tm_now.tm_min,
					 tm_now.tm_sec);
			printf("start recording %s\r\n", mp4_filename);
			mm_module_ctrl(mp4_ctx, CMD_MP4_SET_RECORD_FILE_NAME, (int)mp4_filename);
			mm_module_ctrl(mp4_ctx, CMD_MP4_START, 1);
			xTimerStart(mp4_stop_record_timer, 10);
		}
	}

#if MD_DRAW
	    //mp4 only draw text
	  	int motion = md_res->motion_cnt;  
        //显示时间
        struct tm now_tim = sntp_gen_system_time_s(8 * 3600);
        snprintf(osd_tim, sizeof(osd_tim), "%04d-%02d-%02d %02d:%02d:%02d", now_tim.tm_year, now_tim.tm_mon, now_tim.tm_mday, now_tim.tm_hour, now_tim.tm_min,
					 now_tim.tm_sec);

	    canvas_create_bitmap(V1_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
        canvas_set_text(V1_CHANNEL, 0, 5, 5, osd_tim, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置

	    if (motion) {
		int xmin = (int)(md_res->md_pos[0].xmin * V2_WIDTH);
		int ymin = (int)(md_res->md_pos[0].ymin * V2_HEIGHT);
		int xmax = (int)(md_res->md_pos[0].xmax * V2_WIDTH);
		int ymax = (int)(md_res->md_pos[0].ymax * V2_HEIGHT);

		canvas_set_rect(V1_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
	   }
	    canvas_update(V1_CHANNEL, 0, 1);


    canvas_create_bitmap(V2_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
    canvas_set_text(V2_CHANNEL, 0, 5, 5, osd_tim, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置
	  if (motion) {

		int xmin = (int)(md_res->md_pos[0].xmin * V2_WIDTH);
		int ymin = (int)(md_res->md_pos[0].ymin * V2_HEIGHT);
		int xmax = (int)(md_res->md_pos[0].xmax * V2_WIDTH);
		int ymax = (int)(md_res->md_pos[0].ymax * V2_HEIGHT);

		canvas_set_rect(V2_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
	   }
    canvas_update(V2_CHANNEL, 0, 1);


	canvas_create_bitmap(V3_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
    canvas_set_text(V3_CHANNEL, 0, 5, 5, osd_tim, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置
	  if (motion) {

		int xmin = (int)(md_res->md_pos[0].xmin * V2_WIDTH);
		int ymin = (int)(md_res->md_pos[0].ymin * V2_HEIGHT);
		int xmax = (int)(md_res->md_pos[0].xmax * V2_WIDTH);
		int ymax = (int)(md_res->md_pos[0].ymax * V2_HEIGHT);

		canvas_set_rect(V3_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
	   }
    canvas_update(V3_CHANNEL, 0, 1);



#endif
}



void mmf2_video_example_md_mp4_init(void)
{
  atcmd_userctrl_init();

#if defined(ENABLE_META_INFO)
	unsigned char uuid[16] = {0xc7, 0x98, 0x2c, 0x28, 0x0a, 0xfc, 0x49, 0xe6, 0xaa, 0xe4, 0x7f, 0x8f, 0x64, 0xee, 0x65, 0x01};
	video_pre_init_params_t init_params;
	memset(&init_params, 0x00, sizeof(video_pre_init_params_t));
	init_params.meta_enable = 1;
	init_params.meta_size = VIDEO_META_USER_SIZE;
	memcpy(init_params.video_meta_uuid, uuid, VIDEO_META_UUID_SIZE);
	video_pre_init_setup_parameters(&init_params);//It only setup one time.
	video_v1_params.meta_enable = 1;
	video_v2_params.meta_enable = 1;
	for (int i = 0; i < 64; i++) {
		meta_user_buf[i] = i;
	}
#endif

	video_v1_params.resolution = VIDEO_FHD;
	video_v1_params.width = sensor_params[USE_SENSOR].sensor_width;
	video_v1_params.height = sensor_params[USE_SENSOR].sensor_height;
	video_v1_params.fps = V1_FPS;
	video_v1_params.gop = V1_FPS;

	video_v2_params.resolution = VIDEO_HD;
	video_v2_params.width = 1280;
	video_v2_params.height = 720;
	video_v2_params.fps = 15;
	video_v2_params.gop = 15;

	video_v3_params.resolution = VIDEO_HD;
	video_v3_params.width = 1280;
	video_v3_params.height = 720;
    video_v3_params.fps = 15 ;
	video_v3_params.gop = 15 ;

	video_v4_params.width = MD_WIDTH;
	video_v4_params.height = MD_HEIGHT;
	video_v4_params.fps = MD_FPS;
	video_v4_params.gop = MD_FPS;
	video_v4_params.roi.xmax = sensor_params[USE_SENSOR].sensor_width;
	video_v4_params.roi.ymax = sensor_params[USE_SENSOR].sensor_height;

 	/*mp4 parameter setting*/
 	mp4_v1_params.fps = V1_FPS;
	mp4_v1_params.gop = V1_FPS;
	mp4_v1_params.width = sensor_params[USE_SENSOR].sensor_width;
	mp4_v1_params.height = sensor_params[USE_SENSOR].sensor_height;

	/* rtsp parameter setting */
    rtsp2_v1_params.u.v.fps = 15;
	rtsp2_v2_params.u.v.fps = 15;
    rtsp2_v3_params.u.v.fps = 15;

	int voe_heap_size = video_voe_presetting(1, video_v1_params.width, video_v1_params.height, V1_BPS, 0,
						1, video_v2_params.width, video_v2_params.height, V2_BPS, 0,
						1, video_v3_params.width, video_v3_params.height, V3_BPS, 0,
						1, MD_WIDTH, MD_HEIGHT);  

	printf("\r\n voe heap size = %d\r\n", voe_heap_size);
	if (voe_boot_fsc_status()) {
		video_v1_params.fcs = 1;
	}

	// ---------- Channel 1--------------
	video_v1_ctx = mm_module_open(&video_module);
	if (video_v1_ctx) {
		mm_module_ctrl(video_v1_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v1_params);
		mm_module_ctrl(video_v1_ctx, MM_CMD_SET_QUEUE_LEN, video_v1_params.fps);
		mm_module_ctrl(video_v1_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);

	} else {
		rt_printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	// ----------- Channel 2--------------
	video_v2_ctx = mm_module_open(&video_module);
	if (video_v2_ctx) {
		mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v2_params);
		mm_module_ctrl(video_v2_ctx, MM_CMD_SET_QUEUE_LEN, video_v2_params.fps * 3);
		mm_module_ctrl(video_v2_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);

	} else {
		rt_printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

    //------------ Channel 3--------------
	video_v3_ctx = mm_module_open(&video_module);
	if (video_v3_ctx) {
		mm_module_ctrl(video_v3_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v3_params);
		mm_module_ctrl(video_v3_ctx, MM_CMD_SET_QUEUE_LEN, video_v3_params.fps);
		mm_module_ctrl(video_v3_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);

	} else {
		rt_printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	//------ Channel 4--------------
	video_rgb_ctx = mm_module_open(&video_module);
	if (video_rgb_ctx) {
		mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_SET_PARAMS, (int)&video_v4_params);
		mm_module_ctrl(video_rgb_ctx, MM_CMD_SET_QUEUE_LEN, 2);
		mm_module_ctrl(video_rgb_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
	} else {
		printf("video open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	md_ctx  = mm_module_open(&eip_module);
	if (md_ctx) {
		md_config_t md_config;
		mm_module_ctrl(md_ctx, CMD_EIP_GET_MD_CONFIG, (int)&md_config); //get default md config
		md_config.md_obj_sensitivity = md_sensitivity;
		mm_module_ctrl(md_ctx, CMD_EIP_SET_PARAMS, (int)&md_param);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_DISPPOST, (int)md_process);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_CONFIG, (int)&md_config);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_EN, 1);
		mm_module_ctrl(md_ctx, CMD_EIP_SET_STATUS, EIP_STATUS_START);
	} else {
		printf("md_ctx open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}



   	//--------------MP4---------------
	mp4_ctx = mm_module_open(&mp4_module);
	if (mp4_ctx) {
		mm_module_ctrl(mp4_ctx, CMD_MP4_SET_PARAMS, (int)&mp4_v1_params);
		mm_module_ctrl(mp4_ctx, CMD_MP4_LOOP_MODE, 0);
	} else {
		printf("MP4 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}
	mp4_stop_record_timer = xTimerCreate("mp4_stop_record_timer", 10000 / portTICK_PERIOD_MS, pdFALSE, NULL, mp4_stop_record_callback);

    sntp_init();

	queue_ctx = mm_module_open(&queue_module);
	if (queue_ctx) {
		int audio_queue_len = mp4_v1_params.sample_rate / 1024;
		mm_module_ctrl(queue_ctx, MM_CMD_SET_QUEUE_LEN, (video_v1_params.fps + audio_queue_len) * 3); //mp4 init takes 2.5s, buffer 3 seconds video and audio
		mm_module_ctrl(queue_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
		mm_module_ctrl(queue_ctx, CMD_QUEUE_SET_VQUEUE_LEN, video_v1_params.fps * 5); //buffer 5 second video
		mm_module_ctrl(queue_ctx, CMD_QUEUE_SET_AQUEUE_LEN, audio_queue_len * 5); //buffer 5 second audio
	} else {
		printf("QUEUE open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	//--------------Audio --------------
	audio_ctx = mm_module_open(&audio_module);
	if (audio_ctx) {
#if !USE_DEFAULT_AUDIO_SET
		mm_module_ctrl(audio_ctx, CMD_AUDIO_SET_PARAMS, (int)&audio_params);
#endif
		mm_module_ctrl(audio_ctx, MM_CMD_SET_QUEUE_LEN, 6);
		mm_module_ctrl(audio_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_STATIC);
		mm_module_ctrl(audio_ctx, CMD_AUDIO_APPLY, 0);
	} else {
		rt_printf("audio open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	aac_ctx = mm_module_open(&aac_module);
	if (aac_ctx) {
		mm_module_ctrl(aac_ctx, CMD_AAC_SET_PARAMS, (int)&aac_params);
		mm_module_ctrl(aac_ctx, MM_CMD_SET_QUEUE_LEN, 16);
		mm_module_ctrl(aac_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
		mm_module_ctrl(aac_ctx, CMD_AAC_INIT_MEM_POOL, 0);
		mm_module_ctrl(aac_ctx, CMD_AAC_APPLY, 0);
	} else {
		rt_printf("AAC open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	//--------------RTSP---------------

    rtsp2_v2_ctx = mm_module_open(&rtsp2_module);
	if (rtsp2_v2_ctx) {
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 0);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_v2_params);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);
	    mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);

        //mjpeg audio --> rtsp2
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 1);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_a_params);
		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);

		mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);
	} else {
		rt_printf("RTSP2 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}


	rtsp2_v3_ctx = mm_module_open(&rtsp2_module); 
	if (rtsp2_v3_ctx) {
		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SELECT_STREAM, 0);
		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_v3_params);
		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_APPLY, 0);

		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SELECT_STREAM, 1);
		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_PARAMS, (int)&rtsp2_a_params);
		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_APPLY, 0);

		mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_STREAMMING, ON);
	} else {
		rt_printf("RTSP2 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	

	//--------------Link---------------------------
	siso_audio_aac = siso_create();
	if (siso_audio_aac) {
		siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_INPUT, (uint32_t)audio_ctx, 0);
		siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_OUTPUT, (uint32_t)aac_ctx, 0);
		siso_ctrl(siso_audio_aac, MMIC_CMD_SET_STACKSIZE, 44 * 1024, 0);
		siso_start(siso_audio_aac);
	} else {
		rt_printf("siso1 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

	rt_printf("siso started\n\r");

	mimo_2v_1a_rtsp_queue = mimo_create();
	if (mimo_2v_1a_rtsp_queue) {
#if defined(configENABLE_TRUSTZONE) && (configENABLE_TRUSTZONE == 1)
		mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT0, (uint32_t)video_v1_ctx, 0);
		mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT1, (uint32_t)video_v2_ctx, 0);
		mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT2, (uint32_t)video_v3_ctx, 0);
		mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT3, (uint32_t)aac_ctx, 0);

		mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_OUTPUT0, (uint32_t)queue_ctx, MMIC_DEP_INPUT0 | MMIC_DEP_INPUT3);
		mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_OUTPUT1, (uint32_t)rtsp2_v2_ctx, MMIC_DEP_INPUT1 | MMIC_DEP_INPUT3);
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_OUTPUT2, (uint32_t)rtsp2_v3_ctx, MMIC_DEP_INPUT2 | MMIC_DEP_INPUT3);
	
		mimo_start(mimo_2v_1a_rtsp_queue);
	} else {
		rt_printf("mimo open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}

    mm_module_ctrl(video_v1_ctx, CMD_VIDEO_APPLY, V1_CHANNEL);

    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_APPLY, V2_CHANNEL);   
	mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SNAPSHOT, 2);   // jpeg串流不可删除

	mm_module_ctrl(video_v3_ctx, CMD_VIDEO_APPLY, V3_CHANNEL);
	 

	rt_printf("mimo started\n\r");

// ------------siso rgb md-----------------
	siso_rgb_md = siso_create();
	if (siso_rgb_md) {
#if defined(configENABLE_TRUSTZONE) && (configENABLE_TRUSTZONE == 1)
		siso_ctrl(siso_rgb_md, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
		siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_INPUT, (uint32_t)video_rgb_ctx, 0);
		siso_ctrl(siso_rgb_md, MMIC_CMD_SET_STACKSIZE, (uint32_t)1024 * 64, 0);
		siso_ctrl(siso_rgb_md, MMIC_CMD_SET_TASKPRIORITY, 3, 0);
		siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_OUTPUT, (uint32_t)md_ctx, 0);
		siso_start(siso_rgb_md);
	} else {
		printf("siso_rgb_md open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}
	printf("siso_rgb_md started\n\r");
	mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_APPLY, MD_CHANNEL);	// start channel 4
	mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_YUV, 2);
    
    // ------------siso  mp4-----------------
   	siso_queue_mp4 = siso_create();
	if (siso_queue_mp4) {
		siso_ctrl(siso_queue_mp4, MMIC_CMD_ADD_INPUT, (uint32_t)queue_ctx, 0);
		siso_ctrl(siso_queue_mp4, MMIC_CMD_ADD_OUTPUT, (uint32_t)mp4_ctx, 0);
		siso_start(siso_queue_mp4);
	} else {
		printf("siso2 open fail\n\r");
		goto mmf2_video_example_md_mp4_fail;
	}
	printf("siso_queue_mp4 started\n\r");

	#if MD_DRAW
	
	 int ch_enable[4] = {1, 1, 1,0};
	 int char_resize_w[4] = {16, 16, 16,0}, char_resize_h[4] = {32, 32, 32,0};
	 int ch_width[4] = {video_v1_params.width, video_v2_params.width, video_v3_params.width,0};
	 int ch_height[4] = {video_v1_params.height, video_v2_params.height, video_v3_params.height,0};
	 osd_render_dev_init(ch_enable, char_resize_w, char_resize_h);
	 osd_render_task_start(ch_enable, ch_width, ch_height);
    #endif

	return;
mmf2_video_example_md_mp4_fail:

	return;
}






static const char *example = "mmf2_video_example_md_mp4_init";
static void example_deinit(void)
{
	sntp_stop();
	xTimerDelete(mp4_stop_record_timer, 0xFFFFFFFF);
	mm_module_ctrl(md_ctx, CMD_EIP_SET_STATUS, EIP_STATUS_STOP);

#if MD_DRAW
	osd_render_task_stop();
	osd_render_dev_deinit_all();
#endif

	//Pause Linker
	siso_pause(siso_audio_aac);
	mimo_pause(mimo_2v_1a_rtsp_queue, MM_OUTPUT0 | MM_OUTPUT1);
	siso_pause(siso_rgb_md);
	siso_pause(siso_queue_mp4);

	//Stop module
	mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, OFF);
	mm_module_ctrl(aac_ctx, CMD_AAC_STOP, 0);
	mm_module_ctrl(audio_ctx, CMD_AUDIO_SET_TRX, 0);
	mm_module_ctrl(mp4_ctx, CMD_MP4_STOP, 0);
	mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_STREAM_STOP, 0);
	mm_module_ctrl(video_v1_ctx, CMD_VIDEO_STREAM_STOP, 0);
	mm_module_ctrl(video_v2_ctx, CMD_VIDEO_STREAM_STOP, 0);

	//Delete linker
	siso_delete(siso_queue_mp4);
	siso_delete(siso_rgb_md);
	mimo_delete(mimo_2v_1a_rtsp_queue);
	siso_delete(siso_audio_aac);

	//Close module
	rtsp2_v2_ctx = mm_module_close(rtsp2_v2_ctx);
	aac_ctx = mm_module_close(aac_ctx);
	audio_ctx = mm_module_close(audio_ctx);
	mp4_ctx = mm_module_close(mp4_ctx);
	queue_ctx = mm_module_close(queue_ctx);
	md_ctx = mm_module_close(md_ctx);
	video_rgb_ctx = mm_module_close(video_rgb_ctx);
	video_v2_ctx = mm_module_close(video_v2_ctx);
	video_v1_ctx = mm_module_close(video_v1_ctx);

	//Video Deinit
	video_deinit();
}



static void fUC(void *arg)
{
	static uint32_t user_cmd = 0;

	if (!strcmp(arg, "TD")) {
		if (user_cmd & USR_CMD_EXAMPLE_DEINIT) {
			printf("invalid state, can not do %s deinit!\r\n", example);
		} else {
			example_deinit();
			user_cmd = USR_CMD_EXAMPLE_DEINIT;
			printf("deinit %s\r\n", example);
		}
	} else if (!strcmp(arg, "TSR")) {
		if (user_cmd & USR_CMD_EXAMPLE_DEINIT) {
			printf("reinit %s\r\n", example);
			sys_reset();
		} else {
			printf("invalid state, can not do %s init!\r\n", example);
		}
	} else {
		printf("invalid cmd");
	}

	printf("user command 0x%x\r\n", user_cmd);
}

#define MAX_ARGC 18

static void fMD(void *arg)
{
	char *argv[MAX_ARGC] = {0};
	if (!arg) {
		return;
	}

	parse_param(arg, argv);

	if (strcmp(argv[1], "sen") == 0) {
		int sen = atoi(argv[2]);
		if (md_ctx) {
			mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_SENSITIVITY, sen);
			printf("Set MD sensitivity %d\r\n", sen);
		}
	} else if (strcmp(argv[1], "thr") == 0) {
		int event = atoi(argv[2]);
		if (event < MD_FPS) {
			event_threshold = event;
			printf("Set event threshold %d\r\n", event_threshold);
		} else {
			printf("Event threshold out of range (0-%d)\r\n", MD_FPS);
		}
	}
	return;
}

static log_item_t userctrl_items[] = {
	{"UC", fUC, },
	{"MD", fMD, },
};

static void atcmd_userctrl_init(void)
{
	log_service_add_table(userctrl_items, sizeof(userctrl_items) / sizeof(userctrl_items[0]));
}
```



定义日志存储空间200k

- 连接时间日志

```
{connect:"2024/12/12 20:32:20"}
```

- 断开连接日志

```
{disconnect:"2024/12/12 20:32:20"}
```

- 
















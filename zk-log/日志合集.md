## 2024/12/9

- [x] 解决上周六问题

在V3通道上显示osd会造成  canvas_send_msg: idx larger than available block

解决如下，添加V3通道的配置

![image-20241209163332374](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241209163332374.png)



- [x] 定义日志存储格式  时间 + 指令，理论计算与格式定义

```json
//时间同步
[2024-11-20 20:20:10]{"sync_tim":{"now_tim": "2024-11-20 20:20:10"}}

//多段基础率
[2024-11-20 20:20:10]{ "basal_rate":{"basal_rate_num": "1","speed":"30","basal_rate_tim":"00:00-12:00"}}   
[2024-11-20 20:20:10]{ "basal_rate":{"basal_rate_num": "2","speed":"25","basal_rate_tim":"12:00-12:05"}}   
[2024-11-20 20:20:10]{ "basal_rate":{"basal_rate_num": "3","speed":"30","basal_rate_tim":"12:05-12:10"}}   
[2024-11-20 20:20:10]{ "basal_rate":{"basal_rate_num": "4","speed":"25","basal_rate_tim":"12:10-23:59"}}   
//常规大剂量
[2024-11-20 20:20:10]{"normal_large_dose": {"large_dose_liquid": "9.5"}}  
//方波大剂量
[2024-11-20 20:20:10]{"square_wave_large_dose":{"large_dose_liquid":"10.5","tim_hh":"02","tim_min":"30"}} 
//双波大剂量
[2024-11-20 20:20:10]{"double_wave_large_dose":{"all_liquid":"60","proportion":"50", "tim_hh":"1","tim_min":"00"}}

```

此外，增加还需扩展的日志信息如下

- 连接时间

```json
[2024-11-20 20:20:10]{connect_tim:"2024/12/12 20:32:20"}
```

- 断开连接时间

```json
[2024-11-20 20:20:10]{dis_connect_tim:"2024/12/12 20:32:20"}
```



预估1天日志存储量

首次使用，开机设置基础率，6段，每天设置6次大剂量，20次连接状态查看

1天总计存储容量为：

- 开机的6段基础率日志，120字节*6  = 720字节
- 6次大剂量日志存储 120字节*6 = 720字节
- 48+22 次连接状态(连接+断开连接)  60字节 * 70 = 4200字节
- 70次时间同步 70字节*70 = 4900字节

**一天的日志存储用量 = 10540字节   大小约11k**

200K的容量大约可以存储18天的历史记录



falsh擦写寿命计算

Flash的擦写寿命，一般在10000-100000 次擦写

每天擦写Flash的次数约 160次，按照上述，可正常运行天数在 62.5天 -  625天

**评估上述使用寿命较短**，市场上胰岛素泵售后一般在五年左右，擦写Flash较为频繁会导致产品寿命变短

**时间同步指令会频繁写flash，去掉该日志，平均一天的擦写次数在82次左右**

10000-100000 次擦写 使用寿命在 122 - 1220天，使用寿命还是较短



按照5万次擦写寿命计算，产品质保为5年，则日志每天写的次数不得超过的 28



## 2024/12/10

计算DDR剩余使用情况

![image-20241210110907080](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241210110907080.png)

![image-20241210110929079](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241210110929079.png)

- 可用DDR大小 61MB

```
.ddr.bss        0x0000000070347800   0x3c5b38
                0x0000000070347800                . = ALIGN (0x4)
                0x0000000070347800                __eram_bss_start__ = .
                
                
.ddr.text       0x000000007010f7e0    0xe5db8
                0x000000007010f7e0                . = ALIGN (0x4)
                0x000000007010f7e0                __eram_text_start__ = .
                
.ddr.data       0x00000000702df960    0x67ea0
                0x00000000702df960                . = ALIGN (0x4)
                0x00000000702df960                __eram_data_start__ = .   
                
.ddr.rodata     0x00000000701f6ba8    0xe8db8
                0x00000000701f6ba8                . = ALIGN (0x4)
                0x00000000701f6ba8                __eram_rodata_start__ = .   
                
              
 available heap 64895904    

64895904/1024/1024  = 61MB
                
```

- [x] DDR大小128MB , 剩余内存为 61 MB 
- [ ] 将视频缓存至ddr  15s 轮询   进行中……      实现较为困难
  - mm_module_ctrl函数底层使用静态库，无法查看底层实现，



## 2024/12/11

- [x] 已实现音视频缓存至RAM 15s，

  设置视频每秒帧数为15fps  设置缓存15fps*15s，缓存至DDR成功，使用H264对视频进行了压缩，当前内存剩余量为55MB 





## 2024/12/12

- [x] 保存MP4文件到SD卡，保存视频最长的时间为6min，超过该时间将自动切断，重新创建文件保存视频，

保存的视频文件名格式为   年月日时分秒   如 20241212134520

SD卡写满时处理方法

- 检查剩余空间是否满足下一次视频存储(按照最长的存储空间计算，可以多给一部分空间

删除最老视频的方法

- 系统启动时，在第一次录制视频时，将视频文件名存储到一个索引文件，在检测到要删除最老的视频时，查看索引文件，索引文件中存储着最老的文件，可以直接获得该文件名直接删除，删除之后查找当前最老文件附近最旧的文件，替换索引文件中的旧文件名称

**优点** 可以快速查找到最旧的文件直接删除，

**缺点** 当停止录像后，有一个较长的时间间隔，此时查找最旧的文件非常耗时， 不适用

其他方式，每次写一个文件时，将文件名更新至索引，每次读取文件最开始的字节知晓删除的文件，更新索引中的文件直接删除前几个字节，此处的问题是，fatfs文件系统 不支持在文件中索引删除(不能删除指定数据)，

- [ ] 目前还没有想好合适的算法删除最老的视频，需要考虑到查找速度应该足够快，可以牺牲空间换时间



## 2024/12/13

fatfs文件系统实现打印文件函数，打印的文件如下，可以看到文件打印是按照文件创建的先后顺序打印的，

```

File: 20241212134740.mp4, Size: 3315894 bytes

File: 20241212134810.mp4, Size: 2807223 bytes

File: 20241212134835.mp4, Size: 3645697 bytes

File: 20241212134914.mp4, Size: 1581912 bytes

File: 20241212134940.mp4, Size: 1475362 bytes

File: 20241212135020.mp4, Size: 2301132 bytes

File: 20241212135046.mp4, Size: 1578096 bytes

File: 20241212135057.mp4, Size: 8658189 bytes

File: 20241212135215.mp4, Size: 1720941 bytes

File: 20241212135253.mp4, Size: 9042486 bytes

File: 20241213090528.mp4, Size: 10116604 bytes

File: 20241213090646.mp4, Size: 4201491 bytes

File: 20241213090720.mp4, Size: 5265550 bytes

File: 20241213090805.mp4, Size: 3507007 bytes

File: 20241213090838.mp4, Size: 5272187 bytes
```

依据此特性实现直接删除旧文件

- 存储即将不够时
- 遍历所有文件获得文件名
- 删除文件
- 获取剩余空间
- 剩余空间足够安全存储下一次的视频，跳出该函数

![image-20241213094122359](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213094122359.png)

![image-20241213094735989](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213094735989.png)

实际测试下来，删除的文件似乎并不是按照删除最旧的删除，拔下sd卡查看文件情况，最旧的文件没有被删除，**此方法不可行**

![image-20241213095207823](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213095207823.png)

**牺牲空间的方法构想**

由于ddr内存较大，剩余空间五十多MB, 在系统启动时候读取所有文件名保存在堆中(使用链表实现)，读取的文件时间为随机排序的，需要先将文件按照时间进行排序，删除旧文件时直接删除链表头，新增加的文件增加到链表尾

**优点：**可快速删除旧文件

**缺点：**消耗系统启动时间

**评估使用最大的堆：**

存储视频的时间为30s，一天创建文件7200个，预估一天使用存储大小为10G ，

64G的存储卡 可存储文件 46080

128G的存储卡 可存储文件 92160    一个节点的大小预计为 18+4+4 字节，结构体对齐后预计为28字节

92160*28 = 2580480字节 = 2520KB = 2.46M ,大小可接受，



突然想到该sdk包中有支持sqlite，直接利用sqlite存储文件名应该是个不错的选择，查看sqlite使用的是sd卡作为存储，

使用sqlite可以更加方便的添加与删除，更加稳定，使用此方案，可以更好管理文件，

在ubuntu系统上安装sqlite验证

```
sudo apt-get update
sudo apt-get install sqlite3

//C/C++ 程序中使用 SQLite 的 C API
sudo apt-get install libsqlite3-dev

启动
sqlite3
```



创建一个文件信息表，一个字段存储时间，一个字段存储文件名，再向这个表中写入数据，时间的格式为xxxx-xx-xx xx:xx:xx   文件名字的格式为202412131212.mp  其中存储时xxxx-xx-xx xx:xx:xx对应文件时间，向表中写十个数据，时间由小到大

```
-- 启动 SQLite 并连接到数据库文件
sqlite3 file_database.db


-- 创建表，包含 文件时间和文件名两个字段
CREATE TABLE IF NOT EXISTS file_info (
    file_time TEXT NOT NULL,
    filename TEXT NOT NULL
);

-- 向表中插入10条数据，每条记录的时间依次增加，以实现时间由小到大
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:01:00', '202412131201.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:02:00', '202412131202.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:03:00', '202412131203.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:04:00', '202412131204.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:05:00', '202412131205.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:06:00', '202412131206.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:07:00', '202412131207.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:08:00', '202412131208.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:09:00', '202412131209.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:10:00', '202412131210.mp');

-- 查询验证结果
SELECT * FROM file_info ORDER BY file_time ASC;

-- 获取最新记录
SELECT * FROM file_info
ORDER BY file_time DESC
LIMIT 1;

-- 获取最老记录
SELECT * FROM file_info
ORDER BY file_time ASC
LIMIT 1;

-- 删除最老的记录
WITH oldest AS (
    SELECT filename FROM file_info
    ORDER BY file_time ASC
    LIMIT 1
)
DELETE FROM file_info
WHERE filename IN (SELECT filename FROM oldest);

-- 验证删除结果
SELECT * FROM file_info ORDER BY file_time ASC;

```

![image-20241213113634956](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213113634956.png)

![image-20241213113854554](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213113854554.png)

上述中可以看到这样是可行的，可以查询最老的字段并直接删除

测试使用sqlite的C语言的api来实现这一步骤

```
#include <stdio.h>
#include <stdlib.h>
#include <sqlite3.h>
#include <string.h>

// 数据库文件名
#define DATABASE_NAME "file_database.db"

// 回调函数用于打印查询结果
static int callback(void *NotUsed, int argc, char **argv, char **azColName){
    for(int i = 0; i < argc; i++) {
        printf("%s = %s\t", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

// 函数声明
int drop_table(sqlite3 *db);
int create_table(sqlite3 *db);
int insert_data(sqlite3 *db);
int query_all_records(sqlite3 *db);
int get_latest_record(sqlite3 *db);
int get_oldest_record(sqlite3 *db);
int delete_oldest_record(sqlite3 *db);
int verify_deletion(sqlite3 *db);

int main(int argc, char* argv[]) {
    sqlite3 *db;
    int rc;

    // 打开连接到数据库文件（如果不存在，将创建一个新的）
    rc = sqlite3_open(DATABASE_NAME, &db);
    if(rc){
        fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db));
        return(0);
    } else {
        fprintf(stdout, "成功打开数据库\n");
    }

    // 删除表（如果存在）
    if(drop_table(db) != SQLITE_OK){
        fprintf(stderr, "删除表失败\n");
        sqlite3_close(db);
        return 1;
    }

    // 创建表
    if(create_table(db) != SQLITE_OK){
        fprintf(stderr, "创建表失败\n");
        sqlite3_close(db);
        return 1;
    }

    // 插入数据
    if(insert_data(db) != SQLITE_OK){
        fprintf(stderr, "插入数据失败\n");
        sqlite3_close(db);
        return 1;
    }

    // 查询所有记录
    printf("\n所有记录（按时间升序排列）：\n");
    if(query_all_records(db) != SQLITE_OK){
        fprintf(stderr, "查询所有记录失败\n");
    }

    // 获取最新记录
    printf("\n最新记录：\n");
    if(get_latest_record(db) != SQLITE_OK){
        fprintf(stderr, "获取最新记录失败\n");
    }

    // 获取最老记录
    printf("\n最老记录：\n");
    if(get_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, "获取最老记录失败\n");
    }

    // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, "删除最老记录失败\n");
    } else {
        printf("\n已删除最老的记录。\n");
    }

    // 验证删除结果
    printf("\n删除后的记录（按时间升序排列）：\n");
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, "验证删除结果失败\n");
    }

     // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, "删除最老记录失败\n");
    } else {
        printf("\n已删除最老的记录。\n");
    }

    // 验证删除结果
    printf("\n删除后的记录（按时间升序排列）：\n");
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, "验证删除结果失败\n");
    }

    // 关闭数据库连接
    sqlite3_close(db);
    return 0;
}

// 删除表的函数
int drop_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "DROP TABLE IF EXISTS file_info;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "删除表 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf("表 'file_info' 已删除（如果存在）。\n");
    return SQLITE_OK;
}

// 创建表的函数
int create_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        "CREATE TABLE IF NOT EXISTS file_info ("
        "file_time TEXT NOT NULL, "
        "filename TEXT NOT NULL"
        ");";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "创建表 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf("表 'file_info' 已创建或已存在。\n");
    return SQLITE_OK;
}

// 插入数据的函数
int insert_data(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        "INSERT INTO file_info (file_time, filename) VALUES "
        "('2024-12-13 12:01:00', '202412131201.mp'),"
        "('2024-12-13 12:02:00', '202412131202.mp'),"
        "('2024-12-13 12:03:00', '202412131203.mp'),"
        "('2024-12-13 12:04:00', '202412131204.mp'),"
        "('2024-12-13 12:05:00', '202412131205.mp'),"
        "('2024-12-13 12:06:00', '202412131206.mp'),"
        "('2024-12-13 12:07:00', '202412131207.mp'),"
        "('2024-12-13 12:08:00', '202412131208.mp'),"
        "('2024-12-13 12:09:00', '202412131209.mp'),"
        "('2024-12-13 12:10:00', '202412131210.mp');";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "插入数据 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf("成功插入10条记录。\n");
    return SQLITE_OK;
}

// 查询所有记录的函数
int query_all_records(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time ASC;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "查询所有记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最新记录的函数
int get_latest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time DESC LIMIT 1;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "获取最新记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最老记录的函数
int get_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time ASC LIMIT 1;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "获取最老记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 删除最老记录的函数
int delete_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        "WITH oldest AS ("
        "    SELECT filename FROM file_info ORDER BY file_time ASC LIMIT 1"
        ") "
        "DELETE FROM file_info WHERE filename IN (SELECT filename FROM oldest);";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "删除最老记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 验证删除结果的函数
int verify_deletion(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time ASC;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "验证删除结果 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

```



```
编译
gcc main.c -o main -lsqlite3

运行
./mian
```



![image-20241213120004778](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213120004778.png)

上述实现可行，下一步将在amebapro中实现

- amebapor创建数据库并创建数据表(系统首次启动时创建，第二次启动只查看是否存在数据库)
- 视频开始录制时添加字段到数据表
- 视频将满的时候获取最老的记录删除





## 2024/12/16



```c
vfs_init(NULL);
vfs_user_register("sd", VFS_FATFS, VFS_INF_SD);
prv_set_interface_tag_in_sqlite_vfs(0);

int ret = sqlite_test();

if (ret == 0) {
printf("run sqlite test successfully [%d] \r\n", idx + 1);
pass_cnt++;
} else {
printf("run sqlite test fail [%d] \r\n", idx + 1);
}

//解初始化
vfs_user_unregister("sd", VFS_FATFS, VFS_INF_SD);
vfs_deinit(NULL);

static int sqlite_test(void)
{
    sqlite3_initialize();

	sqlite3 *db = NULL;
	char *zErrMsg = NULL;
	int rc;
	const char *sql;
	const char *data = "Callback function called";
	const char *database_name = "video_record.db";
    
    /* sqlite lib version */
	printf("SQLite version: %s \r\n", sqlite3_libversion());
    
    rc = sqlite3_open(database_name, &db);
	if (rc) {
		printf("Can't open database: %s\r\n", sqlite3_errmsg(db));
		goto sqlite_close;
	} else {
		printf("Opened database successfully\r\n");
	}
    
    //创建表
    
    
    
    
    
    
}



```





```c
#include <stdio.h>
#include <stdlib.h>
#include <sqlite3.h>
#include <string.h>

// 数据库文件名
#define DATABASE_NAME "file_database.db"

// 回调函数用于打印查询结果
static int callback(void *NotUsed, int argc, char **argv, char **azColName){
    for(int i = 0; i < argc; i++) {
        printf("%s = %s\t", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

// 函数声明
int drop_table(sqlite3 *db);
int create_table(sqlite3 *db);
int insert_data(sqlite3 *db, const char *file_time, const char *filename);
int query_all_records(sqlite3 *db);
int get_latest_record(sqlite3 *db);
int get_oldest_record(sqlite3 *db);
int delete_oldest_record(sqlite3 *db);
int verify_deletion(sqlite3 *db);


const char *timestamp1 = "2024-12-13 12:01:00";
const char *filename1 = "202412131201.mp";

const char *timestamp2 = "2024-12-13 12:02:00";
const char *filename2 = "202412131202.mp";

const char *timestamp3 = "2024-12-13 12:03:00";
const char *filename3 = "202412131203.mp";

const char *timestamp4 = "2024-12-13 12:04:00";
const char *filename4 = "202412131204.mp";


int main(int argc, char* argv[]) {
    sqlite3 *db;
    int rc;

    // 打开连接到数据库文件（如果不存在，将创建一个新的）
    rc = sqlite3_open(DATABASE_NAME, &db);
    if(rc){
        fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db));
        return(0);
    } else {
        fprintf(stdout, "成功打开数据库\n");
    }

    // 删除表（如果存在）
    if(drop_table(db) != SQLITE_OK){
        fprintf(stderr, "删除表失败\n");
        sqlite3_close(db);
        return 1;
    }

    // 创建表
    if(create_table(db) != SQLITE_OK){
        fprintf(stderr, "创建表失败\n");
        sqlite3_close(db);
        return 1;
    }

    // 插入数据
    // if(insert_data(db) != SQLITE_OK){
    //     fprintf(stderr, "插入数据失败\n");
    //     sqlite3_close(db);
    //     return 1;
    // }
    
    if (insert_data(db, timestamp1, filename1) != SQLITE_OK) {
        fprintf(stderr, "插入数据失败\n");
        sqlite3_close(db);
        return 1;
    }

    if (insert_data(db, timestamp2, filename2) != SQLITE_OK) {
        fprintf(stderr, "插入数据失败\n");
        sqlite3_close(db);
        return 1;
    }

    if (insert_data(db, timestamp3, filename3) != SQLITE_OK) {
        fprintf(stderr, "插入数据失败\n");
        sqlite3_close(db);
        return 1;
    }

     if (insert_data(db, timestamp4, filename4) != SQLITE_OK) {
        fprintf(stderr, "插入数据失败\n");
        sqlite3_close(db);
        return 1;
    }

    // 查询所有记录
    printf("\n所有记录（按时间升序排列）：\n");
    if(query_all_records(db) != SQLITE_OK){
        fprintf(stderr, "查询所有记录失败\n");
    }

    // 获取最新记录
    printf("\n最新记录：\n");
    if(get_latest_record(db) != SQLITE_OK){
        fprintf(stderr, "获取最新记录失败\n");
    }

    // 获取最老记录
    printf("\n最老记录：\n");
    if(get_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, "获取最老记录失败\n");
    }

    // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, "删除最老记录失败\n");
    } else {
        printf("\n已删除最老的记录。\n");
    }

    // 验证删除结果
    printf("\n删除后的记录（按时间升序排列）：\n");
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, "验证删除结果失败\n");
    }

     // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, "删除最老记录失败\n");
    } else {
        printf("\n已删除最老的记录。\n");
    }

    // 验证删除结果
    printf("\n删除后的记录（按时间升序排列）：\n");
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, "验证删除结果失败\n");
    }

    // 关闭数据库连接
    sqlite3_close(db);
    return 0;
}

// 删除表的函数
int drop_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "DROP TABLE IF EXISTS file_info;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "删除表 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf("表 'file_info' 已删除（如果存在）。\n");
    return SQLITE_OK;
}

// 创建表的函数
int create_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        "CREATE TABLE IF NOT EXISTS file_info ("
        "file_time TEXT NOT NULL, "
        "filename TEXT NOT NULL"
        ");";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "创建表 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf("表 'file_info' 已创建或已存在。\n");
    return SQLITE_OK;
}

// 插入数据的函数
// int insert_data(sqlite3 *db){
//     char *err_msg = 0;
//     const char *sql = 
//         "INSERT INTO file_info (file_time, filename) VALUES "
//         "('2024-12-13 12:01:00', '202412131201.mp'),"
//         "('2024-12-13 12:02:00', '202412131202.mp'),"
//         "('2024-12-13 12:03:00', '202412131203.mp'),"
//         "('2024-12-13 12:04:00', '202412131204.mp'),"
//         "('2024-12-13 12:05:00', '202412131205.mp'),"
//         "('2024-12-13 12:06:00', '202412131206.mp'),"
//         "('2024-12-13 12:07:00', '202412131207.mp'),"
//         "('2024-12-13 12:08:00', '202412131208.mp'),"
//         "('2024-12-13 12:09:00', '202412131209.mp'),"
//         "('2024-12-13 12:10:00', '202412131210.mp');";

//     int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
//     if(rc != SQLITE_OK ){
//         fprintf(stderr, "插入数据 SQL 错误: %s\n", err_msg);
//         sqlite3_free(err_msg);
//         return rc;
//     }

//     printf("成功插入10条记录。\n");
//     return SQLITE_OK;
// }


// 新的插入函数，传入要插入的 file_time 和 filename 参数
int insert_data(sqlite3 *db, const char *file_time, const char *filename) {
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO file_info (file_time, filename) VALUES (?, ?);";
    int rc;

    // 预编译 SQL 语句
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "预编译SQL失败: %s\n", sqlite3_errmsg(db));
        return rc;
    }

    // 绑定参数，将第1个问号绑定为 file_time，将第2个问号绑定为 filename
    sqlite3_bind_text(stmt, 1, file_time, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(stmt, 2, filename, -1, SQLITE_TRANSIENT);

    // 执行插入
    rc = sqlite3_step(stmt);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "插入数据失败: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return rc;
    }

    // 清理资源
    sqlite3_finalize(stmt);

    printf("成功插入记录: %s, %s\n", file_time, filename);
    return SQLITE_OK;
}


// 查询所有记录的函数
int query_all_records(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time ASC;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "查询所有记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最新记录的函数
int get_latest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time DESC LIMIT 1;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "获取最新记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最老记录的函数
int get_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time ASC LIMIT 1;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "获取最老记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 删除最老记录的函数
int delete_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        "WITH oldest AS ("
        "    SELECT filename FROM file_info ORDER BY file_time ASC LIMIT 1"
        ") "
        "DELETE FROM file_info WHERE filename IN (SELECT filename FROM oldest);";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "删除最老记录 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 验证删除结果的函数
int verify_deletion(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = "SELECT * FROM file_info ORDER BY file_time ASC;";

    int rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, "验证删除结果 SQL 错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

```

## 2024/12/16

- [x] 动态侦测触发时，将缓存在ddr中的历史录像10s,以及当前动态侦测录像，写入sd卡中保存，实际测试查看录像验证成功



## 2024/12/17

- [x] 更新fatfs文件的创建时间与修改时间

fatfs文件系统文件创建时间与文件修改时间无变化

![image-20241217104608345](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241217104608345.png)

文件系统的修改日期不一致，需要同步时间~

```
FILINFO 结构体是FatFs库中用于存储或获取文件（或目录）信息的一个数据结构。其各字段含义如下：

FSIZE_t fsize：
文件大小（以字节为单位）。当获取文件信息时，这里存储该文件的长度。

WORD fdate：
文件的最后修改日期。日期的格式为FAT文件系统使用的内部格式：

复制代码
bit15:9   年 (从1980年起计数)
bit8:5    月 (1–12)
bit4:0    日 (1–31)
比如，如果fdate的值对应2024年12月17日，那会将(2024-1980)=44存入bit15:9中、12存入bit8:5中、17存入bit4:0中。

WORD ftime：
文件的最后修改时间。时间格式同样为FAT格式：

复制代码
bit15:11  时 (0–23)
bit10:5   分 (0–59)
bit4:0    秒 (以2秒为单位, 范围0–29)
比如，14:30:10（10秒应转换为2秒计数的5）则对应(14<<11) | (30<<5) | 5。
```

fatfs提供的接口函数更改如下

```
需注意获取网络时间时需要先进行sntp的初始化，这里依赖的是网络时间，在断网的情况下应该使用rtc

DWORD get_fattime(void)
{
	DWORD time_abs;
	struct tm tim_now = sntp_gen_system_time_s(8 * 3600);

	time_abs = ((DWORD)(tim_now.tm_year - 1980) << 25) /* Fixed to Feb. 2, 2016 */
			   | ((DWORD)tim_now.tm_mon << 21)
			   | ((DWORD)tim_now.tm_mday << 16)
			   | ((DWORD)tim_now.tm_hour << 11)
			   | ((DWORD)tim_now.tm_min << 5)
			   | ((DWORD)tim_now.tm_sec >> 1);

	return time_abs;
}
```

更改后  创建文件时间与修改时间就正确了

![image-20241217175111609](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241217175111609.png)

## 2024/12/18

在application中使用sqlite3时需包源文件以及路径，直接使用sqlite3时会报错，需使用cmake配置sqlite中的一些宏定义

引入源码 application.cmake

```
list(
	APPEND app_sources
	
	${sdk_root}/component/application/sqlite/sqlite_port_8735b/ameba_sqlite_io_methods.c
	${sdk_root}/component/application/sqlite/sqlite_port_8735b/ameba_sqlite_mutex.c
	${sdk_root}/component/application/sqlite/sqlite_port_8735b/ameba_sqlite_vfs.c
	${sdk_root}/component/application/sqlite/sqlite_3.40.0/sqlite3.c
)
```

引入头文件  includepath.cmake

```
  "${sdk_root}/component/application/sqlite/sqlite_3.40.0"
  "${sdk_root}/component/application/sqlite/sqlite_port_8735b"
```

此时编译报错

```
/home/hdj/amb82-mini-RTL8735B/sdk-ameba-v9.6b/component/application/sqlite/sqlite_3.40.0/sqlite3.c:36747:10: fatal error: sys/ioctl.h: No such file or directory
36747 | #include <sys/ioctl.h>
```

需要设置编译时的宏定义

```
	CONFIG_BUILD_RAM=1 
	CONFIG_BUILD_LIB=1 
	CONFIG_PLATFORM_8735B
	CONFIG_RTL8735B_PLATFORM=1
	CONFIG_SYSTEM_TIME64=1

    # SQLITE configuration
	SQLITE_OMIT_LOAD_EXTENSION=1
	SQLITE_OMIT_WAL=1
	SQLITE_OMIT_AUTOINIT=1
	SQLITE_OMIT_SHARED_CACHE=1
	SQLITE_OMIT_DEPRECATED=1
	SQLITE_THREADSAFE=1
	NDEBUG
	# SQLITE_DEBUG
	SQLITE_OS_OTHER=1
	SQLITE_OS_FREERTOS=1
	SQLITE_MUTEX_FREERTOS=1
```

![image-20241218105850685](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241218105850685.png)

解释

```
CONFIG_BUILD_RAM=1：表示构建时使用 RAM。
CONFIG_BUILD_LIB=1：表示构建库。
CONFIG_PLATFORM_8735B：指定平台为 RTL8735B。
SQLITE_OMIT_*：禁用 SQLite 的某些功能，如扩展加载、写时复制(WAL)、自动初始化、共享缓存和废弃的功能。这是为了减小 SQLite 的大小和提升性能。
SQLITE_THREADSAFE=1：启用线程安全功能。
SQLITE_OS_FREERTOS=1 和 SQLITE_MUTEX_FREERTOS=1：配置 SQLite 在 FreeRTOS 系统上的操作，支持 FreeRTOS 的互斥锁。
SQLITE_OS_OTHER=1：标明系统平台为其他类型。
```

配置上述后编译正常无报错



添加功能代码

- sqlite初始化
- 写文件时同时插入数据至数据库中
- 磁盘空间检测，空间检测，磁盘不够用时查找数据库中最老文件并删除，同时删除视频文件

- 实验进行前将sd卡做两个分区，第一个分区为100M, 软件上检测磁盘空间小于80M时删除最老文件，直至存储空间剩余80M为止







## 2024/12/19

- [x] 利用数据库实现了快速删除最旧文件，保证存储空间即将满时有足够容量存储新文件

已实现功能代码，对日志分析如下

```
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 14:54:18 filename = 20241219145418.mp4
file_time = 2024-12-19 14:54:29 filename = 20241219145429.mp4
file_time = 2024-12-19 14:54:50 filename = 20241219145450.mp4
file_time = 2024-12-19 14:55:11 filename = 20241219145511.mp4
file_time = 2024-12-19 14:55:35 filename = 20241219145535.mp4
file_time = 2024-12-19 14:56:03 filename = 20241219145603.mp4
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
STORAGE_STOP
video_len = 165 audio_len = 76 moov_len = 7838 total_size = 1297383
Record stop
STORAGE_STOP -> STORAGE_IDLE
Record end
start recording 20241219145827
.....................................sd free spase is 79MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145418.mp4
成功删除文件: 20241219145418.mp4
要删除的最老记录的文件: 1219145418.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 80MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145429.mp4
成功删除文件: 20241219145429.mp4
要删除的最老记录的文件: 1219145429.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 81MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145450.mp4
成功删除文件: 20241219145450.mp4
要删除的最老记录的文件: (219145450.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 83MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145511.mp4
成功删除文件: 20241219145511.mp4
要删除的最老记录的文件: 1219145511.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 85MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145535.mp4
成功删除文件: 20241219145535.mp4
要删除的最老记录的文件: 1219145535.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 86MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145603.mp4
成功删除文件: 20241219145603.mp4
要删除的最老记录的文件: 1219145603.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 90MB 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 
成功插入记录: 2024-12-19 14:58:27, 20241219145827.mp4
Start MP4 recording (1 files)
STORAGE_INIT
open file (0:/20241219145827.mp4) len = 305 seconds
STORAGE_INIT -> STORAGE_START
[MD] FPS = 10.85
[MD] FPS = 11.34
no motion for 10 seconds
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
file_time = 2024-12-19 14:58:27 filename = 20241219145827.mp4
hal_voe_send2voe too long 38710 cmd 0x00000209 p1 0x00000001 p2 0x00000000
STORAGE_STOP
video_len = 216 audio_len = 100 moov_len = 9954 total_size = 1909397
Record stop
STORAGE_STOP -> STORAGE_IDLE
Record end
[MD] FPS = 11.25
[MD] FPS = 11.25
start recording 20241219145903
.....................................sd free spase is 88MB 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 
成功插入记录: 2024-12-19 14:59:03, 20241219145903.mp4
Start MP4 recording (1 files)
STORAGE_INIT
```

未删除前文件

```
file_time = 2024-12-19 14:54:18 filename = 20241219145418.mp4
file_time = 2024-12-19 14:54:29 filename = 20241219145429.mp4
file_time = 2024-12-19 14:54:50 filename = 20241219145450.mp4
file_time = 2024-12-19 14:55:11 filename = 20241219145511.mp4
file_time = 2024-12-19 14:55:35 filename = 20241219145535.mp4
file_time = 2024-12-19 14:56:03 filename = 20241219145603.mp4
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
```

空间不足删除后文件

```
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
file_time = 2024-12-19 14:58:27 filename = 20241219145827.mp4
```

上述日志可以看出，每次删除的都是最旧的文件，保留最新的文件



空间再次满时下一轮日志分析

```
STORAGE_INIT -> STORAGE_START
[MD] FPS = 11.22
no motion for 10 seconds
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 15:03:37 filename = 20241219150337.mp4
file_time = 2024-12-19 15:03:49 filename = 20241219150349.mp4
file_time = 2024-12-19 15:04:28 filename = 20241219150428.mp4
file_time = 2024-12-19 15:05:12 filename = 20241219150512.mp4
file_time = 2024-12-19 15:05:35 filename = 20241219150535.mp4
file_time = 2024-12-19 15:06:01 filename = 20241219150601.mp4
file_time = 2024-12-19 15:06:43 filename = 20241219150643.mp4
file_time = 2024-12-19 15:06:58 filename = 20241219150658.mp4
file_time = 2024-12-19 15:07:23 filename = 20241219150723.mp4
STORAGE_STOP
video_len = 188 audio_len = 86 moov_len = 8770 total_size = 1684272
Record stop
STORAGE_STOP -> STORAGE_IDLE
Record end
[MD] FPS = 11.25
[MD] FPS = 11.34
start recording 20241219150748
.....................................sd free spase is 79MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150337.mp4
成功删除文件: 20241219150337.mp4
要删除的最老记录的文件: 1219150337.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 81MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150349.mp4
成功删除文件: 20241219150349.mp4
要删除的最老记录的文件: 1219150349.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 82MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150428.mp4
成功删除文件: 20241219150428.mp4
要删除的最老记录的文件: 1219150428.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 87MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150512.mp4
成功删除文件: 20241219150512.mp4
要删除的最老记录的文件: (219150512.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 88MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150535.mp4
成功删除文件: 20241219150535.mp4
要删除的最老记录的文件: (219150535.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 90MB 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 
成功插入记录: 2024-12-19 15:07:48, 20241219150748.mp4
Start MP4 recording (1 files)
STORAGE_INIT
open file (0:/20241219150748.mp4) len = 305 seconds
STORAGE_INIT -> STORAGE_START
[MD] FPS = 10.91
[MD] FPS = 11.25
[MD] FPS = 11.25
[MD] FPS = 11.25
no motion for 10 seconds
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 15:06:01 filename = 20241219150601.mp4
file_time = 2024-12-19 15:06:43 filename = 20241219150643.mp4
file_time = 2024-12-19 15:06:58 filename = 20241219150658.mp4
file_time = 2024-12-19 15:07:23 filename = 20241219150723.mp4
file_time = 2024-12-19 15:07:48 filename = 20241219150748.mp4
hal_voe_send2voe too long 38476 cmd 0x00000209 p1 0x00000001 p2 0x00000000
STORAGE_STOP
video_len = 860 audio_len = 398 moov_len = 36502 total_size = 7476366
Record stop
```

上述日志分析可再次确认删除的为最旧的数据

验证

- [x] 稳定性验证：**磁盘分区为100M,磁盘不足80M时开始删除旧文件，直至剩余空间为90M**，一直动态侦测。数小时后查看数据库中的数据是否与视频文件是否一致（确保是否存在漏删除的文件）**安装Navicat查看数据库中的数据**

**短时间验证（大概经过五次删除文件）**

查看sd卡中有6个视频文件，这时候数据库文件中也应该存储有这6个视频文件名字才对

![image-20241219152441931](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241219152441931.png)

- **验证结果一致**

![image-20241219152416738](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241219152416738.png)



**长时间验证(经过两小时后验证15:30 - 17:30)**

- 经过多轮的删除写入，验证结果一致

![image-20241219173258227](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241219173258227.png)





- [ ] 大量存储验证： 磁盘分区为1G时进行验证，查看存储数据多时，删除时间是否会较长，造成系统卡死等问题，

  此测试应该屏蔽查看所有数据库数据  打印非常耗时，额外增加负担





## 2024/12/20

- [x] 昨日大量存储视频验证删除时间以及稳定性

磁盘分区为1G时保存视频验证，此时查看数据库中保存有181条视频记录，sd卡中包括数据库文件保存有182个文件

测试使用数据库保存视频名称稳定

![image-20241220110948716](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241220110948716.png)



- 目前存储的内容还是较少，扩大sd卡分区至20G继续测试，此时可以将sd卡中的内容拷贝一份，分区后拷贝进去，继续测试



- [x] 将目前实现的功能移植到最新版本v9.6c上

新增 cmos senser

```
    {1920, 1080, 30}, //DUMMY
	{1920, 1080, 30}, //SC2336
	{1920, 1080, 30}, //GC2053
	{2560, 1440, 24}, //GC4653
	{1920, 1080, 30}, //F37
	{1920, 1080, 30}, //IMX327
	{1536, 1536, 30}, //F51
	{1920, 1080, 30}, //PS5258
	{2048, 1536, 20}, //SC301
	{1920, 1080, 30}, //IMX307
	{1920, 1080, 30}, //SC2333
	{2560, 1440, 24}, //GC4023
	{1952, 1944, 24}, //PS5420
	{1536, 1536, 30}, //PS5270
	{2592, 1944, 15}, //GC5035
	{1920, 1080, 30}, //PS5268
	{1920, 1080, 30}, //SC2310
	{1952, 1944, 24}, //PS5420_HDR
	{1536, 1536, 30}, //PS5270_HDR
	
	{1920, 1080, 30}, //SENSOR_F53
	{1920, 1080, 30}, //SENSOR_F55
	{2560, 1440, 24}, //SENSOR_GC4663
	{2560, 1440, 20}, //SENSOR_GC4663_HDR
	{2000, 2000, 24}, //SENSOR_K351
	{2000, 2000, 20}, //SENSOR_K351_HDR
	{2048, 1536, 30}, //SENSOR_OV50A40
	{2048, 1536, 20}, //SENSOR_SC301_HDR
```

- 替换mmf2_video_example_md_mp4_init.c文件
- 包含sqlite的文件以及路径，宏定义配置
- 添加函数  void update_tim(char *file_name, FILINFO *fno);   至  fatfs_sdcard_api.c 并在  fatfs_sdcard_api.h声明
- ffconfig.h中使能宏定义   #define FF_USE_CHMOD   1
- main函数中添加 wps功能
- 设置摄像头senser



log:

VOE]sensor power on
[VOE]i2c_master_err_callback ERR:8, tx_len: 2, rx_len: 0
[VOE]i2c tx abrt source: 1
[VOE]i2c txflr: 2
[VOE][sensor_start][837]Errsensor_start check sensor id err 
[VOE]sensor power off

- [ ] 提示senson id错误，明天检查代码





linux上录制视频流

```
sudo apt update
sudo apt install ffmpeg


ffmpeg -i rtsp://your_camera_ip/stream_path -c copy -f segment -segment_time 60 -strftime 1 "%Y-%m-%d_%H-%M-%S.mp4"

//开始录制
ffmpeg -i rtsp://192.168.8.15:554 -c copy -f segment -segment_time 60 -strftime 1 "%Y-%m-%d_%H-%M-%S.mp4"
//打印详细信息
ffmpeg -loglevel debug -i rtsp://192.168.8.15:554 -c copy -f segment -segment_time 60 -strftime 1 "%Y-%m-%d_%H-%M-%S.mp4"

```

**解释：**

- `-i rtsp://your_camera_ip/stream_path`：指定 RTSP 流的地址。
- `-c copy`：复制流数据，而不是重新编码，保持原视频质量。
- `-f segment`：指定使用分段模式，将视频拆分为多个文件。
- `-segment_time 60`：每个视频段的时长为 60 秒（即 1 分钟）。
- `-strftime 1`：启用时间格式化，允许使用当前时间戳来命名文件。
- `"%Y-%m-%d_%H-%M-%S.mp4"`：输出文件的命名格式，按照年月日时分秒命名（例如：`2024-12-20_14-30-00.mp4`）。

上述录制只有音频没有视频



ffmpeg -i rtsp://192.168.8.15:554 -c:v libx264 -c:a aac -f segment -segment_time 60 -strftime 1 "%Y-%m-%d_%H-%M-%S.mp4"



ubuntu软件包下载失败

阿里云镜像站或其他站下载 Ubuntu 软件包时遇到 DNS 解析问题。这通常是由于系统无法解析域名 `mirrors.aliyun.com`。

更换 DNS 服务器

```
sudo vim /etc/resolv.conf
```

在文件中添加以下内容，使用 Google 的 DNS   

```
nameserver 8.8.8.8
nameserver 8.8.4.4
```





## 2024/12/21

- [x] 将sdk-v9.6b版本实现的功能代码移植到sdk-v9.6c 完成并测试通过

- [ ] 了解到Mdns网络协议，可优化串流连接方式，串流的流程如下

  - 打开vlc，输入ip以及端口，由于是DHCP,IP是动态的，当网络环境发生变化时需要知道设备的ip，使用mDNS可将用户名替换为ip

    

**mDNS** 的全称是 **Multicast DNS**（多播 DNS），它是一种在局域网（LAN）内使用多播进行 DNS 查询和解析的协议。mDNS 使得设备能够在没有传统 DNS 服务器的情况下，通过主机名解析获取 IP 地址，并支持在局域网内进行设备发现和服务发现

在传统的 DNS 中，设备通过查询一个公共或私有的 DNS 服务器来解析域名（如 `example.com`）到 IP 地址。这种方式依赖于中心化的 DNS 服务器，并且需要配置 DNS 服务器及其记录。而在一个 **无中心化 DNS 服务器** 的局域网环境中（例如家庭网络或小型办公室），设备也需要能够通过主机名（如 `printer.local` 或 `mydevice.local`）进行相互发现。

**mDNS** 的出现就是为了解决在没有 DNS 服务器的情况下，设备如何在局域网内实现自动发现和解析。



应用示例：

- 群晖的Synology Assistant

- 共享文件samba服务也用到了mDNS
- 开发板，ssh登录 直接用名称登录也是开启了mDNS



![image-20241221165014277](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241221165014277.png)

![image-20241221164956831](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241221164956831.png)

![MobaXterm ssh登录](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/hostname-11.png)





## 2024/12/23

监控存储方案：

- 本地TF卡存储
- 局域网下存储（NVR方案）
- 云盘存储（对接云盘存储）

**网络视频录像机（NVR）**

- **特点**：专为IP摄像头设计，支持多路视频输入，内置视频管理软件，便于配置和管理。
- **适用场景**：中小型监控系统，安装简便，易于扩展。

**网络视频录像机（NVR）的工作方式确实涉及视频流的接收**。具体来说，NVR负责从网络中的IP摄像头接收实时视频流，并将这些视频流进行记录和管理。以下是对NVR与视频流接收之间关系的详细解释：

**NVR与视频流的关系**

1. **视频流接收**
   - **IP摄像头输出视频流**：IP摄像头通过网络（通常是以太网）将实时视频数据以流的形式传输出来，常见的协议包括RTSP（实时流协议）、RTMP等。
   - **NVR接收视频流**：NVR作为中心设备，负责接收来自各个IP摄像头的视频流。这些视频流通过局域网传输到NVR，NVR对其进行解码、处理和存储。
2. **集中管理**
   - **统一平台**：NVR提供一个集中管理的平台，用户可以通过NVR的界面查看、回放和管理所有接收到的视频流。
   - **实时监控与录制**：除了接收视频流，NVR还可以进行实时监控和定时录制，根据预设的录像计划自动存储视频数据。



- [x] 此方案使用NVR方案，需要与第三方的NVR录像机对接，



**配网方式**

Wi-Fi 配网

- WPS（Wi-Fi Protected Setup）
- AP 模式（Access Point Mode）

蓝牙配网

- 蓝牙传输ssid password配网

这里使用AP配网方案

配网大致流程如下

![image-20241223143923129](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223143923129.png)

上述需要实现的基本功能

- [ ] 系统第一次启动时，使用内置的ssid   password, 并写入flash保存

- [ ] 蓝牙配网的实现（开机连接到wifi失败时，打开蓝牙广播，与手机建立连接后，手机发送wifi配置信息）

- [ ] 重置按键 长按清除flash中的ssid信息并进行软件复位

- [ ] wifi连接状态指示灯，未连接wifi时指示灯熄灭，连接上wifi时指示灯闪烁



蓝牙配网可下载 **Easy WiFi Config**    应用商店搜索即可， iso与安卓都可下载

![image-20241223145140169](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223145140169.png)

![image-20241223145213761](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223145213761.png)

![image-20241223145238839](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223145238839.png)



系统开启蓝牙配网

Start BT Config     **ATBB=1**      

Stop BT Config     **ATBB=0** 

ATBB=0 

AT命令配置  蓝牙配网文件  atcmd_bt.c



开启蓝牙配网函数

```
bt_config_app_init();
set_bt_cmd_type(CONFIG_BIT | STACK_BIT);
```

关闭蓝牙配网函数

```
bt_config_app_deinit();     //关闭蓝牙配网
set_bt_cmd_type(0);
```



![image-20241223152133735](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223152133735.png)

- WIFI连接状态使用LED2来表示，未连接状态该LED常亮，连接状态该LED熄灭，此开发板不支持用户按键



lwip获取网络连接状态方法

```
https://blog.csdn.net/qq_42820594/article/details/126197207
```

```
if (netif_is_link_up(&gnetif))
{
    BSP_LED_Off(LED2);
}
else
{
    BSP_LED_On(LED2);
}
```



## 2024/12/24

- [x] 实现LED显示网络连接状态，闪烁网络连接上，未闪烁网络未连接

配网方式使用两种，wps和蓝牙配网，实际测试时，两者不能同时存在，开启wps的同时，蓝牙将连接不上

更改应用逻辑如下

- [x] 未连接到wifi时默认开启蓝牙配网，当长按某个按键时，开启wps配网，此时蓝牙配网将失效

由于此开发板没有用户按键可以使用了，自定义一个io, 外接高电平时判断为按键按下，已完成wps按键配网

**WPS key**

- 使用PF15作为 WPS按键，

![image-20241224110452539](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241224110452539.png)



![image-20241224110801847](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241224110801847.png)



实验过程

1.使用细针头注入

2.拔掉针头直接使用输液管注入

3.手动使用100ml针管，人工抽药，注入



结论与实验发现

- **使用细针头会限制流速，此种方式最慢**

- 直接使用输液管注入，此种方式较前一种快，**但由于容器未预留出气口，压强逐渐变大**，流速逐渐降低

  **170ml--->130ml  用时2min 30s**

- **使用100ml针管手推时，速度最快**，抽药与输注两轮，共计200ml,用时 1min 45s，由于使用针管较粗，操作过程会漏液



综合考虑，两种方案选择

**1.开大容器孔，选用较粗的管增加流速，需预留排气孔**

**2.使用人工抽药输注**



## 2024/12/25

对比sdk v9.6b和sdkv9.6c 的io引脚

针对客户原理图部分，我们根据我们sdk整理出以下不同的GPIO功能引脚：

```
45 - gpioF_0 -adc0
56 - GPIOF_10 - JTAG_TMS
57 - GPIOF_11 - JTAG_TRST
58 - GPIOF_12 - I2S_rx
59 - GPIOF_13 - I2S_sclk
68 - GPIOA_2 - COMP_ADC
69 - GPIOA_3 - COMP_ADC
70 - GPIOA_0 - COMP_ADC
71 - GPIOA_1 - COMP_ADC
```

- 软件上无法体现一些io的功能，sdk未定义,找到以下io

```c
i2s
#define I2S_SCLK_PIN            PF_13
#define I2S_WS_PIN              PF_15
#define I2S_TX_PIN              PF_14
#define I2S_RX_PIN              PF_12
#define I2S_MCK_PIN             PF_11

adc
#define MBED_ADC_EXAMPLE_PIN_0    PF_0
#define MBED_ADC_EXAMPLE_PIN_1    PF_1
#define MBED_ADC_EXAMPLE_PIN_2    PF_2
#define MBED_ADC_EXAMPLE_PIN_3    PF_3   //log uart
```



- [x] 蓝牙配网功能测试成功，应用逻辑已完成，

- [ ] 目前发现串流时vlc掉帧，较卡，可能是该开发板未接天线的原因，信号不好，网络跟不上

- [ ] 串流发现一个通道 缓存溢出？ 

  

  ![](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241225175633914.png)

  

## 2024/12/26

- [x] 昨日出现问题，串流时掉帧，与类似缓存溢出问题实际测试都是开发板没有天线造成的（用一根金属棒与天线接口接触这一现象就会解决）

![](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241225175633914.png)

- [x] 更改保存的视频格式为MJPEG，mjpeg格式的可裁切为图片作为视频证据
- [ ] 网络连接上时，当关闭wifi,20s内会自动扫描该网络建立连接，超过此时间不会继续扫描网络，这是系统库函数中实现，此逻辑需要更改，应该一直扫描连接

## 2024/12/27

ATW0=iPhone

ATW1=1234567890..

ATWC



- [x] 添加WPS配网指示灯

目前配网功能都已经完成，与王总沟通确定接下来的实现方向

- [ ] 远程语音播放，实现类似语音对讲的功能
- [ ] 软件控制
- [ ] 局域网保存视频，串流 or 存储同步



语音传输并通过喇叭播放”通常包含以下几个关键环节：

**1.手机端**音频采集、编码

**2.网络传输**（手机到摄像头）

**3.摄像头端**音频解码、播放

**1.手机端：如何采集并发送音频？**

**1.1 音频采集**

- 手机麦克风
  - 在 Android 或 iOS 系统上，都可以通过官方的音频录制 API（`AudioRecord`、`AVAudioEngine` 等）来获取麦克风输入。
  - 获取到的是 PCM 数据（未经压缩）。
  - 一般以**单声道**、**16bit**、**8kHz/16kHz**等参数为主，以减少数据量并满足通话/监控场景的音质要求。

**1.2 音频编码**

- 为了减小网络带宽占用、降低延迟，通常需要**先对 PCM 进行压缩**再传输。
- 常见的语音编码格式：
  - **G.711 (uLaw/aLaw)**：简单、延迟低，但码率较高（64kbps）。
  - **G.726**：能在 16~32kbps 间选择，常见于监控/对讲。
  - **AAC** / **OPUS**：音质更好、压缩率更高，但实现稍复杂。
- 在手机端如果使用厂商 SDK，可能内部就集成了编码模块。如果自行实现，可移植常见的开源库（如 WebRTC 中的编解码组件、或者 FFmpeg 等）来编码。

**1.3 发送到摄像头**

- 建立连接

  手机要与摄像头通过网络（Wi-Fi/4G/局域网等）建立通信。

  - 有的场景下手机和摄像头同处于同一个局域网，可能直接通过 RTSP/RTMP/WebSocket/TCP 等方式访问摄像头 IP 或者使用摄像头提供的私有协议端口。
  - 更多时候，摄像头在家中、手机在外网，需要**P2P**或**云服务器转发**来穿透 NAT。很多家用摄像头厂商都会提供自己的一套 P2P/云平台 SDK，用于建立双向音频/视频通道。

- 流媒体/协议封装

  - 如果摄像头支持 **双向 RTP** 通道（比如 RTSP 中反向音频流），手机可将编码后的音频打包成 RTP，向摄像头发送；
  - 如果使用厂商私有 SDK，那么就把编码后的音频帧通过 SDK 的“对讲接口”发送给云端或摄像头。SDK 会自动封装并传给摄像头。

- 推送方式

  - 常见做法是**“边采集、边编码、边发送”**，保证实时性；
  - 手机 App 通常会有“按住说话”或“对讲”按钮，一旦按下，就开始采集-编码-发送音频数据给摄像头；松开则结束发送。





![image-20241227162602198](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241227162602198.png)

先实现本地的音频解码播放，目前提供的demo是针对音频插孔的程序，该开发板不带放大功放芯片

测试i2s sdk包中使用的io为，该芯片找不到此io，

```
#define I2S_SCLK_PIN	PC_1
#define I2S_WS_PIN		PC_0
#define I2S_SD_PIN		PC_2
```

替换io  如下测试，示波器测量没有信号产生

```
#define I2S_SCLK_PIN	PD_14
#define I2S_WS_PIN		PD_17
#define I2S_SD_PIN		PD_15
```



## 2024/12/30

ameba 跳线测试VP10的音频播放电路ok，



![image-20241230112040366](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241230112040366.png)





## 2025/1/2

- [x] 实现咪头采集音频信号通过喇叭播放
- [ ] 调节音量大小未实现

## 2025/1/3

- [ ] 调节音量大小还未实现，调节 数字麦克风增益无反应

## 2025/1/4

测试新光宝全的网关，能分配ip，开机前几秒能ping通，但之后ping不通，无wifi，

单独测试摄像机可以通过WPS连接到我们的网关，IP 地址分配成功，但是查看摄像需要新光宝全的app,app需要网关认证



## 2025/1/6

使用ffmpeg将音频MP3文件转换成 aac文件与wav文件

| 特性         | MP3                                | AAC                                 | WAV                                |
| ------------ | ---------------------------------- | ----------------------------------- | ---------------------------------- |
| **压缩方式** | 有损压缩                           | 有损压缩                            | 无损                               |
| **音质**     | 较低（低比特率时音质损失明显）     | 优于 MP3（在相同比特率下）          | 无损，无任何音质损失               |
| **文件大小** | 小（高压缩率）                     | 更小（比 MP3 高效）                 | 大（无压缩或少量压缩）             |
| **兼容性**   | 极其广泛，几乎所有设备和播放器支持 | 支持主流设备和软件，但不如 MP3 广泛 | 广泛支持，但设备不如 MP3 和 AAC 多 |
| **使用场景** | 音乐存储、流媒体、便携设备         | 流媒体、苹果设备、音频压缩          | 专业音频编辑、录音和高质量音频存储 |

- **MP3**：适用于需要较小文件大小、广泛兼容性且音质要求不高的场景。
- **AAC**：适用于对音质有较高要求、同时还需要高压缩比的场景，尤其是流媒体。
- **WAV**：适用于需要保存最高音质、无损音频的专业音频存储和编辑场景。

需要高音质且文件较小，建议使用 **AAC**；对音质要求非常高且不在乎文件大小，可以选择 **WAV**；需要广泛的兼容性且文件大小适中，MP3 依然是一个常见的选择。



linux下安装ffmpeg，转换成采样率为16khz的 aac文件

```
ffmpeg -i test_audio.mp3 -ar 16000 -c:a aac -b:a 128k output_audio.aac
```

转换成采样率为16khz的wav文件

```
ffmpeg -i test_audio_mp3.mp3 -ar 16000 output_audio.wav
```



转码后的文件进行串流，这里使用的是转换后的wav文件

![image-20250106171034981](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171034981.png)

![image-20250106171200289](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171200289.png)

![image-20250106171215851](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171215851.png)

![image-20250106171355135](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171355135.png)

![image-20250106172235235](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172235235.png)

![image-20250106172526824](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172526824.png)

![image-20250106172539638](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172539638.png)

  ![image-20250106172641277](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172641277.png)

此处已经开始串流了，但是播放的声音一直是噪声，尝试其他格式的文件也是噪声，确定转换后的采样率一致，

尝试下载网络上其他16khz转换率的音乐，串流一样是噪声，目前怀疑是软件上的设定导致的错误，

当前软件实现现较为困难，开发周期可能较长





## 2025/1/7

更改功放电路部分

![image-20250107104515858](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250107104515858.png)

- 将输入直接接在C1上，audio-pw的R3断开，拉高



module_audio.c文件中可以调整喇叭的音量以及咪头的增益，将喇叭的音量调整为最大，当咪头的增益调整较大时会出现较大回声，将喇叭的音量调整最小时，增加一点咪头的增益也会出现回声，目前要增加音量就必须要增加咪头的增益，需要解决回声的问题



**搜索解决方案如下**

1. **物理设计优化**

- 距离与隔离
  - 增加麦克风和喇叭之间的物理距离，减少直接声传播。
  - 使用声学屏蔽材料（例如吸音材料）来隔离咪头和喇叭。
- 方向性调整
  - 选择指向性麦克风，并调整其拾音方向远离喇叭。
  - 使用定向扬声器，使声音主要集中在特定区域，避免进入麦克风拾音区域。

------

2. **信号处理方法**

(1) 回声消除 (AEC, Acoustic Echo Cancellation)

- 使用数字信号处理（DSP）技术，通过算法在麦克风信号中识别喇叭发出的声音并实时消除。
- 常用的AEC技术包括：
  - 自适应滤波器（Adaptive Filtering）：动态估计回声路径，抵消回声。
  - 时域和频域回声消除：分析音频信号在不同域中的特征来消除回声。

(2) 自动增益控制 (AGC, Automatic Gain Control)

- 动态调节麦克风的增益，降低输入音量以减少喇叭声音被拾取的概率。

(3) 降噪与滤波

- 应用高通滤波器（High-pass filter）和低通滤波器（Low-pass filter）来过滤特定频段的声音，从而抑制回声。
- 使用噪声门限（Noise Gate）技术，设置一个音量阈值，低于该阈值的信号被忽略。

------

3. **音频流程控制**

- 全双工切换为半双工：
  - 如果场景允许，可以采用半双工通信模式（即同一时间只能收音或播放），从根本上避免回声问题。
- 回声路径延迟处理：
  - 通过精确控制音频链路中的延迟，避免回声循环的产生。
- 动态音量调整：
  - 当系统检测到麦克风活动时，可以暂时降低喇叭音量。

------

4. **软硬件结合方案**

- 麦克风阵列（Microphone Array）：
  - 采用多麦克风阵列，通过波束形成（Beamforming）技术增强特定方向的声音，减少喇叭方向的声音拾取。
- 专用回声消除芯片：
  - 使用内置AEC的音频处理芯片（例如Cirrus Logic、Texas Instruments或Synaptics的产品），硬件实现回声消除。
- 软件算法：
  - 如果系统中有处理能力，可以集成开源的回声消除算法，如WebRTC的AEC模块。



## 2025/1/8

![image-20250108093307894](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108093307894.png)

![image-20250108093331937](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108093331937.png)

开发手册中 回声和嚎叫  解释到，

- 发送端和接收端的设备距离太近
- 音量太大或麦克风太敏感
- AEC未打开
- AEC参数设置不正确

目前产生回声和嚎叫的情况为 AEC参数未打开，麦克风太敏感了

开启AEC,最终测试咪头的增益为AUDIO_MIC_20DB时，.ADC_gain = 0x4A时，此时麦克风的音量较大且距离较远时没有回声。

```c
.mic_gain           = AUDIO_MIC_20DB,    //咪头增益   0db 20db 30db 40db
.dmic_l_gain        = DMIC_BOOST_36DB,  //左声道喇叭音量   0db 12db 24db 36db
.dmic_r_gain        = DMIC_BOOST_36DB,  //右声道喇叭音量   0db 12db 24db 36db
```

```c
//ADC_gain: set the dgain for mic path. Support -17.625dB (0x00) ~ 30dB (0x7F)
.ADC_gain      = 0x4A,   //ADC path Dgain about 20dB 
```

查找spi屏幕的驱动芯片手册并下载查看驱动源码

![image-20250108175227971](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108175227971.png)

![image-20250108175311424](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108175311424.png)

## 2025/1/9

- 移植st7789v spi lcd 驱动

确定spi的控制io 

```C
sclk ---> PE1
miso ---> PE2
mosi ---> PE3
cs   ---> PE4

RST  ---> PD17
RS   ---> PD18
```

- [x] 移植ST 7789v 的驱动至 RTL 8735完成 ,编译通过，当前没有硬件测试环境，不确定驱动是否需要更改



## 2025/1/10

连接PIN

![9a053000f82c996937cd0c28991dc64](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/9a053000f82c996937cd0c28991dc64.jpg)

![image-20250110133929975](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250110133929975.png)

![image-20250110133957861](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250110133957861.png)

![image-20250110155546636](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250110155546636.png)

软件接口

```
RS
CS
SCL  时钟线
SDA  数据线
RES  复位线

sclk ---> PE1     15
miso ---> PE2     14
cs   ---> GND     12

RST  ---> PD17     17
RS   ---> PD18     16
```



- 当前驱动测试未能成功刷写屏幕，使用屏幕厂家的 命令与数据配置，还是未能成功

  先使用 STM32F103C8 原测试代码，测试屏幕是否可以正常刷新，确保能在F103C8跑起来再移植过去



## 2025/1/13

实现st7789 lcd 软件模式spi 驱动,成功显示，但需调整为横屏

调整命令与 下列相关，当前还未调试出

```
LCD_WR_REG(0x36);

LCD_WR_REG(0x2A);

LCD_WR_REG(0x2B);
```



## 2025/1/14

更改屏幕io接线

```
sclk ---> PF6     1    // scl
mosi ---> PF7     2    // sda
cs   ---> GND         // 片选直接拉地

RST  ---> PD17    17    // 复位
RS   ---> PD18    16      // cmd/data
```

- [x] 实现硬件spi驱动  频率10MHZ     初始化spi时选择 mode 3模式   点不亮与 极性与相位相关

## 2025/1/16

- [ ] 移植lvgl编译通过但系统卡死，  
  -  修改camek文件    添加源文件   ，设置lvgl心跳，设置缓冲区，填写lvgl接口函数

## 2025/1/17

- [x] 解决卡死问题，为定义缓冲区存在错误已改正

  ```c
      LV_ATTRIBUTE_MEM_ALIGN
      static uint8_t buf_1_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];            /*A buffer for 10 rows*/
      lv_display_set_buffers(disp, buf_1_1, NULL, sizeof(buf_1_1), LV_DISPLAY_RENDER_MODE_PARTIAL);
  ```

  - 烧录程序运行，但是提示LVGL无心跳, 当前的心跳函数是加入systick中断中的

```C
[Warn]  (0.000, +0)      lv_timer_handler: It seems lv_tick_inc() is not called. lv_timer.c:89
```

- 将心跳函数加入其他中断

使用软件定时器TIMER2  做1ms 中断，将LVGL心跳加入 该中断，io翻转 示波器测量查看中断1ms准确

- [ ] 目前lvgl可以运行，但是屏幕的刷写存在问题，造成显示与颜色不正常，怀疑还是驱动配置的问题，

明天使用stm32开发板验证驱动，当前的开发板烧写测试要两三分钟，



## 2025/1/18

当前使用的硬件spi的帧率较低，18帧用时3s 左右    使用DMA的方式来渲染图像，

目前使用dma的发送函数就会造成系统卡死，原因未找到



## 2025/1/20

- [x] 实现 硬件spi+dma 

  当前测试20帧的时间为 796ms      1s 约 25帧    使用全图填充  

![image-20250120175313625](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250120175313625.png)

- 实际测试发现，最后一帧存在不显示的情况，（前20帧全图刷新，最后一帧使用非dma的方式画圆与显示字符）



## 2025/1/21

- spi 硬件dma发现颜色错误，更改填充函数LCD_Fill

```
uint16_t swap_color = (color >> 8) | (color << 8);  
```

```c
void LCD_Fill(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)
{          
	u16 i,j; 
	LCD_Address_Set(xsta,ysta,xend-1,yend-1);//设置显示范围
	uint16_t swap_color = (color >> 8) | (color << 8);  

	 for(i = 0 ; i < DMA_SPI_BUF_SIZE; i++)
    {
        Spi2DmaBuffer[i] = swap_color; 
    }

	for(i = 0; i < 16/*(SCREEN_SIZE/DMA_SPI_BUF_SIZE)*/; i++)
	{
		TrDone = 0;      
		spi_master_write_stream_dma(&spi_master, Spi2DmaBuffer, DMA_SPI_BUF_SIZE);
		while (TrDone == 0) {
	    }
	}
	vTaskDelay(2000);
}
```

- lvgl 使用双缓冲

```c
LV_ATTRIBUTE_MEM_ALIGN     static uint8_t buf_2_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];      LV_ATTRIBUTE_MEM_ALIGN     static uint8_t buf_2_2[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];     lv_display_set_buffers(disp, buf_2_1, buf_2_2, sizeof(buf_2_1), LV_DISPLAY_RENDER_MODE_PARTIAL);
```

- lvgl 接口更改 当前使用画点函数

```c
static void disp_flush(lv_display_t * disp_drv, const lv_area_t * area, uint8_t * px_map)
{
    if(disp_flush_enabled) {
        /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/
        int32_t x;
        int32_t y;
        for(y = area->y1; y <= area->y2; y++) {
            for(x = area->x1; x <= area->x2; x++) {
                /*Put a pixel to the display. For example:*/
                /*put_px(x, y, *px_map)*/

                uint16_t color = (px_map[1] << 8) | px_map[0]; 

                LCD_DrawPoint(x, y, color);

                px_map+=2;
            }
        }
    }

    /*IMPORTANT!!!
     *Inform the graphics library that you are ready with the flushing*/
    lv_display_flush_ready(disp_drv);
}
```


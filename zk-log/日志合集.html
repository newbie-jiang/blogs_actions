
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>日志合集</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h2 id="2024129">2024/12/9</h2>
<ul>
<li>[x] 解决上周六问题</li>
</ul>
<p>在V3通道上显示osd会造成  canvas_send_msg: idx larger than available block</p>
<p>解决如下，添加V3通道的配置</p>
<p><img alt="image-20241209163332374" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241209163332374.png" /></p>
<ul>
<li>[x] 定义日志存储格式  时间 + 指令，理论计算与格式定义</li>
</ul>
<pre><code class="language-json">//时间同步
[2024-11-20 20:20:10]{&quot;sync_tim&quot;:{&quot;now_tim&quot;: &quot;2024-11-20 20:20:10&quot;}}

//多段基础率
[2024-11-20 20:20:10]{ &quot;basal_rate&quot;:{&quot;basal_rate_num&quot;: &quot;1&quot;,&quot;speed&quot;:&quot;30&quot;,&quot;basal_rate_tim&quot;:&quot;00:00-12:00&quot;}}   
[2024-11-20 20:20:10]{ &quot;basal_rate&quot;:{&quot;basal_rate_num&quot;: &quot;2&quot;,&quot;speed&quot;:&quot;25&quot;,&quot;basal_rate_tim&quot;:&quot;12:00-12:05&quot;}}   
[2024-11-20 20:20:10]{ &quot;basal_rate&quot;:{&quot;basal_rate_num&quot;: &quot;3&quot;,&quot;speed&quot;:&quot;30&quot;,&quot;basal_rate_tim&quot;:&quot;12:05-12:10&quot;}}   
[2024-11-20 20:20:10]{ &quot;basal_rate&quot;:{&quot;basal_rate_num&quot;: &quot;4&quot;,&quot;speed&quot;:&quot;25&quot;,&quot;basal_rate_tim&quot;:&quot;12:10-23:59&quot;}}   
//常规大剂量
[2024-11-20 20:20:10]{&quot;normal_large_dose&quot;: {&quot;large_dose_liquid&quot;: &quot;9.5&quot;}}  
//方波大剂量
[2024-11-20 20:20:10]{&quot;square_wave_large_dose&quot;:{&quot;large_dose_liquid&quot;:&quot;10.5&quot;,&quot;tim_hh&quot;:&quot;02&quot;,&quot;tim_min&quot;:&quot;30&quot;}} 
//双波大剂量
[2024-11-20 20:20:10]{&quot;double_wave_large_dose&quot;:{&quot;all_liquid&quot;:&quot;60&quot;,&quot;proportion&quot;:&quot;50&quot;, &quot;tim_hh&quot;:&quot;1&quot;,&quot;tim_min&quot;:&quot;00&quot;}}

</code></pre>
<p>此外，增加还需扩展的日志信息如下</p>
<ul>
<li>连接时间</li>
</ul>
<pre><code class="language-json">[2024-11-20 20:20:10]{connect_tim:&quot;2024/12/12 20:32:20&quot;}
</code></pre>
<ul>
<li>断开连接时间</li>
</ul>
<pre><code class="language-json">[2024-11-20 20:20:10]{dis_connect_tim:&quot;2024/12/12 20:32:20&quot;}
</code></pre>
<p>预估1天日志存储量</p>
<p>首次使用，开机设置基础率，6段，每天设置6次大剂量，20次连接状态查看</p>
<p>1天总计存储容量为：</p>
<ul>
<li>开机的6段基础率日志，120字节*6  = 720字节</li>
<li>6次大剂量日志存储 120字节*6 = 720字节</li>
<li>48+22 次连接状态(连接+断开连接)  60字节 * 70 = 4200字节</li>
<li>70次时间同步 70字节*70 = 4900字节</li>
</ul>
<p><strong>一天的日志存储用量 = 10540字节   大小约11k</strong></p>
<p>200K的容量大约可以存储18天的历史记录</p>
<p>falsh擦写寿命计算</p>
<p>Flash的擦写寿命，一般在10000-100000 次擦写</p>
<p>每天擦写Flash的次数约 160次，按照上述，可正常运行天数在 62.5天 -  625天</p>
<p><strong>评估上述使用寿命较短</strong>，市场上胰岛素泵售后一般在五年左右，擦写Flash较为频繁会导致产品寿命变短</p>
<p><strong>时间同步指令会频繁写flash，去掉该日志，平均一天的擦写次数在82次左右</strong></p>
<p>10000-100000 次擦写 使用寿命在 122 - 1220天，使用寿命还是较短</p>
<p>按照5万次擦写寿命计算，产品质保为5年，则日志每天写的次数不得超过的 28</p>
<h2 id="20241210">2024/12/10</h2>
<p>计算DDR剩余使用情况</p>
<p><img alt="image-20241210110907080" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241210110907080.png" /></p>
<p><img alt="image-20241210110929079" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241210110929079.png" /></p>
<ul>
<li>可用DDR大小 61MB</li>
</ul>
<pre><code>.ddr.bss        0x0000000070347800   0x3c5b38
                0x0000000070347800                . = ALIGN (0x4)
                0x0000000070347800                __eram_bss_start__ = .


.ddr.text       0x000000007010f7e0    0xe5db8
                0x000000007010f7e0                . = ALIGN (0x4)
                0x000000007010f7e0                __eram_text_start__ = .

.ddr.data       0x00000000702df960    0x67ea0
                0x00000000702df960                . = ALIGN (0x4)
                0x00000000702df960                __eram_data_start__ = .   

.ddr.rodata     0x00000000701f6ba8    0xe8db8
                0x00000000701f6ba8                . = ALIGN (0x4)
                0x00000000701f6ba8                __eram_rodata_start__ = .   


 available heap 64895904    

64895904/1024/1024  = 61MB

</code></pre>
<ul>
<li>[x] DDR大小128MB , 剩余内存为 61 MB </li>
<li>[ ] 将视频缓存至ddr  15s 轮询   进行中……      实现较为困难</li>
<li>mm_module_ctrl函数底层使用静态库，无法查看底层实现，</li>
</ul>
<h2 id="20241211">2024/12/11</h2>
<ul>
<li>[x] 已实现音视频缓存至RAM 15s，</li>
</ul>
<p>设置视频每秒帧数为15fps  设置缓存15fps*15s，缓存至DDR成功，使用H264对视频进行了压缩，当前内存剩余量为55MB </p>
<h2 id="20241212">2024/12/12</h2>
<ul>
<li>[x] 保存MP4文件到SD卡，保存视频最长的时间为6min，超过该时间将自动切断，重新创建文件保存视频，</li>
</ul>
<p>保存的视频文件名格式为   年月日时分秒   如 20241212134520</p>
<p>SD卡写满时处理方法</p>
<ul>
<li>检查剩余空间是否满足下一次视频存储(按照最长的存储空间计算，可以多给一部分空间</li>
</ul>
<p>删除最老视频的方法</p>
<ul>
<li>系统启动时，在第一次录制视频时，将视频文件名存储到一个索引文件，在检测到要删除最老的视频时，查看索引文件，索引文件中存储着最老的文件，可以直接获得该文件名直接删除，删除之后查找当前最老文件附近最旧的文件，替换索引文件中的旧文件名称</li>
</ul>
<p><strong>优点</strong> 可以快速查找到最旧的文件直接删除，</p>
<p><strong>缺点</strong> 当停止录像后，有一个较长的时间间隔，此时查找最旧的文件非常耗时， 不适用</p>
<p>其他方式，每次写一个文件时，将文件名更新至索引，每次读取文件最开始的字节知晓删除的文件，更新索引中的文件直接删除前几个字节，此处的问题是，fatfs文件系统 不支持在文件中索引删除(不能删除指定数据)，</p>
<ul>
<li>[ ] 目前还没有想好合适的算法删除最老的视频，需要考虑到查找速度应该足够快，可以牺牲空间换时间</li>
</ul>
<h2 id="20241213">2024/12/13</h2>
<p>fatfs文件系统实现打印文件函数，打印的文件如下，可以看到文件打印是按照文件创建的先后顺序打印的，</p>
<pre><code>
File: 20241212134740.mp4, Size: 3315894 bytes

File: 20241212134810.mp4, Size: 2807223 bytes

File: 20241212134835.mp4, Size: 3645697 bytes

File: 20241212134914.mp4, Size: 1581912 bytes

File: 20241212134940.mp4, Size: 1475362 bytes

File: 20241212135020.mp4, Size: 2301132 bytes

File: 20241212135046.mp4, Size: 1578096 bytes

File: 20241212135057.mp4, Size: 8658189 bytes

File: 20241212135215.mp4, Size: 1720941 bytes

File: 20241212135253.mp4, Size: 9042486 bytes

File: 20241213090528.mp4, Size: 10116604 bytes

File: 20241213090646.mp4, Size: 4201491 bytes

File: 20241213090720.mp4, Size: 5265550 bytes

File: 20241213090805.mp4, Size: 3507007 bytes

File: 20241213090838.mp4, Size: 5272187 bytes
</code></pre>
<p>依据此特性实现直接删除旧文件</p>
<ul>
<li>存储即将不够时</li>
<li>遍历所有文件获得文件名</li>
<li>删除文件</li>
<li>获取剩余空间</li>
<li>剩余空间足够安全存储下一次的视频，跳出该函数</li>
</ul>
<p><img alt="image-20241213094122359" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213094122359.png" /></p>
<p><img alt="image-20241213094735989" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213094735989.png" /></p>
<p>实际测试下来，删除的文件似乎并不是按照删除最旧的删除，拔下sd卡查看文件情况，最旧的文件没有被删除，<strong>此方法不可行</strong></p>
<p><img alt="image-20241213095207823" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213095207823.png" /></p>
<p><strong>牺牲空间的方法构想</strong></p>
<p>由于ddr内存较大，剩余空间五十多MB, 在系统启动时候读取所有文件名保存在堆中(使用链表实现)，读取的文件时间为随机排序的，需要先将文件按照时间进行排序，删除旧文件时直接删除链表头，新增加的文件增加到链表尾</p>
<p><strong>优点：</strong>可快速删除旧文件</p>
<p><strong>缺点：</strong>消耗系统启动时间</p>
<p><strong>评估使用最大的堆：</strong></p>
<p>存储视频的时间为30s，一天创建文件7200个，预估一天使用存储大小为10G ，</p>
<p>64G的存储卡 可存储文件 46080</p>
<p>128G的存储卡 可存储文件 92160    一个节点的大小预计为 18+4+4 字节，结构体对齐后预计为28字节</p>
<p>92160*28 = 2580480字节 = 2520KB = 2.46M ,大小可接受，</p>
<p>突然想到该sdk包中有支持sqlite，直接利用sqlite存储文件名应该是个不错的选择，查看sqlite使用的是sd卡作为存储，</p>
<p>使用sqlite可以更加方便的添加与删除，更加稳定，使用此方案，可以更好管理文件，</p>
<p>在ubuntu系统上安装sqlite验证</p>
<pre><code>sudo apt-get update
sudo apt-get install sqlite3

//C/C++ 程序中使用 SQLite 的 C API
sudo apt-get install libsqlite3-dev

启动
sqlite3
</code></pre>
<p>创建一个文件信息表，一个字段存储时间，一个字段存储文件名，再向这个表中写入数据，时间的格式为xxxx-xx-xx xx:xx:xx   文件名字的格式为202412131212.mp  其中存储时xxxx-xx-xx xx:xx:xx对应文件时间，向表中写十个数据，时间由小到大</p>
<pre><code>-- 启动 SQLite 并连接到数据库文件
sqlite3 file_database.db


-- 创建表，包含 文件时间和文件名两个字段
CREATE TABLE IF NOT EXISTS file_info (
    file_time TEXT NOT NULL,
    filename TEXT NOT NULL
);

-- 向表中插入10条数据，每条记录的时间依次增加，以实现时间由小到大
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:01:00', '202412131201.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:02:00', '202412131202.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:03:00', '202412131203.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:04:00', '202412131204.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:05:00', '202412131205.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:06:00', '202412131206.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:07:00', '202412131207.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:08:00', '202412131208.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:09:00', '202412131209.mp');
INSERT INTO file_info (file_time, filename) VALUES ('2024-12-13 12:10:00', '202412131210.mp');

-- 查询验证结果
SELECT * FROM file_info ORDER BY file_time ASC;

-- 获取最新记录
SELECT * FROM file_info
ORDER BY file_time DESC
LIMIT 1;

-- 获取最老记录
SELECT * FROM file_info
ORDER BY file_time ASC
LIMIT 1;

-- 删除最老的记录
WITH oldest AS (
    SELECT filename FROM file_info
    ORDER BY file_time ASC
    LIMIT 1
)
DELETE FROM file_info
WHERE filename IN (SELECT filename FROM oldest);

-- 验证删除结果
SELECT * FROM file_info ORDER BY file_time ASC;

</code></pre>
<p><img alt="image-20241213113634956" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213113634956.png" /></p>
<p><img alt="image-20241213113854554" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213113854554.png" /></p>
<p>上述中可以看到这样是可行的，可以查询最老的字段并直接删除</p>
<p>测试使用sqlite的C语言的api来实现这一步骤</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlite3.h&gt;
#include &lt;string.h&gt;

// 数据库文件名
#define DATABASE_NAME &quot;file_database.db&quot;

// 回调函数用于打印查询结果
static int callback(void *NotUsed, int argc, char **argv, char **azColName){
    for(int i = 0; i &lt; argc; i++) {
        printf(&quot;%s = %s\t&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);
    }
    printf(&quot;\n&quot;);
    return 0;
}

// 函数声明
int drop_table(sqlite3 *db);
int create_table(sqlite3 *db);
int insert_data(sqlite3 *db);
int query_all_records(sqlite3 *db);
int get_latest_record(sqlite3 *db);
int get_oldest_record(sqlite3 *db);
int delete_oldest_record(sqlite3 *db);
int verify_deletion(sqlite3 *db);

int main(int argc, char* argv[]) {
    sqlite3 *db;
    int rc;

    // 打开连接到数据库文件（如果不存在，将创建一个新的）
    rc = sqlite3_open(DATABASE_NAME, &amp;db);
    if(rc){
        fprintf(stderr, &quot;无法打开数据库: %s\n&quot;, sqlite3_errmsg(db));
        return(0);
    } else {
        fprintf(stdout, &quot;成功打开数据库\n&quot;);
    }

    // 删除表（如果存在）
    if(drop_table(db) != SQLITE_OK){
        fprintf(stderr, &quot;删除表失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    // 创建表
    if(create_table(db) != SQLITE_OK){
        fprintf(stderr, &quot;创建表失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    // 插入数据
    if(insert_data(db) != SQLITE_OK){
        fprintf(stderr, &quot;插入数据失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    // 查询所有记录
    printf(&quot;\n所有记录（按时间升序排列）：\n&quot;);
    if(query_all_records(db) != SQLITE_OK){
        fprintf(stderr, &quot;查询所有记录失败\n&quot;);
    }

    // 获取最新记录
    printf(&quot;\n最新记录：\n&quot;);
    if(get_latest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;获取最新记录失败\n&quot;);
    }

    // 获取最老记录
    printf(&quot;\n最老记录：\n&quot;);
    if(get_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;获取最老记录失败\n&quot;);
    }

    // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;删除最老记录失败\n&quot;);
    } else {
        printf(&quot;\n已删除最老的记录。\n&quot;);
    }

    // 验证删除结果
    printf(&quot;\n删除后的记录（按时间升序排列）：\n&quot;);
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, &quot;验证删除结果失败\n&quot;);
    }

     // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;删除最老记录失败\n&quot;);
    } else {
        printf(&quot;\n已删除最老的记录。\n&quot;);
    }

    // 验证删除结果
    printf(&quot;\n删除后的记录（按时间升序排列）：\n&quot;);
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, &quot;验证删除结果失败\n&quot;);
    }

    // 关闭数据库连接
    sqlite3_close(db);
    return 0;
}

// 删除表的函数
int drop_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;DROP TABLE IF EXISTS file_info;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;删除表 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf(&quot;表 'file_info' 已删除（如果存在）。\n&quot;);
    return SQLITE_OK;
}

// 创建表的函数
int create_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        &quot;CREATE TABLE IF NOT EXISTS file_info (&quot;
        &quot;file_time TEXT NOT NULL, &quot;
        &quot;filename TEXT NOT NULL&quot;
        &quot;);&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;创建表 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf(&quot;表 'file_info' 已创建或已存在。\n&quot;);
    return SQLITE_OK;
}

// 插入数据的函数
int insert_data(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        &quot;INSERT INTO file_info (file_time, filename) VALUES &quot;
        &quot;('2024-12-13 12:01:00', '202412131201.mp'),&quot;
        &quot;('2024-12-13 12:02:00', '202412131202.mp'),&quot;
        &quot;('2024-12-13 12:03:00', '202412131203.mp'),&quot;
        &quot;('2024-12-13 12:04:00', '202412131204.mp'),&quot;
        &quot;('2024-12-13 12:05:00', '202412131205.mp'),&quot;
        &quot;('2024-12-13 12:06:00', '202412131206.mp'),&quot;
        &quot;('2024-12-13 12:07:00', '202412131207.mp'),&quot;
        &quot;('2024-12-13 12:08:00', '202412131208.mp'),&quot;
        &quot;('2024-12-13 12:09:00', '202412131209.mp'),&quot;
        &quot;('2024-12-13 12:10:00', '202412131210.mp');&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;插入数据 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf(&quot;成功插入10条记录。\n&quot;);
    return SQLITE_OK;
}

// 查询所有记录的函数
int query_all_records(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time ASC;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;查询所有记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最新记录的函数
int get_latest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time DESC LIMIT 1;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;获取最新记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最老记录的函数
int get_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time ASC LIMIT 1;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;获取最老记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 删除最老记录的函数
int delete_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        &quot;WITH oldest AS (&quot;
        &quot;    SELECT filename FROM file_info ORDER BY file_time ASC LIMIT 1&quot;
        &quot;) &quot;
        &quot;DELETE FROM file_info WHERE filename IN (SELECT filename FROM oldest);&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;删除最老记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 验证删除结果的函数
int verify_deletion(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time ASC;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;验证删除结果 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

</code></pre>
<pre><code>编译
gcc main.c -o main -lsqlite3

运行
./mian
</code></pre>
<p><img alt="image-20241213120004778" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241213120004778.png" /></p>
<p>上述实现可行，下一步将在amebapro中实现</p>
<ul>
<li>amebapor创建数据库并创建数据表(系统首次启动时创建，第二次启动只查看是否存在数据库)</li>
<li>视频开始录制时添加字段到数据表</li>
<li>视频将满的时候获取最老的记录删除</li>
</ul>
<h2 id="20241216">2024/12/16</h2>
<pre><code class="language-c">vfs_init(NULL);
vfs_user_register(&quot;sd&quot;, VFS_FATFS, VFS_INF_SD);
prv_set_interface_tag_in_sqlite_vfs(0);

int ret = sqlite_test();

if (ret == 0) {
printf(&quot;run sqlite test successfully [%d] \r\n&quot;, idx + 1);
pass_cnt++;
} else {
printf(&quot;run sqlite test fail [%d] \r\n&quot;, idx + 1);
}

//解初始化
vfs_user_unregister(&quot;sd&quot;, VFS_FATFS, VFS_INF_SD);
vfs_deinit(NULL);

static int sqlite_test(void)
{
    sqlite3_initialize();

    sqlite3 *db = NULL;
    char *zErrMsg = NULL;
    int rc;
    const char *sql;
    const char *data = &quot;Callback function called&quot;;
    const char *database_name = &quot;video_record.db&quot;;

    /* sqlite lib version */
    printf(&quot;SQLite version: %s \r\n&quot;, sqlite3_libversion());

    rc = sqlite3_open(database_name, &amp;db);
    if (rc) {
        printf(&quot;Can't open database: %s\r\n&quot;, sqlite3_errmsg(db));
        goto sqlite_close;
    } else {
        printf(&quot;Opened database successfully\r\n&quot;);
    }

    //创建表






}



</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlite3.h&gt;
#include &lt;string.h&gt;

// 数据库文件名
#define DATABASE_NAME &quot;file_database.db&quot;

// 回调函数用于打印查询结果
static int callback(void *NotUsed, int argc, char **argv, char **azColName){
    for(int i = 0; i &lt; argc; i++) {
        printf(&quot;%s = %s\t&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);
    }
    printf(&quot;\n&quot;);
    return 0;
}

// 函数声明
int drop_table(sqlite3 *db);
int create_table(sqlite3 *db);
int insert_data(sqlite3 *db, const char *file_time, const char *filename);
int query_all_records(sqlite3 *db);
int get_latest_record(sqlite3 *db);
int get_oldest_record(sqlite3 *db);
int delete_oldest_record(sqlite3 *db);
int verify_deletion(sqlite3 *db);


const char *timestamp1 = &quot;2024-12-13 12:01:00&quot;;
const char *filename1 = &quot;202412131201.mp&quot;;

const char *timestamp2 = &quot;2024-12-13 12:02:00&quot;;
const char *filename2 = &quot;202412131202.mp&quot;;

const char *timestamp3 = &quot;2024-12-13 12:03:00&quot;;
const char *filename3 = &quot;202412131203.mp&quot;;

const char *timestamp4 = &quot;2024-12-13 12:04:00&quot;;
const char *filename4 = &quot;202412131204.mp&quot;;


int main(int argc, char* argv[]) {
    sqlite3 *db;
    int rc;

    // 打开连接到数据库文件（如果不存在，将创建一个新的）
    rc = sqlite3_open(DATABASE_NAME, &amp;db);
    if(rc){
        fprintf(stderr, &quot;无法打开数据库: %s\n&quot;, sqlite3_errmsg(db));
        return(0);
    } else {
        fprintf(stdout, &quot;成功打开数据库\n&quot;);
    }

    // 删除表（如果存在）
    if(drop_table(db) != SQLITE_OK){
        fprintf(stderr, &quot;删除表失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    // 创建表
    if(create_table(db) != SQLITE_OK){
        fprintf(stderr, &quot;创建表失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    // 插入数据
    // if(insert_data(db) != SQLITE_OK){
    //     fprintf(stderr, &quot;插入数据失败\n&quot;);
    //     sqlite3_close(db);
    //     return 1;
    // }

    if (insert_data(db, timestamp1, filename1) != SQLITE_OK) {
        fprintf(stderr, &quot;插入数据失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    if (insert_data(db, timestamp2, filename2) != SQLITE_OK) {
        fprintf(stderr, &quot;插入数据失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    if (insert_data(db, timestamp3, filename3) != SQLITE_OK) {
        fprintf(stderr, &quot;插入数据失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

     if (insert_data(db, timestamp4, filename4) != SQLITE_OK) {
        fprintf(stderr, &quot;插入数据失败\n&quot;);
        sqlite3_close(db);
        return 1;
    }

    // 查询所有记录
    printf(&quot;\n所有记录（按时间升序排列）：\n&quot;);
    if(query_all_records(db) != SQLITE_OK){
        fprintf(stderr, &quot;查询所有记录失败\n&quot;);
    }

    // 获取最新记录
    printf(&quot;\n最新记录：\n&quot;);
    if(get_latest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;获取最新记录失败\n&quot;);
    }

    // 获取最老记录
    printf(&quot;\n最老记录：\n&quot;);
    if(get_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;获取最老记录失败\n&quot;);
    }

    // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;删除最老记录失败\n&quot;);
    } else {
        printf(&quot;\n已删除最老的记录。\n&quot;);
    }

    // 验证删除结果
    printf(&quot;\n删除后的记录（按时间升序排列）：\n&quot;);
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, &quot;验证删除结果失败\n&quot;);
    }

     // 删除最老记录
    if(delete_oldest_record(db) != SQLITE_OK){
        fprintf(stderr, &quot;删除最老记录失败\n&quot;);
    } else {
        printf(&quot;\n已删除最老的记录。\n&quot;);
    }

    // 验证删除结果
    printf(&quot;\n删除后的记录（按时间升序排列）：\n&quot;);
    if(verify_deletion(db) != SQLITE_OK){
        fprintf(stderr, &quot;验证删除结果失败\n&quot;);
    }

    // 关闭数据库连接
    sqlite3_close(db);
    return 0;
}

// 删除表的函数
int drop_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;DROP TABLE IF EXISTS file_info;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;删除表 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf(&quot;表 'file_info' 已删除（如果存在）。\n&quot;);
    return SQLITE_OK;
}

// 创建表的函数
int create_table(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        &quot;CREATE TABLE IF NOT EXISTS file_info (&quot;
        &quot;file_time TEXT NOT NULL, &quot;
        &quot;filename TEXT NOT NULL&quot;
        &quot;);&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;创建表 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    printf(&quot;表 'file_info' 已创建或已存在。\n&quot;);
    return SQLITE_OK;
}

// 插入数据的函数
// int insert_data(sqlite3 *db){
//     char *err_msg = 0;
//     const char *sql = 
//         &quot;INSERT INTO file_info (file_time, filename) VALUES &quot;
//         &quot;('2024-12-13 12:01:00', '202412131201.mp'),&quot;
//         &quot;('2024-12-13 12:02:00', '202412131202.mp'),&quot;
//         &quot;('2024-12-13 12:03:00', '202412131203.mp'),&quot;
//         &quot;('2024-12-13 12:04:00', '202412131204.mp'),&quot;
//         &quot;('2024-12-13 12:05:00', '202412131205.mp'),&quot;
//         &quot;('2024-12-13 12:06:00', '202412131206.mp'),&quot;
//         &quot;('2024-12-13 12:07:00', '202412131207.mp'),&quot;
//         &quot;('2024-12-13 12:08:00', '202412131208.mp'),&quot;
//         &quot;('2024-12-13 12:09:00', '202412131209.mp'),&quot;
//         &quot;('2024-12-13 12:10:00', '202412131210.mp');&quot;;

//     int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
//     if(rc != SQLITE_OK ){
//         fprintf(stderr, &quot;插入数据 SQL 错误: %s\n&quot;, err_msg);
//         sqlite3_free(err_msg);
//         return rc;
//     }

//     printf(&quot;成功插入10条记录。\n&quot;);
//     return SQLITE_OK;
// }


// 新的插入函数，传入要插入的 file_time 和 filename 参数
int insert_data(sqlite3 *db, const char *file_time, const char *filename) {
    sqlite3_stmt *stmt;
    const char *sql = &quot;INSERT INTO file_info (file_time, filename) VALUES (?, ?);&quot;;
    int rc;

    // 预编译 SQL 语句
    rc = sqlite3_prepare_v2(db, sql, -1, &amp;stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, &quot;预编译SQL失败: %s\n&quot;, sqlite3_errmsg(db));
        return rc;
    }

    // 绑定参数，将第1个问号绑定为 file_time，将第2个问号绑定为 filename
    sqlite3_bind_text(stmt, 1, file_time, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(stmt, 2, filename, -1, SQLITE_TRANSIENT);

    // 执行插入
    rc = sqlite3_step(stmt);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, &quot;插入数据失败: %s\n&quot;, sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return rc;
    }

    // 清理资源
    sqlite3_finalize(stmt);

    printf(&quot;成功插入记录: %s, %s\n&quot;, file_time, filename);
    return SQLITE_OK;
}


// 查询所有记录的函数
int query_all_records(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time ASC;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;查询所有记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最新记录的函数
int get_latest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time DESC LIMIT 1;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;获取最新记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 获取最老记录的函数
int get_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time ASC LIMIT 1;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;获取最老记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 删除最老记录的函数
int delete_oldest_record(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = 
        &quot;WITH oldest AS (&quot;
        &quot;    SELECT filename FROM file_info ORDER BY file_time ASC LIMIT 1&quot;
        &quot;) &quot;
        &quot;DELETE FROM file_info WHERE filename IN (SELECT filename FROM oldest);&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;删除最老记录 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

// 验证删除结果的函数
int verify_deletion(sqlite3 *db){
    char *err_msg = 0;
    const char *sql = &quot;SELECT * FROM file_info ORDER BY file_time ASC;&quot;;

    int rc = sqlite3_exec(db, sql, callback, 0, &amp;err_msg);
    if(rc != SQLITE_OK ){
        fprintf(stderr, &quot;验证删除结果 SQL 错误: %s\n&quot;, err_msg);
        sqlite3_free(err_msg);
        return rc;
    }

    return SQLITE_OK;
}

</code></pre>
<h2 id="20241216_1">2024/12/16</h2>
<ul>
<li>[x] 动态侦测触发时，将缓存在ddr中的历史录像10s,以及当前动态侦测录像，写入sd卡中保存，实际测试查看录像验证成功</li>
</ul>
<h2 id="20241217">2024/12/17</h2>
<ul>
<li>[x] 更新fatfs文件的创建时间与修改时间</li>
</ul>
<p>fatfs文件系统文件创建时间与文件修改时间无变化</p>
<p><img alt="image-20241217104608345" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241217104608345.png" /></p>
<p>文件系统的修改日期不一致，需要同步时间~</p>
<pre><code>FILINFO 结构体是FatFs库中用于存储或获取文件（或目录）信息的一个数据结构。其各字段含义如下：

FSIZE_t fsize：
文件大小（以字节为单位）。当获取文件信息时，这里存储该文件的长度。

WORD fdate：
文件的最后修改日期。日期的格式为FAT文件系统使用的内部格式：

复制代码
bit15:9   年 (从1980年起计数)
bit8:5    月 (1–12)
bit4:0    日 (1–31)
比如，如果fdate的值对应2024年12月17日，那会将(2024-1980)=44存入bit15:9中、12存入bit8:5中、17存入bit4:0中。

WORD ftime：
文件的最后修改时间。时间格式同样为FAT格式：

复制代码
bit15:11  时 (0–23)
bit10:5   分 (0–59)
bit4:0    秒 (以2秒为单位, 范围0–29)
比如，14:30:10（10秒应转换为2秒计数的5）则对应(14&lt;&lt;11) | (30&lt;&lt;5) | 5。
</code></pre>
<p>fatfs提供的接口函数更改如下</p>
<pre><code>需注意获取网络时间时需要先进行sntp的初始化，这里依赖的是网络时间，在断网的情况下应该使用rtc

DWORD get_fattime(void)
{
    DWORD time_abs;
    struct tm tim_now = sntp_gen_system_time_s(8 * 3600);

    time_abs = ((DWORD)(tim_now.tm_year - 1980) &lt;&lt; 25) /* Fixed to Feb. 2, 2016 */
               | ((DWORD)tim_now.tm_mon &lt;&lt; 21)
               | ((DWORD)tim_now.tm_mday &lt;&lt; 16)
               | ((DWORD)tim_now.tm_hour &lt;&lt; 11)
               | ((DWORD)tim_now.tm_min &lt;&lt; 5)
               | ((DWORD)tim_now.tm_sec &gt;&gt; 1);

    return time_abs;
}
</code></pre>
<p>更改后  创建文件时间与修改时间就正确了</p>
<p><img alt="image-20241217175111609" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241217175111609.png" /></p>
<h2 id="20241218">2024/12/18</h2>
<p>在application中使用sqlite3时需包源文件以及路径，直接使用sqlite3时会报错，需使用cmake配置sqlite中的一些宏定义</p>
<p>引入源码 application.cmake</p>
<pre><code>list(
    APPEND app_sources

    ${sdk_root}/component/application/sqlite/sqlite_port_8735b/ameba_sqlite_io_methods.c
    ${sdk_root}/component/application/sqlite/sqlite_port_8735b/ameba_sqlite_mutex.c
    ${sdk_root}/component/application/sqlite/sqlite_port_8735b/ameba_sqlite_vfs.c
    ${sdk_root}/component/application/sqlite/sqlite_3.40.0/sqlite3.c
)
</code></pre>
<p>引入头文件  includepath.cmake</p>
<pre><code>  &quot;${sdk_root}/component/application/sqlite/sqlite_3.40.0&quot;
  &quot;${sdk_root}/component/application/sqlite/sqlite_port_8735b&quot;
</code></pre>
<p>此时编译报错</p>
<pre><code>/home/hdj/amb82-mini-RTL8735B/sdk-ameba-v9.6b/component/application/sqlite/sqlite_3.40.0/sqlite3.c:36747:10: fatal error: sys/ioctl.h: No such file or directory
36747 | #include &lt;sys/ioctl.h&gt;
</code></pre>
<p>需要设置编译时的宏定义</p>
<pre><code>    CONFIG_BUILD_RAM=1 
    CONFIG_BUILD_LIB=1 
    CONFIG_PLATFORM_8735B
    CONFIG_RTL8735B_PLATFORM=1
    CONFIG_SYSTEM_TIME64=1

    # SQLITE configuration
    SQLITE_OMIT_LOAD_EXTENSION=1
    SQLITE_OMIT_WAL=1
    SQLITE_OMIT_AUTOINIT=1
    SQLITE_OMIT_SHARED_CACHE=1
    SQLITE_OMIT_DEPRECATED=1
    SQLITE_THREADSAFE=1
    NDEBUG
    # SQLITE_DEBUG
    SQLITE_OS_OTHER=1
    SQLITE_OS_FREERTOS=1
    SQLITE_MUTEX_FREERTOS=1
</code></pre>
<p><img alt="image-20241218105850685" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241218105850685.png" /></p>
<p>解释</p>
<pre><code>CONFIG_BUILD_RAM=1：表示构建时使用 RAM。
CONFIG_BUILD_LIB=1：表示构建库。
CONFIG_PLATFORM_8735B：指定平台为 RTL8735B。
SQLITE_OMIT_*：禁用 SQLite 的某些功能，如扩展加载、写时复制(WAL)、自动初始化、共享缓存和废弃的功能。这是为了减小 SQLite 的大小和提升性能。
SQLITE_THREADSAFE=1：启用线程安全功能。
SQLITE_OS_FREERTOS=1 和 SQLITE_MUTEX_FREERTOS=1：配置 SQLite 在 FreeRTOS 系统上的操作，支持 FreeRTOS 的互斥锁。
SQLITE_OS_OTHER=1：标明系统平台为其他类型。
</code></pre>
<p>配置上述后编译正常无报错</p>
<p>添加功能代码</p>
<ul>
<li>sqlite初始化</li>
<li>写文件时同时插入数据至数据库中</li>
<li>
<p>磁盘空间检测，空间检测，磁盘不够用时查找数据库中最老文件并删除，同时删除视频文件</p>
</li>
<li>
<p>实验进行前将sd卡做两个分区，第一个分区为100M, 软件上检测磁盘空间小于80M时删除最老文件，直至存储空间剩余80M为止</p>
</li>
</ul>
<h2 id="20241219">2024/12/19</h2>
<ul>
<li>[x] 利用数据库实现了快速删除最旧文件，保证存储空间即将满时有足够容量存储新文件</li>
</ul>
<p>已实现功能代码，对日志分析如下</p>
<pre><code>Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 14:54:18 filename = 20241219145418.mp4
file_time = 2024-12-19 14:54:29 filename = 20241219145429.mp4
file_time = 2024-12-19 14:54:50 filename = 20241219145450.mp4
file_time = 2024-12-19 14:55:11 filename = 20241219145511.mp4
file_time = 2024-12-19 14:55:35 filename = 20241219145535.mp4
file_time = 2024-12-19 14:56:03 filename = 20241219145603.mp4
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
STORAGE_STOP
video_len = 165 audio_len = 76 moov_len = 7838 total_size = 1297383
Record stop
STORAGE_STOP -&gt; STORAGE_IDLE
Record end
start recording 20241219145827
.....................................sd free spase is 79MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145418.mp4
成功删除文件: 20241219145418.mp4
要删除的最老记录的文件: 1219145418.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 80MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145429.mp4
成功删除文件: 20241219145429.mp4
要删除的最老记录的文件: 1219145429.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 81MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145450.mp4
成功删除文件: 20241219145450.mp4
要删除的最老记录的文件: (219145450.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 83MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145511.mp4
成功删除文件: 20241219145511.mp4
要删除的最老记录的文件: 1219145511.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 85MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145535.mp4
成功删除文件: 20241219145535.mp4
要删除的最老记录的文件: 1219145535.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 86MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219145603.mp4
成功删除文件: 20241219145603.mp4
要删除的最老记录的文件: 1219145603.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 90MB 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 
成功插入记录: 2024-12-19 14:58:27, 20241219145827.mp4
Start MP4 recording (1 files)
STORAGE_INIT
open file (0:/20241219145827.mp4) len = 305 seconds
STORAGE_INIT -&gt; STORAGE_START
[MD] FPS = 10.85
[MD] FPS = 11.34
no motion for 10 seconds
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
file_time = 2024-12-19 14:58:27 filename = 20241219145827.mp4
hal_voe_send2voe too long 38710 cmd 0x00000209 p1 0x00000001 p2 0x00000000
STORAGE_STOP
video_len = 216 audio_len = 100 moov_len = 9954 total_size = 1909397
Record stop
STORAGE_STOP -&gt; STORAGE_IDLE
Record end
[MD] FPS = 11.25
[MD] FPS = 11.25
start recording 20241219145903
.....................................sd free spase is 88MB 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 
成功插入记录: 2024-12-19 14:59:03, 20241219145903.mp4
Start MP4 recording (1 files)
STORAGE_INIT
</code></pre>
<p>未删除前文件</p>
<pre><code>file_time = 2024-12-19 14:54:18 filename = 20241219145418.mp4
file_time = 2024-12-19 14:54:29 filename = 20241219145429.mp4
file_time = 2024-12-19 14:54:50 filename = 20241219145450.mp4
file_time = 2024-12-19 14:55:11 filename = 20241219145511.mp4
file_time = 2024-12-19 14:55:35 filename = 20241219145535.mp4
file_time = 2024-12-19 14:56:03 filename = 20241219145603.mp4
file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
</code></pre>
<p>空间不足删除后文件</p>
<pre><code>file_time = 2024-12-19 14:56:32 filename = 20241219145632.mp4
file_time = 2024-12-19 14:56:54 filename = 20241219145654.mp4
file_time = 2024-12-19 14:57:23 filename = 20241219145723.mp4
file_time = 2024-12-19 14:58:09 filename = 20241219145809.mp4
file_time = 2024-12-19 14:58:27 filename = 20241219145827.mp4
</code></pre>
<p>上述日志可以看出，每次删除的都是最旧的文件，保留最新的文件</p>
<p>空间再次满时下一轮日志分析</p>
<pre><code>STORAGE_INIT -&gt; STORAGE_START
[MD] FPS = 11.22
no motion for 10 seconds
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 15:03:37 filename = 20241219150337.mp4
file_time = 2024-12-19 15:03:49 filename = 20241219150349.mp4
file_time = 2024-12-19 15:04:28 filename = 20241219150428.mp4
file_time = 2024-12-19 15:05:12 filename = 20241219150512.mp4
file_time = 2024-12-19 15:05:35 filename = 20241219150535.mp4
file_time = 2024-12-19 15:06:01 filename = 20241219150601.mp4
file_time = 2024-12-19 15:06:43 filename = 20241219150643.mp4
file_time = 2024-12-19 15:06:58 filename = 20241219150658.mp4
file_time = 2024-12-19 15:07:23 filename = 20241219150723.mp4
STORAGE_STOP
video_len = 188 audio_len = 86 moov_len = 8770 total_size = 1684272
Record stop
STORAGE_STOP -&gt; STORAGE_IDLE
Record end
[MD] FPS = 11.25
[MD] FPS = 11.34
start recording 20241219150748
.....................................sd free spase is 79MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150337.mp4
成功删除文件: 20241219150337.mp4
要删除的最老记录的文件: 1219150337.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 81MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150349.mp4
成功删除文件: 20241219150349.mp4
要删除的最老记录的文件: 1219150349.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 82MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150428.mp4
成功删除文件: 20241219150428.mp4
要删除的最老记录的文件: 1219150428.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 87MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150512.mp4
成功删除文件: 20241219150512.mp4
要删除的最老记录的文件: (219150512.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 88MB 
0:/file_database.db-journal, check 0x0
最老记录的 filename: 20241219150535.mp4
成功删除文件: 20241219150535.mp4
要删除的最老记录的文件: (219150535.mp4
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 

已删除最老的记录。
..while...................................sd free spase is 90MB 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_open] open file name: file_database.db-journal 
0:/file_database.db-journal, check 0x0
[_ameba_vfs_delete] delete file name: file_database.db-journal 
成功插入记录: 2024-12-19 15:07:48, 20241219150748.mp4
Start MP4 recording (1 files)
STORAGE_INIT
open file (0:/20241219150748.mp4) len = 305 seconds
STORAGE_INIT -&gt; STORAGE_START
[MD] FPS = 10.91
[MD] FPS = 11.25
[MD] FPS = 11.25
[MD] FPS = 11.25
no motion for 10 seconds
Stop MP4 recording
0:/file_database.db-journal, check 0x0
file_time = 2024-12-19 15:06:01 filename = 20241219150601.mp4
file_time = 2024-12-19 15:06:43 filename = 20241219150643.mp4
file_time = 2024-12-19 15:06:58 filename = 20241219150658.mp4
file_time = 2024-12-19 15:07:23 filename = 20241219150723.mp4
file_time = 2024-12-19 15:07:48 filename = 20241219150748.mp4
hal_voe_send2voe too long 38476 cmd 0x00000209 p1 0x00000001 p2 0x00000000
STORAGE_STOP
video_len = 860 audio_len = 398 moov_len = 36502 total_size = 7476366
Record stop
</code></pre>
<p>上述日志分析可再次确认删除的为最旧的数据</p>
<p>验证</p>
<ul>
<li>[x] 稳定性验证：<strong>磁盘分区为100M,磁盘不足80M时开始删除旧文件，直至剩余空间为90M</strong>，一直动态侦测。数小时后查看数据库中的数据是否与视频文件是否一致（确保是否存在漏删除的文件）<strong>安装Navicat查看数据库中的数据</strong></li>
</ul>
<p><strong>短时间验证（大概经过五次删除文件）</strong></p>
<p>查看sd卡中有6个视频文件，这时候数据库文件中也应该存储有这6个视频文件名字才对</p>
<p><img alt="image-20241219152441931" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241219152441931.png" /></p>
<ul>
<li><strong>验证结果一致</strong></li>
</ul>
<p><img alt="image-20241219152416738" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241219152416738.png" /></p>
<p><strong>长时间验证(经过两小时后验证15:30 - 17:30)</strong></p>
<ul>
<li>经过多轮的删除写入，验证结果一致</li>
</ul>
<p><img alt="image-20241219173258227" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241219173258227.png" /></p>
<ul>
<li>[ ] 大量存储验证： 磁盘分区为1G时进行验证，查看存储数据多时，删除时间是否会较长，造成系统卡死等问题，</li>
</ul>
<p>此测试应该屏蔽查看所有数据库数据  打印非常耗时，额外增加负担</p>
<h2 id="20241220">2024/12/20</h2>
<ul>
<li>[x] 昨日大量存储视频验证删除时间以及稳定性</li>
</ul>
<p>磁盘分区为1G时保存视频验证，此时查看数据库中保存有181条视频记录，sd卡中包括数据库文件保存有182个文件</p>
<p>测试使用数据库保存视频名称稳定</p>
<p><img alt="image-20241220110948716" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241220110948716.png" /></p>
<ul>
<li>
<p>目前存储的内容还是较少，扩大sd卡分区至20G继续测试，此时可以将sd卡中的内容拷贝一份，分区后拷贝进去，继续测试</p>
</li>
<li>
<p>[x] 将目前实现的功能移植到最新版本v9.6c上</p>
</li>
</ul>
<p>新增 cmos senser</p>
<pre><code>    {1920, 1080, 30}, //DUMMY
    {1920, 1080, 30}, //SC2336
    {1920, 1080, 30}, //GC2053
    {2560, 1440, 24}, //GC4653
    {1920, 1080, 30}, //F37
    {1920, 1080, 30}, //IMX327
    {1536, 1536, 30}, //F51
    {1920, 1080, 30}, //PS5258
    {2048, 1536, 20}, //SC301
    {1920, 1080, 30}, //IMX307
    {1920, 1080, 30}, //SC2333
    {2560, 1440, 24}, //GC4023
    {1952, 1944, 24}, //PS5420
    {1536, 1536, 30}, //PS5270
    {2592, 1944, 15}, //GC5035
    {1920, 1080, 30}, //PS5268
    {1920, 1080, 30}, //SC2310
    {1952, 1944, 24}, //PS5420_HDR
    {1536, 1536, 30}, //PS5270_HDR

    {1920, 1080, 30}, //SENSOR_F53
    {1920, 1080, 30}, //SENSOR_F55
    {2560, 1440, 24}, //SENSOR_GC4663
    {2560, 1440, 20}, //SENSOR_GC4663_HDR
    {2000, 2000, 24}, //SENSOR_K351
    {2000, 2000, 20}, //SENSOR_K351_HDR
    {2048, 1536, 30}, //SENSOR_OV50A40
    {2048, 1536, 20}, //SENSOR_SC301_HDR
</code></pre>
<ul>
<li>替换mmf2_video_example_md_mp4_init.c文件</li>
<li>包含sqlite的文件以及路径，宏定义配置</li>
<li>添加函数  void update_tim(char <em>file_name, FILINFO </em>fno);   至  fatfs_sdcard_api.c 并在  fatfs_sdcard_api.h声明</li>
<li>ffconfig.h中使能宏定义   #define FF_USE_CHMOD   1</li>
<li>main函数中添加 wps功能</li>
<li>设置摄像头senser</li>
</ul>
<p>log:</p>
<p>VOE]sensor power on
[VOE]i2c_master_err_callback ERR:8, tx_len: 2, rx_len: 0
[VOE]i2c tx abrt source: 1
[VOE]i2c txflr: 2
[VOE][sensor_start][837]Errsensor_start check sensor id err 
[VOE]sensor power off</p>
<ul>
<li>[ ] 提示senson id错误，明天检查代码</li>
</ul>
<p>linux上录制视频流</p>
<pre><code>sudo apt update
sudo apt install ffmpeg


ffmpeg -i rtsp://your_camera_ip/stream_path -c copy -f segment -segment_time 60 -strftime 1 &quot;%Y-%m-%d_%H-%M-%S.mp4&quot;

//开始录制
ffmpeg -i rtsp://192.168.8.15:554 -c copy -f segment -segment_time 60 -strftime 1 &quot;%Y-%m-%d_%H-%M-%S.mp4&quot;
//打印详细信息
ffmpeg -loglevel debug -i rtsp://192.168.8.15:554 -c copy -f segment -segment_time 60 -strftime 1 &quot;%Y-%m-%d_%H-%M-%S.mp4&quot;

</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>-i rtsp://your_camera_ip/stream_path</code>：指定 RTSP 流的地址。</li>
<li><code>-c copy</code>：复制流数据，而不是重新编码，保持原视频质量。</li>
<li><code>-f segment</code>：指定使用分段模式，将视频拆分为多个文件。</li>
<li><code>-segment_time 60</code>：每个视频段的时长为 60 秒（即 1 分钟）。</li>
<li><code>-strftime 1</code>：启用时间格式化，允许使用当前时间戳来命名文件。</li>
<li><code>"%Y-%m-%d_%H-%M-%S.mp4"</code>：输出文件的命名格式，按照年月日时分秒命名（例如：<code>2024-12-20_14-30-00.mp4</code>）。</li>
</ul>
<p>上述录制只有音频没有视频</p>
<p>ffmpeg -i rtsp://192.168.8.15:554 -c:v libx264 -c:a aac -f segment -segment_time 60 -strftime 1 "%Y-%m-%d_%H-%M-%S.mp4"</p>
<p>ubuntu软件包下载失败</p>
<p>阿里云镜像站或其他站下载 Ubuntu 软件包时遇到 DNS 解析问题。这通常是由于系统无法解析域名 <code>mirrors.aliyun.com</code>。</p>
<p>更换 DNS 服务器</p>
<pre><code>sudo vim /etc/resolv.conf
</code></pre>
<p>在文件中添加以下内容，使用 Google 的 DNS   </p>
<pre><code>nameserver 8.8.8.8
nameserver 8.8.4.4
</code></pre>
<h2 id="20241221">2024/12/21</h2>
<ul>
<li>
<p>[x] 将sdk-v9.6b版本实现的功能代码移植到sdk-v9.6c 完成并测试通过</p>
</li>
<li>
<p>[ ] 了解到Mdns网络协议，可优化串流连接方式，串流的流程如下</p>
</li>
<li>
<p>打开vlc，输入ip以及端口，由于是DHCP,IP是动态的，当网络环境发生变化时需要知道设备的ip，使用mDNS可将用户名替换为ip</p>
</li>
</ul>
<p><strong>mDNS</strong> 的全称是 <strong>Multicast DNS</strong>（多播 DNS），它是一种在局域网（LAN）内使用多播进行 DNS 查询和解析的协议。mDNS 使得设备能够在没有传统 DNS 服务器的情况下，通过主机名解析获取 IP 地址，并支持在局域网内进行设备发现和服务发现</p>
<p>在传统的 DNS 中，设备通过查询一个公共或私有的 DNS 服务器来解析域名（如 <code>example.com</code>）到 IP 地址。这种方式依赖于中心化的 DNS 服务器，并且需要配置 DNS 服务器及其记录。而在一个 <strong>无中心化 DNS 服务器</strong> 的局域网环境中（例如家庭网络或小型办公室），设备也需要能够通过主机名（如 <code>printer.local</code> 或 <code>mydevice.local</code>）进行相互发现。</p>
<p><strong>mDNS</strong> 的出现就是为了解决在没有 DNS 服务器的情况下，设备如何在局域网内实现自动发现和解析。</p>
<p>应用示例：</p>
<ul>
<li>
<p>群晖的Synology Assistant</p>
</li>
<li>
<p>共享文件samba服务也用到了mDNS</p>
</li>
<li>开发板，ssh登录 直接用名称登录也是开启了mDNS</li>
</ul>
<p><img alt="image-20241221165014277" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241221165014277.png" /></p>
<p><img alt="image-20241221164956831" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241221164956831.png" /></p>
<p><img alt="MobaXterm ssh登录" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/hostname-11.png" /></p>
<h2 id="20241223">2024/12/23</h2>
<p>监控存储方案：</p>
<ul>
<li>本地TF卡存储</li>
<li>局域网下存储（NVR方案）</li>
<li>云盘存储（对接云盘存储）</li>
</ul>
<p><strong>网络视频录像机（NVR）</strong></p>
<ul>
<li><strong>特点</strong>：专为IP摄像头设计，支持多路视频输入，内置视频管理软件，便于配置和管理。</li>
<li><strong>适用场景</strong>：中小型监控系统，安装简便，易于扩展。</li>
</ul>
<p><strong>网络视频录像机（NVR）的工作方式确实涉及视频流的接收</strong>。具体来说，NVR负责从网络中的IP摄像头接收实时视频流，并将这些视频流进行记录和管理。以下是对NVR与视频流接收之间关系的详细解释：</p>
<p><strong>NVR与视频流的关系</strong></p>
<ol>
<li><strong>视频流接收</strong></li>
<li><strong>IP摄像头输出视频流</strong>：IP摄像头通过网络（通常是以太网）将实时视频数据以流的形式传输出来，常见的协议包括RTSP（实时流协议）、RTMP等。</li>
<li><strong>NVR接收视频流</strong>：NVR作为中心设备，负责接收来自各个IP摄像头的视频流。这些视频流通过局域网传输到NVR，NVR对其进行解码、处理和存储。</li>
<li><strong>集中管理</strong></li>
<li><strong>统一平台</strong>：NVR提供一个集中管理的平台，用户可以通过NVR的界面查看、回放和管理所有接收到的视频流。</li>
<li>
<p><strong>实时监控与录制</strong>：除了接收视频流，NVR还可以进行实时监控和定时录制，根据预设的录像计划自动存储视频数据。</p>
</li>
<li>
<p>[x] 此方案使用NVR方案，需要与第三方的NVR录像机对接，</p>
</li>
</ol>
<p><strong>配网方式</strong></p>
<p>Wi-Fi 配网</p>
<ul>
<li>WPS（Wi-Fi Protected Setup）</li>
<li>AP 模式（Access Point Mode）</li>
</ul>
<p>蓝牙配网</p>
<ul>
<li>蓝牙传输ssid password配网</li>
</ul>
<p>这里使用AP配网方案</p>
<p>配网大致流程如下</p>
<p><img alt="image-20241223143923129" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223143923129.png" /></p>
<p>上述需要实现的基本功能</p>
<ul>
<li>
<p>[ ] 系统第一次启动时，使用内置的ssid   password, 并写入flash保存</p>
</li>
<li>
<p>[ ] 蓝牙配网的实现（开机连接到wifi失败时，打开蓝牙广播，与手机建立连接后，手机发送wifi配置信息）</p>
</li>
<li>
<p>[ ] 重置按键 长按清除flash中的ssid信息并进行软件复位</p>
</li>
<li>
<p>[ ] wifi连接状态指示灯，未连接wifi时指示灯熄灭，连接上wifi时指示灯闪烁</p>
</li>
</ul>
<p>蓝牙配网可下载 <strong>Easy WiFi Config</strong>    应用商店搜索即可， iso与安卓都可下载</p>
<p><img alt="image-20241223145140169" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223145140169.png" /></p>
<p><img alt="image-20241223145213761" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223145213761.png" /></p>
<p><img alt="image-20241223145238839" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223145238839.png" /></p>
<p>系统开启蓝牙配网</p>
<p>Start BT Config     <strong>ATBB=1</strong>      </p>
<p>Stop BT Config     <strong>ATBB=0</strong> </p>
<p>ATBB=0 </p>
<p>AT命令配置  蓝牙配网文件  atcmd_bt.c</p>
<p>开启蓝牙配网函数</p>
<pre><code>bt_config_app_init();
set_bt_cmd_type(CONFIG_BIT | STACK_BIT);
</code></pre>
<p>关闭蓝牙配网函数</p>
<pre><code>bt_config_app_deinit();     //关闭蓝牙配网
set_bt_cmd_type(0);
</code></pre>
<p><img alt="image-20241223152133735" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241223152133735.png" /></p>
<ul>
<li>WIFI连接状态使用LED2来表示，未连接状态该LED常亮，连接状态该LED熄灭，此开发板不支持用户按键</li>
</ul>
<p>lwip获取网络连接状态方法</p>
<pre><code>https://blog.csdn.net/qq_42820594/article/details/126197207
</code></pre>
<pre><code>if (netif_is_link_up(&amp;gnetif))
{
    BSP_LED_Off(LED2);
}
else
{
    BSP_LED_On(LED2);
}
</code></pre>
<h2 id="20241224">2024/12/24</h2>
<ul>
<li>[x] 实现LED显示网络连接状态，闪烁网络连接上，未闪烁网络未连接</li>
</ul>
<p>配网方式使用两种，wps和蓝牙配网，实际测试时，两者不能同时存在，开启wps的同时，蓝牙将连接不上</p>
<p>更改应用逻辑如下</p>
<ul>
<li>[x] 未连接到wifi时默认开启蓝牙配网，当长按某个按键时，开启wps配网，此时蓝牙配网将失效</li>
</ul>
<p>由于此开发板没有用户按键可以使用了，自定义一个io, 外接高电平时判断为按键按下，已完成wps按键配网</p>
<p><strong>WPS key</strong></p>
<ul>
<li>使用PF15作为 WPS按键，</li>
</ul>
<p><img alt="image-20241224110452539" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241224110452539.png" /></p>
<p><img alt="image-20241224110801847" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241224110801847.png" /></p>
<p>实验过程</p>
<p>1.使用细针头注入</p>
<p>2.拔掉针头直接使用输液管注入</p>
<p>3.手动使用100ml针管，人工抽药，注入</p>
<p>结论与实验发现</p>
<ul>
<li>
<p><strong>使用细针头会限制流速，此种方式最慢</strong></p>
</li>
<li>
<p>直接使用输液管注入，此种方式较前一种快，<strong>但由于容器未预留出气口，压强逐渐变大</strong>，流速逐渐降低</p>
</li>
</ul>
<p><strong>170ml---&gt;130ml  用时2min 30s</strong></p>
<ul>
<li><strong>使用100ml针管手推时，速度最快</strong>，抽药与输注两轮，共计200ml,用时 1min 45s，由于使用针管较粗，操作过程会漏液</li>
</ul>
<p>综合考虑，两种方案选择</p>
<p><strong>1.开大容器孔，选用较粗的管增加流速，需预留排气孔</strong></p>
<p><strong>2.使用人工抽药输注</strong></p>
<h2 id="20241225">2024/12/25</h2>
<p>对比sdk v9.6b和sdkv9.6c 的io引脚</p>
<p>针对客户原理图部分，我们根据我们sdk整理出以下不同的GPIO功能引脚：</p>
<pre><code>45 - gpioF_0 -adc0
56 - GPIOF_10 - JTAG_TMS
57 - GPIOF_11 - JTAG_TRST
58 - GPIOF_12 - I2S_rx
59 - GPIOF_13 - I2S_sclk
68 - GPIOA_2 - COMP_ADC
69 - GPIOA_3 - COMP_ADC
70 - GPIOA_0 - COMP_ADC
71 - GPIOA_1 - COMP_ADC
</code></pre>
<ul>
<li>软件上无法体现一些io的功能，sdk未定义,找到以下io</li>
</ul>
<pre><code class="language-c">i2s
#define I2S_SCLK_PIN            PF_13
#define I2S_WS_PIN              PF_15
#define I2S_TX_PIN              PF_14
#define I2S_RX_PIN              PF_12
#define I2S_MCK_PIN             PF_11

adc
#define MBED_ADC_EXAMPLE_PIN_0    PF_0
#define MBED_ADC_EXAMPLE_PIN_1    PF_1
#define MBED_ADC_EXAMPLE_PIN_2    PF_2
#define MBED_ADC_EXAMPLE_PIN_3    PF_3   //log uart
</code></pre>
<ul>
<li>
<p>[x] 蓝牙配网功能测试成功，应用逻辑已完成，</p>
</li>
<li>
<p>[ ] 目前发现串流时vlc掉帧，较卡，可能是该开发板未接天线的原因，信号不好，网络跟不上</p>
</li>
<li>
<p>[ ] 串流发现一个通道 缓存溢出？ </p>
</li>
</ul>
<p><img alt="" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241225175633914.png" /></p>
<h2 id="20241226">2024/12/26</h2>
<ul>
<li>[x] 昨日出现问题，串流时掉帧，与类似缓存溢出问题实际测试都是开发板没有天线造成的（用一根金属棒与天线接口接触这一现象就会解决）</li>
</ul>
<p><img alt="" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241225175633914.png" /></p>
<ul>
<li>[x] 更改保存的视频格式为MJPEG，mjpeg格式的可裁切为图片作为视频证据</li>
<li>[ ] 网络连接上时，当关闭wifi,20s内会自动扫描该网络建立连接，超过此时间不会继续扫描网络，这是系统库函数中实现，此逻辑需要更改，应该一直扫描连接</li>
</ul>
<h2 id="20241227">2024/12/27</h2>
<p>ATW0=iPhone</p>
<p>ATW1=1234567890..</p>
<p>ATWC</p>
<ul>
<li>[x] 添加WPS配网指示灯</li>
</ul>
<p>目前配网功能都已经完成，与王总沟通确定接下来的实现方向</p>
<ul>
<li>[ ] 远程语音播放，实现类似语音对讲的功能</li>
<li>[ ] 软件控制</li>
<li>[ ] 局域网保存视频，串流 or 存储同步</li>
</ul>
<p>语音传输并通过喇叭播放”通常包含以下几个关键环节：</p>
<p><strong>1.手机端</strong>音频采集、编码</p>
<p><strong>2.网络传输</strong>（手机到摄像头）</p>
<p><strong>3.摄像头端</strong>音频解码、播放</p>
<p><strong>1.手机端：如何采集并发送音频？</strong></p>
<p><strong>1.1 音频采集</strong></p>
<ul>
<li>手机麦克风</li>
<li>在 Android 或 iOS 系统上，都可以通过官方的音频录制 API（<code>AudioRecord</code>、<code>AVAudioEngine</code> 等）来获取麦克风输入。</li>
<li>获取到的是 PCM 数据（未经压缩）。</li>
<li>一般以<strong>单声道</strong>、<strong>16bit</strong>、<strong>8kHz/16kHz</strong>等参数为主，以减少数据量并满足通话/监控场景的音质要求。</li>
</ul>
<p><strong>1.2 音频编码</strong></p>
<ul>
<li>为了减小网络带宽占用、降低延迟，通常需要<strong>先对 PCM 进行压缩</strong>再传输。</li>
<li>常见的语音编码格式：</li>
<li><strong>G.711 (uLaw/aLaw)</strong>：简单、延迟低，但码率较高（64kbps）。</li>
<li><strong>G.726</strong>：能在 16~32kbps 间选择，常见于监控/对讲。</li>
<li><strong>AAC</strong> / <strong>OPUS</strong>：音质更好、压缩率更高，但实现稍复杂。</li>
<li>在手机端如果使用厂商 SDK，可能内部就集成了编码模块。如果自行实现，可移植常见的开源库（如 WebRTC 中的编解码组件、或者 FFmpeg 等）来编码。</li>
</ul>
<p><strong>1.3 发送到摄像头</strong></p>
<ul>
<li>建立连接</li>
</ul>
<p>手机要与摄像头通过网络（Wi-Fi/4G/局域网等）建立通信。</p>
<ul>
<li>有的场景下手机和摄像头同处于同一个局域网，可能直接通过 RTSP/RTMP/WebSocket/TCP 等方式访问摄像头 IP 或者使用摄像头提供的私有协议端口。</li>
<li>
<p>更多时候，摄像头在家中、手机在外网，需要<strong>P2P</strong>或<strong>云服务器转发</strong>来穿透 NAT。很多家用摄像头厂商都会提供自己的一套 P2P/云平台 SDK，用于建立双向音频/视频通道。</p>
</li>
<li>
<p>流媒体/协议封装</p>
</li>
<li>
<p>如果摄像头支持 <strong>双向 RTP</strong> 通道（比如 RTSP 中反向音频流），手机可将编码后的音频打包成 RTP，向摄像头发送；</p>
</li>
<li>
<p>如果使用厂商私有 SDK，那么就把编码后的音频帧通过 SDK 的“对讲接口”发送给云端或摄像头。SDK 会自动封装并传给摄像头。</p>
</li>
<li>
<p>推送方式</p>
</li>
<li>
<p>常见做法是<strong>“边采集、边编码、边发送”</strong>，保证实时性；</p>
</li>
<li>手机 App 通常会有“按住说话”或“对讲”按钮，一旦按下，就开始采集-编码-发送音频数据给摄像头；松开则结束发送。</li>
</ul>
<p><img alt="image-20241227162602198" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241227162602198.png" /></p>
<p>先实现本地的音频解码播放，目前提供的demo是针对音频插孔的程序，该开发板不带放大功放芯片</p>
<p>测试i2s sdk包中使用的io为，该芯片找不到此io，</p>
<pre><code>#define I2S_SCLK_PIN    PC_1
#define I2S_WS_PIN      PC_0
#define I2S_SD_PIN      PC_2
</code></pre>
<p>替换io  如下测试，示波器测量没有信号产生</p>
<pre><code>#define I2S_SCLK_PIN    PD_14
#define I2S_WS_PIN      PD_17
#define I2S_SD_PIN      PD_15
</code></pre>
<h2 id="20241230">2024/12/30</h2>
<p>ameba 跳线测试VP10的音频播放电路ok，</p>
<p><img alt="image-20241230112040366" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241230112040366.png" /></p>
<h2 id="202512">2025/1/2</h2>
<ul>
<li>[x] 实现咪头采集音频信号通过喇叭播放</li>
<li>[ ] 调节音量大小未实现</li>
</ul>
<h2 id="202513">2025/1/3</h2>
<ul>
<li>[ ] 调节音量大小还未实现，调节 数字麦克风增益无反应</li>
</ul>
<h2 id="202514">2025/1/4</h2>
<p>测试新光宝全的网关，能分配ip，开机前几秒能ping通，但之后ping不通，无wifi，</p>
<p>单独测试摄像机可以通过WPS连接到我们的网关，IP 地址分配成功，但是查看摄像需要新光宝全的app,app需要网关认证</p>
<h2 id="202516">2025/1/6</h2>
<p>使用ffmpeg将音频MP3文件转换成 aac文件与wav文件</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>MP3</th>
<th>AAC</th>
<th>WAV</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>压缩方式</strong></td>
<td>有损压缩</td>
<td>有损压缩</td>
<td>无损</td>
</tr>
<tr>
<td><strong>音质</strong></td>
<td>较低（低比特率时音质损失明显）</td>
<td>优于 MP3（在相同比特率下）</td>
<td>无损，无任何音质损失</td>
</tr>
<tr>
<td><strong>文件大小</strong></td>
<td>小（高压缩率）</td>
<td>更小（比 MP3 高效）</td>
<td>大（无压缩或少量压缩）</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>极其广泛，几乎所有设备和播放器支持</td>
<td>支持主流设备和软件，但不如 MP3 广泛</td>
<td>广泛支持，但设备不如 MP3 和 AAC 多</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>音乐存储、流媒体、便携设备</td>
<td>流媒体、苹果设备、音频压缩</td>
<td>专业音频编辑、录音和高质量音频存储</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>MP3</strong>：适用于需要较小文件大小、广泛兼容性且音质要求不高的场景。</li>
<li><strong>AAC</strong>：适用于对音质有较高要求、同时还需要高压缩比的场景，尤其是流媒体。</li>
<li><strong>WAV</strong>：适用于需要保存最高音质、无损音频的专业音频存储和编辑场景。</li>
</ul>
<p>需要高音质且文件较小，建议使用 <strong>AAC</strong>；对音质要求非常高且不在乎文件大小，可以选择 <strong>WAV</strong>；需要广泛的兼容性且文件大小适中，MP3 依然是一个常见的选择。</p>
<p>linux下安装ffmpeg，转换成采样率为16khz的 aac文件</p>
<pre><code>ffmpeg -i test_audio.mp3 -ar 16000 -c:a aac -b:a 128k output_audio.aac
</code></pre>
<p>转换成采样率为16khz的wav文件</p>
<pre><code>ffmpeg -i test_audio_mp3.mp3 -ar 16000 output_audio.wav
</code></pre>
<p>转码后的文件进行串流，这里使用的是转换后的wav文件</p>
<p><img alt="image-20250106171034981" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171034981.png" /></p>
<p><img alt="image-20250106171200289" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171200289.png" /></p>
<p><img alt="image-20250106171215851" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171215851.png" /></p>
<p><img alt="image-20250106171355135" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106171355135.png" /></p>
<p><img alt="image-20250106172235235" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172235235.png" /></p>
<p><img alt="image-20250106172526824" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172526824.png" /></p>
<p><img alt="image-20250106172539638" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172539638.png" /></p>
<p><img alt="image-20250106172641277" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250106172641277.png" /></p>
<p>此处已经开始串流了，但是播放的声音一直是噪声，尝试其他格式的文件也是噪声，确定转换后的采样率一致，</p>
<p>尝试下载网络上其他16khz转换率的音乐，串流一样是噪声，目前怀疑是软件上的设定导致的错误，</p>
<p>当前软件实现现较为困难，开发周期可能较长</p>
<h2 id="202517">2025/1/7</h2>
<p>更改功放电路部分</p>
<p><img alt="image-20250107104515858" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250107104515858.png" /></p>
<ul>
<li>将输入直接接在C1上，audio-pw的R3断开，拉高</li>
</ul>
<p>module_audio.c文件中可以调整喇叭的音量以及咪头的增益，将喇叭的音量调整为最大，当咪头的增益调整较大时会出现较大回声，将喇叭的音量调整最小时，增加一点咪头的增益也会出现回声，目前要增加音量就必须要增加咪头的增益，需要解决回声的问题</p>
<p><strong>搜索解决方案如下</strong></p>
<ol>
<li>
<p><strong>物理设计优化</strong></p>
</li>
<li>
<p>距离与隔离</p>
</li>
<li>增加麦克风和喇叭之间的物理距离，减少直接声传播。</li>
<li>使用声学屏蔽材料（例如吸音材料）来隔离咪头和喇叭。</li>
<li>方向性调整</li>
<li>选择指向性麦克风，并调整其拾音方向远离喇叭。</li>
<li>使用定向扬声器，使声音主要集中在特定区域，避免进入麦克风拾音区域。</li>
</ol>
<hr />
<ol>
<li><strong>信号处理方法</strong></li>
</ol>
<p>(1) 回声消除 (AEC, Acoustic Echo Cancellation)</p>
<ul>
<li>使用数字信号处理（DSP）技术，通过算法在麦克风信号中识别喇叭发出的声音并实时消除。</li>
<li>常用的AEC技术包括：</li>
<li>自适应滤波器（Adaptive Filtering）：动态估计回声路径，抵消回声。</li>
<li>时域和频域回声消除：分析音频信号在不同域中的特征来消除回声。</li>
</ul>
<p>(2) 自动增益控制 (AGC, Automatic Gain Control)</p>
<ul>
<li>动态调节麦克风的增益，降低输入音量以减少喇叭声音被拾取的概率。</li>
</ul>
<p>(3) 降噪与滤波</p>
<ul>
<li>应用高通滤波器（High-pass filter）和低通滤波器（Low-pass filter）来过滤特定频段的声音，从而抑制回声。</li>
<li>使用噪声门限（Noise Gate）技术，设置一个音量阈值，低于该阈值的信号被忽略。</li>
</ul>
<hr />
<ol>
<li>
<p><strong>音频流程控制</strong></p>
</li>
<li>
<p>全双工切换为半双工：</p>
</li>
<li>如果场景允许，可以采用半双工通信模式（即同一时间只能收音或播放），从根本上避免回声问题。</li>
<li>回声路径延迟处理：</li>
<li>通过精确控制音频链路中的延迟，避免回声循环的产生。</li>
<li>动态音量调整：</li>
<li>当系统检测到麦克风活动时，可以暂时降低喇叭音量。</li>
</ol>
<hr />
<ol>
<li>
<p><strong>软硬件结合方案</strong></p>
</li>
<li>
<p>麦克风阵列（Microphone Array）：</p>
</li>
<li>采用多麦克风阵列，通过波束形成（Beamforming）技术增强特定方向的声音，减少喇叭方向的声音拾取。</li>
<li>专用回声消除芯片：</li>
<li>使用内置AEC的音频处理芯片（例如Cirrus Logic、Texas Instruments或Synaptics的产品），硬件实现回声消除。</li>
<li>软件算法：</li>
<li>如果系统中有处理能力，可以集成开源的回声消除算法，如WebRTC的AEC模块。</li>
</ol>
<h2 id="202518">2025/1/8</h2>
<p><img alt="image-20250108093307894" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108093307894.png" /></p>
<p><img alt="image-20250108093331937" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108093331937.png" /></p>
<p>开发手册中 回声和嚎叫  解释到，</p>
<ul>
<li>发送端和接收端的设备距离太近</li>
<li>音量太大或麦克风太敏感</li>
<li>AEC未打开</li>
<li>AEC参数设置不正确</li>
</ul>
<p>目前产生回声和嚎叫的情况为 AEC参数未打开，麦克风太敏感了</p>
<p>开启AEC,最终测试咪头的增益为AUDIO_MIC_20DB时，.ADC_gain = 0x4A时，此时麦克风的音量较大且距离较远时没有回声。</p>
<pre><code class="language-c">.mic_gain           = AUDIO_MIC_20DB,    //咪头增益   0db 20db 30db 40db
.dmic_l_gain        = DMIC_BOOST_36DB,  //左声道喇叭音量   0db 12db 24db 36db
.dmic_r_gain        = DMIC_BOOST_36DB,  //右声道喇叭音量   0db 12db 24db 36db
</code></pre>
<pre><code class="language-c">//ADC_gain: set the dgain for mic path. Support -17.625dB (0x00) ~ 30dB (0x7F)
.ADC_gain      = 0x4A,   //ADC path Dgain about 20dB 
</code></pre>
<p>查找spi屏幕的驱动芯片手册并下载查看驱动源码</p>
<p><img alt="image-20250108175227971" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108175227971.png" /></p>
<p><img alt="image-20250108175311424" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250108175311424.png" /></p>
<h2 id="202519">2025/1/9</h2>
<ul>
<li>移植st7789v spi lcd 驱动</li>
</ul>
<p>确定spi的控制io </p>
<pre><code class="language-C">sclk ---&gt; PE1
miso ---&gt; PE2
mosi ---&gt; PE3
cs   ---&gt; PE4

RST  ---&gt; PD17
RS   ---&gt; PD18
</code></pre>
<ul>
<li>[x] 移植ST 7789v 的驱动至 RTL 8735完成 ,编译通过，当前没有硬件测试环境，不确定驱动是否需要更改</li>
</ul>
<h2 id="2025110">2025/1/10</h2>
<p>连接PIN</p>
<p><img alt="9a053000f82c996937cd0c28991dc64" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/9a053000f82c996937cd0c28991dc64.jpg" /></p>
<p><img alt="image-20250110133929975" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250110133929975.png" /></p>
<p><img alt="image-20250110133957861" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250110133957861.png" /></p>
<p><img alt="image-20250110155546636" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250110155546636.png" /></p>
<p>软件接口</p>
<pre><code>RS
CS
SCL  时钟线
SDA  数据线
RES  复位线

sclk ---&gt; PE1     15
miso ---&gt; PE2     14
cs   ---&gt; GND     12

RST  ---&gt; PD17     17
RS   ---&gt; PD18     16
</code></pre>
<ul>
<li>当前驱动测试未能成功刷写屏幕，使用屏幕厂家的 命令与数据配置，还是未能成功</li>
</ul>
<p>先使用 STM32F103C8 原测试代码，测试屏幕是否可以正常刷新，确保能在F103C8跑起来再移植过去</p>
<h2 id="2025113">2025/1/13</h2>
<p>实现st7789 lcd 软件模式spi 驱动,成功显示，但需调整为横屏</p>
<p>调整命令与 下列相关，当前还未调试出</p>
<pre><code>LCD_WR_REG(0x36);

LCD_WR_REG(0x2A);

LCD_WR_REG(0x2B);
</code></pre>
<h2 id="2025114">2025/1/14</h2>
<p>更改屏幕io接线</p>
<pre><code>sclk ---&gt; PF6     1    // scl
mosi ---&gt; PF7     2    // sda
cs   ---&gt; GND         // 片选直接拉地

RST  ---&gt; PD17    17    // 复位
RS   ---&gt; PD18    16      // cmd/data
</code></pre>
<ul>
<li>[x] 实现硬件spi驱动  频率10MHZ     初始化spi时选择 mode 3模式   点不亮与 极性与相位相关</li>
</ul>
<h2 id="2025116">2025/1/16</h2>
<ul>
<li>[ ] 移植lvgl编译通过但系统卡死，  </li>
<li>修改camek文件    添加源文件   ，设置lvgl心跳，设置缓冲区，填写lvgl接口函数</li>
</ul>
<h2 id="2025117">2025/1/17</h2>
<ul>
<li>[x] 解决卡死问题，为定义缓冲区存在错误已改正</li>
</ul>
<p><code>c
      LV_ATTRIBUTE_MEM_ALIGN
      static uint8_t buf_1_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];            /*A buffer for 10 rows*/
      lv_display_set_buffers(disp, buf_1_1, NULL, sizeof(buf_1_1), LV_DISPLAY_RENDER_MODE_PARTIAL);</code></p>
<ul>
<li>烧录程序运行，但是提示LVGL无心跳, 当前的心跳函数是加入systick中断中的</li>
</ul>
<pre><code class="language-C">[Warn]  (0.000, +0)      lv_timer_handler: It seems lv_tick_inc() is not called. lv_timer.c:89
</code></pre>
<ul>
<li>将心跳函数加入其他中断</li>
</ul>
<p>使用软件定时器TIMER2  做1ms 中断，将LVGL心跳加入 该中断，io翻转 示波器测量查看中断1ms准确</p>
<ul>
<li>[ ] 目前lvgl可以运行，但是屏幕的刷写存在问题，造成显示与颜色不正常，怀疑还是驱动配置的问题，</li>
</ul>
<p>明天使用stm32开发板验证驱动，当前的开发板烧写测试要两三分钟，</p>
<h2 id="2025118">2025/1/18</h2>
<p>当前使用的硬件spi的帧率较低，18帧用时3s 左右    使用DMA的方式来渲染图像，</p>
<p>目前使用dma的发送函数就会造成系统卡死，原因未找到</p>
<h2 id="2025120">2025/1/20</h2>
<ul>
<li>[x] 实现 硬件spi+dma </li>
</ul>
<p>当前测试20帧的时间为 796ms      1s 约 25帧    使用全图填充  </p>
<p><img alt="image-20250120175313625" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20250120175313625.png" /></p>
<ul>
<li>实际测试发现，最后一帧存在不显示的情况，（前20帧全图刷新，最后一帧使用非dma的方式画圆与显示字符）</li>
</ul>
<h2 id="2025121">2025/1/21</h2>
<ul>
<li>spi 硬件dma发现颜色错误，更改填充函数LCD_Fill</li>
</ul>
<pre><code>uint16_t swap_color = (color &gt;&gt; 8) | (color &lt;&lt; 8);  
</code></pre>
<pre><code class="language-c">void LCD_Fill(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)
{          
    u16 i,j; 
    LCD_Address_Set(xsta,ysta,xend-1,yend-1);//设置显示范围
    uint16_t swap_color = (color &gt;&gt; 8) | (color &lt;&lt; 8);  

     for(i = 0 ; i &lt; DMA_SPI_BUF_SIZE; i++)
    {
        Spi2DmaBuffer[i] = swap_color; 
    }

    for(i = 0; i &lt; 16/*(SCREEN_SIZE/DMA_SPI_BUF_SIZE)*/; i++)
    {
        TrDone = 0;      
        spi_master_write_stream_dma(&amp;spi_master, Spi2DmaBuffer, DMA_SPI_BUF_SIZE);
        while (TrDone == 0) {
        }
    }
    vTaskDelay(2000);
}
</code></pre>
<ul>
<li>lvgl 使用双缓冲</li>
</ul>
<pre><code class="language-c">LV_ATTRIBUTE_MEM_ALIGN     static uint8_t buf_2_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];      LV_ATTRIBUTE_MEM_ALIGN     static uint8_t buf_2_2[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];     lv_display_set_buffers(disp, buf_2_1, buf_2_2, sizeof(buf_2_1), LV_DISPLAY_RENDER_MODE_PARTIAL);
</code></pre>
<ul>
<li>lvgl 接口更改 当前使用画点函数</li>
</ul>
<pre><code class="language-c">static void disp_flush(lv_display_t * disp_drv, const lv_area_t * area, uint8_t * px_map)
{
    if(disp_flush_enabled) {
        /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/
        int32_t x;
        int32_t y;
        for(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) {
            for(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) {
                /*Put a pixel to the display. For example:*/
                /*put_px(x, y, *px_map)*/

                uint16_t color = (px_map[1] &lt;&lt; 8) | px_map[0]; 

                LCD_DrawPoint(x, y, color);

                px_map+=2;
            }
        }
    }

    /*IMPORTANT!!!
     *Inform the graphics library that you are ready with the flushing*/
    lv_display_flush_ready(disp_drv);
}
</code></pre>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul>
<li><a href="#2024129">2024/12/9</a></li>
<li><a href="#20241210">2024/12/10</a></li>
<li><a href="#20241211">2024/12/11</a></li>
<li><a href="#20241212">2024/12/12</a></li>
<li><a href="#20241213">2024/12/13</a></li>
<li><a href="#20241216">2024/12/16</a></li>
<li><a href="#20241216_1">2024/12/16</a></li>
<li><a href="#20241217">2024/12/17</a></li>
<li><a href="#20241218">2024/12/18</a></li>
<li><a href="#20241219">2024/12/19</a></li>
<li><a href="#20241220">2024/12/20</a></li>
<li><a href="#20241221">2024/12/21</a></li>
<li><a href="#20241223">2024/12/23</a></li>
<li><a href="#20241224">2024/12/24</a></li>
<li><a href="#20241225">2024/12/25</a></li>
<li><a href="#20241226">2024/12/26</a></li>
<li><a href="#20241227">2024/12/27</a></li>
<li><a href="#20241230">2024/12/30</a></li>
<li><a href="#202512">2025/1/2</a></li>
<li><a href="#202513">2025/1/3</a></li>
<li><a href="#202514">2025/1/4</a></li>
<li><a href="#202516">2025/1/6</a></li>
<li><a href="#202517">2025/1/7</a></li>
<li><a href="#202518">2025/1/8</a></li>
<li><a href="#202519">2025/1/9</a></li>
<li><a href="#2025110">2025/1/10</a></li>
<li><a href="#2025113">2025/1/13</a></li>
<li><a href="#2025114">2025/1/14</a></li>
<li><a href="#2025116">2025/1/16</a></li>
<li><a href="#2025117">2025/1/17</a></li>
<li><a href="#2025118">2025/1/18</a></li>
<li><a href="#2025120">2025/1/20</a></li>
<li><a href="#2025121">2025/1/21</a></li>
</ul>
</div>

</div>
</body>
</html>

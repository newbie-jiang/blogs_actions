
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>按键唤醒</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <pre><code>/*
 * INCLUDE FILES
 ****************************************************************************************
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;gap_api.h&quot;
#include &quot;gatt_api.h&quot;

#include &quot;os_timer.h&quot;
#include &quot;os_mem.h&quot;
#include &quot;sys_utils.h&quot;
#include &quot;button.h&quot;
#include &quot;jump_table.h&quot;

#include &quot;user_task.h&quot;

#include &quot;driver_plf.h&quot;
#include &quot;driver_system.h&quot;
#include &quot;driver_i2s.h&quot;
#include &quot;driver_pmu.h&quot;
#include &quot;driver_uart.h&quot;
#include &quot;driver_rtc.h&quot;
#include &quot;driver_flash.h&quot;
#include &quot;driver_efuse.h&quot;
#include &quot;flash_usage_config.h&quot;
#include &quot;driver_gpio.h&quot;
#include &quot;ble_simple_peripheral.h&quot;
#include &quot;simple_gatt_service.h&quot;

/*
 * LOCAL VARIABLES
 */

const struct jump_table_version_t _jump_table_version __attribute__((section(&quot;jump_table_3&quot;))) = 
{
    .firmware_version = 0x00000000,
};

const struct jump_table_image_t _jump_table_image __attribute__((section(&quot;jump_table_1&quot;))) =
{
    .image_type = IMAGE_TYPE_APP,
    .image_size = 0x19000,      
};


__attribute__((section(&quot;ram_code&quot;))) void pmu_gpio_isr_ram(void)
{
    uint32_t gpio_value = ool_read32(PMU_REG_GPIOA_V);

    button_toggle_detected(gpio_value);
    ool_write32(PMU_REG_PORTA_LAST, gpio_value);
}

/*********************************************************************
 * @fn      user_custom_parameters
 *
 * @brief   initialize several parameters, this function will be called 
 *          at the beginning of the program. 
 *
 * @param   None. 
 *       
 *
 * @return  None.
 */
void user_custom_parameters(void)
{
    struct chip_unique_id_t id_data;

    efuse_get_chip_unique_id(&amp;id_data);
    __jump_table.addr.addr[0] = 0xBD;
    __jump_table.addr.addr[1] = 0xAD;
    __jump_table.addr.addr[2] = 0xD0;
    __jump_table.addr.addr[3] = 0xF0;
    __jump_table.addr.addr[4] = 0x17;
    __jump_table.addr.addr[5] = 0x20;

    id_data.unique_id[5] |= 0xc0; // random addr-&gt;static addr type:the top two bit must be 1.
    memcpy(__jump_table.addr.addr,id_data.unique_id,6);
    __jump_table.system_clk = SYSTEM_SYS_CLK_48M;
    jump_table_set_static_keys_store_offset(JUMP_TABLE_STATIC_KEY_OFFSET);
    ble_set_addr_type(BLE_ADDR_TYPE_PUBLIC);
    retry_handshake();
}

/*********************************************************************
 * @fn      user_entry_before_sleep_imp
 *
 * @brief   Before system goes to sleep mode, user_entry_before_sleep_imp()
 *          will be called, MCU peripherals can be configured properly before 
 *          system goes to sleep, for example, some MCU peripherals need to be
 *          used during the system is in sleep mode. 
 *
 * @param   None. 
 *       
 *
 * @return  None.
 */
__attribute__((section(&quot;ram_code&quot;))) void user_entry_before_sleep_imp(void)
{
    uart_putc_noint_no_wait(UART1, 's');
}

/*********************************************************************
 * @fn      user_entry_after_sleep_imp
 *
 * @brief   After system wakes up from sleep mode, user_entry_after_sleep_imp()
 *          will be called, MCU peripherals need to be initialized again, 
 *          this can be done in user_entry_after_sleep_imp(). MCU peripherals
 *          status will not be kept during the sleep. 
 *
 * @param   None. 
 *       
 *
 * @return  None.
 */
__attribute__((section(&quot;ram_code&quot;))) void user_entry_after_sleep_imp(void)
{
    /* set PA2 and PA3 for AT command interface */
    //system_set_port_pull(GPIO_PA2, true);
    //system_set_port_mux(GPIO_PORT_A, GPIO_BIT_2, PORTA2_FUNC_UART1_RXD);
    system_set_port_mux(GPIO_PORT_A, GPIO_BIT_3, PORTA3_FUNC_UART1_TXD);

    uart_init(UART1, BAUD_RATE_115200);
    //NVIC_EnableIRQ(UART1_IRQn);
    uart_putc_noint_no_wait(UART1, 'w');
    // Do some things here, can be uart print
    system_sleep_disable();     //disable sleep 

    NVIC_EnableIRQ(PMU_IRQn);
}

/*********************************************************************
 * @fn      user_entry_before_ble_init
 *
 * @brief   Code to be executed before BLE stack to be initialized.
 *          Power mode configurations, PMU part driver interrupt enable, MCU 
 *          peripherals init, etc. 
 *
 * @param   None. 
 *       
 *
 * @return  None.
 */
void user_entry_before_ble_init(void)
{    
    /* set system power supply in BUCK mode */
    pmu_set_sys_power_mode(PMU_SYS_POW_BUCK);
#ifdef FLASH_PROTECT
    flash_protect_enable(1);
#endif
    pmu_enable_irq(PMU_ISR_BIT_ACOK
                   | PMU_ISR_BIT_ACOFF
                   | PMU_ISR_BIT_ONKEY_PO
                   | PMU_ISR_BIT_OTP
                   | PMU_ISR_BIT_LVD
                   | PMU_ISR_BIT_BAT
                   | PMU_ISR_BIT_ONKEY_HIGH);
    NVIC_EnableIRQ(PMU_IRQn);

    // Enable UART print.
    //system_set_port_pull(GPIO_PA2, true);
    //system_set_port_mux(GPIO_PORT_A, GPIO_BIT_2, PORTA2_FUNC_UART1_RXD);
    system_set_port_mux(GPIO_PORT_A, GPIO_BIT_3, PORTA3_FUNC_UART1_TXD);
    uart_init(UART1, BAUD_RATE_115200);   


    pmu_set_led2_value(1);  
}

/*********************************************************************
 * @fn      user_entry_after_ble_init
 *
 * @brief   Main entrancy of user application. This function is called after BLE stack
 *          is initialized, and all the application code will be executed from here.
 *          In that case, application layer initializtion can be startd here. 
 *
 * @param   None. 
 *       
 *
 * @return  None.
 */
void user_entry_after_ble_init(void)
{
    co_printf(&quot;BLE Peripheral\r\n&quot;);

#if 0
    system_sleep_disable();     //disable sleep 
#else
    if(__jump_table.system_option &amp; SYSTEM_OPTION_SLEEP_ENABLE)  //if sleep is enalbed, delay 3s for JLINK 
    {
        co_printf(&quot;\r\na&quot;);
        co_delay_100us(10000);       
        co_printf(&quot;\r\nb&quot;);
        co_delay_100us(10000);
        co_printf(&quot;\r\nc&quot;);
        co_delay_100us(10000);
        co_printf(&quot;\r\nd&quot;);
    }
#endif

    // User task initialization, for buttons.
    //user_task_init();

    // Application layer initialization, can included bond manager init, 
    // advertising parameters init, scanning parameter init, GATT service adding, etc.    
    //simple_peripheral_init();

    system_set_port_pull((GPIO_PD7 | GPIO_PD6), true);
    //PD7  PD6输入
    system_set_port_mux(GPIO_PORT_D, GPIO_BIT_7, PORTD7_FUNC_D7 );
    system_set_port_mux(GPIO_PORT_D, GPIO_BIT_6, PORTD6_FUNC_D6 );
    gpio_set_dir(GPIO_PORT_D, GPIO_BIT_7, GPIO_DIR_IN);      
    gpio_set_dir(GPIO_PORT_D, GPIO_BIT_6, GPIO_DIR_IN);   

    //PD5 PD4 PC5输出
    system_set_port_mux(GPIO_PORT_D, GPIO_BIT_4, PORTD4_FUNC_D4 );
    system_set_port_mux(GPIO_PORT_D, GPIO_BIT_5, PORTD5_FUNC_D5 );
    system_set_port_mux(GPIO_PORT_C, GPIO_BIT_5, PORTC5_FUNC_C5 );
    gpio_set_dir(GPIO_PORT_D, GPIO_BIT_4, GPIO_DIR_OUT);                
    gpio_set_dir(GPIO_PORT_D, GPIO_BIT_5, GPIO_DIR_OUT);                
    gpio_set_dir(GPIO_PORT_C, GPIO_BIT_5, GPIO_DIR_OUT);


    gpio_set_pin_value(GPIO_PORT_D, GPIO_BIT_5, 0);
    gpio_set_pin_value(GPIO_PORT_D, GPIO_BIT_4, 0);
    gpio_set_pin_value(GPIO_PORT_C, GPIO_BIT_5, 0);

    pmu_set_pin_pull(GPIO_PORT_D, (1&lt;&lt;GPIO_BIT_6)|(1&lt;&lt;GPIO_BIT_7), false);
    pmu_port_wakeup_func_set(GPIO_PD6);
    pmu_port_wakeup_func_set(GPIO_PD7);


//    pmu_port_wakeup_func_set(GPIO_PD6|GPIO_PD7);


//    pmu_set_pin_pull(GPIO_PORT_D, (1&lt;&lt;GPIO_BIT_4)|(1&lt;&lt;GPIO_BIT_5), true);
//    pmu_port_wakeup_func_set(GPIO_PD4|GPIO_PD5);
}

</code></pre>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul></ul>
</div>

</div>
</body>
</html>

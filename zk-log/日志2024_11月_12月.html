
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>日志2024_11月_12月</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h2 id="_1">日志</h2>
<p>2024/11/7</p>
<ul>
<li>
<p>[x] RTL8735B 调整视频流与音频流，将视频流H264与音频流合并，通过RTSP串流到VLC一个通道，</p>
</li>
<li>
<p>[x] 在VLC软件中,调整缓存时间为10ms(降低缓存时间会降低延迟)，我的电脑测试传输最大延迟范围在700ms左右，李经理笔记本测试延迟在500ms左右，两者不一致可能与网卡有关</p>
</li>
<li>
<p>[ ] 原分辨率为1920 * 1080 30fps 更改为 640 * 480 30fps  未实现，更改参数无效，打印报错缓存不够？由于使用静态库封装，无法查找到打印信息，错误信息如下</p>
</li>
</ul>
<p>[VID Wrn]VOE CH0 ENC queue full (queue/used/out/rsvd) 0/0KB2085KB37KB</p>
<p>表示编码器的队列已满，编码器的缓冲队列空间已用尽，无法接收新的数据</p>
<p>2024/11/11</p>
<ul>
<li>[x]  JPEG + H264双通道串流实现</li>
<li>[ ] 动态检测demo测试ok ，<strong>h264串流ok 且可以完成动态检测，jpeg串流失败</strong></li>
<li>[ ] osd (on screen display) 测试sntp获取网络时间ok，串流显示到屏幕还未实现</li>
</ul>
<p>OSD实现思路：</p>
<ul>
<li>监控设备的处理器<strong>周期性读取时间</strong>（每秒更新一次）。</li>
<li>然后使用<strong>图形叠加</strong>（Graphics Overlay）将时间信息渲染到视频画面上。在视频帧生成或编码之前进行时间叠加，以便时间成为视频画面的一部分。</li>
<li>监控系统会在每一帧的顶部区域生成一个文本图层，显示时间戳。</li>
<li>生成的时间戳信息可以直接叠加到每一帧图像中，通过软件算法，将时间文本绘制在帧的左上角。</li>
<li>一旦时间叠加完成，视频帧就会进入编码阶段，生成 H.264或 MJPEG 等格式，并通过 RTSP 协议输出。</li>
<li><strong>OSD 叠加的时间信息成为视频帧的一部分</strong>，因此最终的流媒体中已经包含了左上角的时间显示。</li>
</ul>
<h2 id="20241112">2024/11/12</h2>
<ul>
<li>[x] RTL8735  OSD（on screen display）实现</li>
</ul>
<p><img alt="480483da2a6ef854dd6508580518605" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/480483da2a6ef854dd6508580518605.png" /></p>
<ul>
<li>[x] 富芮坤 ADC io确定 <strong>PD6</strong>，在富芮坤demo板改变电压采集adc值验证ok</li>
</ul>
<p><img alt="image-20241112180004968" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241112180004968.png" /></p>
<h2 id="20241113">2024/11/13</h2>
<ul>
<li>[x] 多圈旋转电位器 AD检测， 数据小幅抖动，使用   <strong>中值滤波</strong>，6个窗口值    实际检测效果理想</li>
</ul>
<p><img alt="image-20241113170135263" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241113170135263.png" /></p>
<ul>
<li>[x] 检测电机是否阻塞完成</li>
<li>实现原理：（线性状态：电机转动时ad值减小） 五个缓冲区存储历史数据，<strong>最新数据</strong> 与 <strong>最旧数据</strong>作比较，最新数值无变化或比原来的值大则判定发生阻塞，下一次来数据时，数据左移再次判断</li>
</ul>
<p><img alt="image-20241113170248154" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241113170248154.png" /></p>
<h2 id="20241115">2024/11/15</h2>
<ul>
<li>[x] 完成电机阻塞报警</li>
<li>[x] 完成低电量报警</li>
<li>
<p>[x] 完成输注完成报警（无药量时）</p>
</li>
<li>
<p>[ ] 完成电池待机时长理论计算(睡眠时间：1分钟      唤醒时间：500毫秒  电池遵循IEC标准，可运行15天</p>
</li>
</ul>
<p>，还未定下来实际速度，需结合速度再次计算理论值并实际测试，测试按照30mA/h电流消耗，预计需花费一整天</p>
<ul>
<li>[x] 输注速度匹配实验</li>
</ul>
<p>参数：</p>
<ul>
<li>胰岛素泵 管内壁直径为3mm,</li>
<li>胰岛素泵的速度为 0.5u - 30u / h    (1u = 0.01ml = 10ul )</li>
<li>电机齿轮转一圈的长度为18mm</li>
</ul>
<p>齿轮转动一周走的体积为 = 1.5 x 1.5 x 3.14 x 18mm = 0.12723ml =  12.72u  </p>
<p>## 实验1：</p>
<p>停止2s，运动50ms    运动一圈用时1min 16s </p>
<p>运动一圈步数为   76 / 2.05 =  37步   </p>
<p>一步的量    12.72 / 37 =  0.344u / 步    </p>
<p>按照0.5u-30u /h 对应的步数为  0.5u</p>
<p>0.5 - 30u        0.5/0.334 = 2步     30/0.334 = 90步  </p>
<p>实验结论：按照0.5u /h 时，精度较差</p>
<p>## 实验2：</p>
<p>停止1s 运动10ms,运动一圈用时5min 53 s  = 353s   </p>
<p>运动一圈步数为 353 /  1.01 = 349.5 步</p>
<p>一步的量  12.72u / 349.5 = 0.0363 U</p>
<p>按照0.5u-30u /h  对应步数为 0.5/0.0363 =  13.8 步   ---    30/0.0363 = 826步</p>
<p>按照最大量计算1h 需要运动 826步 平均 4s 走一步，对功耗要求较大，该实验的运动时间不可靠</p>
<p>实验结论：按照30u /h时，唤醒频繁，功耗较大</p>
<p><strong>上述两个实验，实验1 运行50ms 步数偏大，实验2运行10ms步数偏小，理想的数据在 一次运动30ms左右</strong></p>
<p>## 实验3：</p>
<p>停止1s 运动30ms，运动一圈用时1min  7s = 67s</p>
<p>运动一圈的步数为 67/1.03 = 65步</p>
<p>一步的量 12.72 / 65 = 0.1957u</p>
<p>按照   0.5u-30u /h  对应步数为 0.5/0.1957 =  2.5 步   ---    30/0.1957 = 153.3步</p>
<p>按照最小计算量  1h 走2.5步    按照最大计算量1h走153步，23.5 s走一步</p>
<p>当前情况下不能精准做到0.5U/h,对于最大剂量很少用到，为保证准确度，继续降低时间，</p>
<p>## 实验4：</p>
<p>停止1s，运动20ms，运动一圈用时  2min</p>
<p>运动一圈的步数为120/1.02 = 117步</p>
<p>一步的量 12.72 / 117 = 0.1087U</p>
<p>按照   0.5u-30u /h  对应步数为 0.5/0.1087 =  5 步   ---    30/0.1087 = 276 步</p>
<p>按照 最小基础率的速度为 20min 一次    按照最大基础率的速率为13s   一次</p>
<p>当前参数下，基础率对应电机关系</p>
<p>0.5 U         20min/次</p>
<p>1 U            10min/次</p>
<p>2u              5 min/次</p>
<p><strong>实际测试下，运动20ms一步适合当下情况</strong></p>
<ul>
<li>[x] CR2450 纽扣电池电压变化曲线理论分析：</li>
</ul>
<p><img alt="a440fc135fd48c90eb765b0090b97c8" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/a440fc135fd48c90eb765b0090b97c8.png" /></p>
<p>负载在7.5k时，此时电流在0.4mA,  电压在3.3V - 3.0V 下降很快，之后在 3.0V- 2.8V 趋于稳定，</p>
<p>实际测试：使用过程带负载的情况下，</p>
<p><strong>实验5</strong></p>
<p>电压3v时测试，停止1s，运动20ms，运动一圈用时  2min</p>
<p>电压2.8v时测试，停止1s，运动20ms，运动一圈用时  2min 15s</p>
<p>实际测试：电压在降低时，电机的转速会降低，   <strong>检测电压降低时，使用补偿的方式对电机速度进</strong>行补偿**</p>
<p>移植cjson: </p>
<ul>
<li>[x] 为方便数据的统一管理，蓝牙使用cjson格式数据进行收发，移植已完成，基础测试通过</li>
</ul>
<p><img alt="" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241118180535173.png" /></p>
<p>定义cjson格式数据，还未完全定义好（初步实现）</p>
<p><strong>运行状态（发送）</strong></p>
<pre><code class="language-c">{
   &quot;running&quot;:
   {
    &quot;states&quot;:&quot;run&quot;              // &quot;run&quot;  
    &quot;remainder drug&quot;:&quot;xx.x&quot;     // 剩余药量 xx.x 整数部分两位数，小数部分一位数
    &quot;have finished drug&quot;:&quot;xx.x&quot; // 已入药量 xx.x 整数部分两位数，小数部分一位数
    &quot;basal rate&quot;:&quot;basal rate 1&quot; // 基础率1  / 基础率2  / 基础率3 
   }
}
</code></pre>
<p><strong>停止状态（发送）</strong></p>
<pre><code class="language-c">{
   &quot;stop&quot;:
   {
    &quot;states&quot;:&quot;stop&quot;             // &quot;stop&quot;
    &quot;remainder drug&quot;:&quot;xx.x&quot;     // 剩余药量 xx.x 整数部分两位数，小数部分一位数
    &quot;have finished drug&quot;:&quot;xx.x&quot; // 已入药量 xx.x 整数部分两位数，小数部分一位数
    &quot;basal rate&quot;:&quot;basal rate 1&quot; // 基础率1  / 基础率2  / 基础率3 
    &quot;history infusion&quot;:
    {
      &quot;01&quot;:&quot;xx.x&quot;
      &quot;02&quot;:&quot;xx.x&quot;
      &quot;03&quot;:&quot;xx.x&quot;
      &quot;04&quot;:&quot;xx.x&quot;
      &quot;05&quot;:&quot;xx.x&quot;
    }
   }
}
</code></pre>
<h2 id="20241119">2024//11/19</h2>
<p><strong>接收数据：</strong></p>
<ul>
<li>[x] 蓝牙接收数据解析实现部分（数据存储方式为结构体，使用时访问结构体成员）</li>
</ul>
<pre><code> typedef struct basal_rate_information{

    char  basal_rate_num; //基础率段数
    float basal_rate_speed;//基础率速度 扩大十倍

    char basal_rate_start_tim_hh;  //起始时间hh
    char basal_rate_start_tim_min; //起始时间min

    char basal_rate_end_tim_hh;    //结束时间hh
    char basal_rate_end_tim_min;   //结束时间min

}basal_rate_information;


//同步时间
 typedef struct sync_tim{
     char sync_tim_hh;
     char sync_tim_min;
     char sync_tim_s;
}sync_tim;


//大剂量设定
typedef struct large_dose{
    float large_dose_liquid; //大剂量液量
    float large_dose_speed;  //大剂量速度
}large_dose_information;
</code></pre>
<p><strong>基础率指令</strong></p>
<pre><code class="language-json">{
  &quot;basal_rate&quot;: {
    &quot;basal_rate_num&quot;: &quot;2&quot;, //第几段基础率
    &quot;speed&quot;: &quot;8.5&quot;,        //基础率速度
    &quot;basal_rate_tim&quot;: &quot;01:03:28-20:30:30&quot; //当前段的基础率  起始时间 - 结束时间
  }
}   

测试指令
{
  &quot;basal_rate&quot;: {
    &quot;basal_rate_num&quot;: &quot;1&quot;,
    &quot;speed&quot;: &quot;8.5&quot;,        
    &quot;basal_rate_tim&quot;: &quot;00:00:00-20:30:00&quot;
  }
}   
</code></pre>
<p><strong>时间同步指令</strong></p>
<pre><code class="language-json">{
  &quot;sync_tim&quot;: {      
    &quot;now_tim&quot;: &quot;12:20:30&quot;   //当前同步时间
  }
}  

测试指令
{
  &quot;sync_tim&quot;: {      
    &quot;now_tim&quot;: &quot;12:20:30&quot;
  }
}  
</code></pre>
<p><strong>大剂量指令</strong></p>
<pre><code class="language-json">  {
   &quot;large_dose&quot;: 
   {      
     &quot;large_dose_liquid&quot;: &quot;2.5&quot;, //大剂量液量设置
     &quot;large_dose_speed&quot;: &quot;2.5&quot;   //大剂量速度设置
   }
  }

  测试指令
   {
   &quot;large_dose&quot;: 
   {      
     &quot;large_dose_liquid&quot;: &quot;2.5&quot;,
     &quot;large_dose_speed&quot;: &quot;2.5&quot;
   }
  }
</code></pre>
<p><strong>ack指令：</strong></p>
<ul>
<li>[ ] 接收到数据后应答指令   从机发送出去  (未完全实现 未验证)：</li>
</ul>
<pre><code>//基础率
{
  &quot;basal_rate&quot;: {
    &quot;basal_rate_num&quot;: &quot;2&quot;, //第几段基础率
    &quot;speed&quot;: &quot;8.5&quot;,        //基础率速度
    &quot;basal_rate_tim&quot;: &quot;01:03:28-20:30:30&quot; //当前段的基础率  起始时间 - 结束时间
  }
} 

//时间同步
{
  &quot;sync_tim&quot;: {      
    &quot;now_tim&quot;: &quot;12:20:30&quot;   //当前同步时间
  }
} 
//大剂量
 {
   &quot;large_dose&quot;: 
   {      
     &quot;large_dose_liquid&quot;: &quot;2.5&quot;, //大剂量液量设置
     &quot;large_dose_speed&quot;: &quot;2.5&quot;   //大剂量速度设置
   }
  }
</code></pre>
<h2 id="20241120">2024/11/20</h2>
<ul>
<li>
<p>[x] 实现ack指令并测试通过</p>
</li>
<li>
<p>基础率ack</p>
</li>
<li>时间同步ack</li>
<li>大剂量ack</li>
</ul>
<p>当ack的关键数据与发送的数据一致时，判定为一个成功的数据包</p>
<p><img alt="b987d460c7f6ca3a09dd2eff8c563f0" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/b987d460c7f6ca3a09dd2eff8c563f0.jpg" /></p>
<p><strong>RTC 时间同步</strong></p>
<ul>
<li>[x] 实现RTC实时时间显示，蓝牙指令可更改当前时间,在使用过程中，连接到手机可自动获取时间更新到设备上</li>
</ul>
<p>可同步的参数      年，月，日    时，分，秒</p>
<p><img alt="image-20241120150656442" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241120150656442.png" /></p>
<p>通过蓝牙指令可更改当前时间</p>
<pre><code>{
  &quot;sync_tim&quot;: {      
    &quot;now_tim&quot;: &quot;2024-08-29 12:22:00&quot;
  }
} 
</code></pre>
<p><strong>基础率设定</strong></p>
<p>基础率 控制睡眠的时间，启动时间为20ms，之后进入休眠，基础率的速度 直接影响睡眠时间</p>
<p>基础率---&gt;睡眠时间</p>
<p><strong>基础率与休眠时间的关系式：</strong>  </p>
<p>20ms  一步的量 0.1087U</p>
<p>0.5  / 0.1087  =   5步 （1h）</p>
<p>3600 / 5 =  720s</p>
<p>基础率 x </p>
<p>tim（ 秒） = 3600 /  (x / 0.1087)步</p>
<p>停止1s，运动20ms，运动一圈用时  2min</p>
<p>运动一圈的步数为120/1.02 = 117步</p>
<p>一步的量 12.72 / 117 = 0.1087U</p>
<p>基础率段数 ---&gt;当前的基础率段数（起始时间，结束时间）</p>
<p>功能： 20min睡眠  1s 唤醒</p>
<p>如何打开手机与蓝牙设备的数据收发</p>
<p>如何打开手机与蓝牙设备的收发？1</p>
<h2 id="20241121">2024/11/21</h2>
<ul>
<li>[x] 理解蓝牙工作模式 ，与 胡工 讨论胰岛素泵  ，确定胰岛素泵与手机app的连接过程</li>
</ul>
<p>1.系统启动时，进入低功耗广播，等待设备连接，</p>
<p>2.设备连接，胰岛素泵发出响声，按键确认后 建立连接（后续连接无需按 按键，保存连接设备信息）</p>
<p>3.建立连接后手机可配置胰岛素泵，与查看胰岛素泵的信息</p>
<p>4.退出app时(app在后台运行)，主动断开蓝牙连接，睡眠与广播交替，等待再次建立连接</p>
<p>5.打开app时(app在后台运行)，主动扫描已存在的设备并建立连接</p>
<p>6.app在后台运行时，间隔30min主动扫描胰岛素泵设备建立连接，获取交互数据，完成后主动断开连接</p>
<p><strong>BLE设备的主要状态</strong></p>
<ol>
<li>
<p><strong>待机状态（Standby State）</strong></p>
</li>
<li>
<p>描述</p>
</li>
<li>BLE设备默认处于待机状态，所有无线通信模块都关闭以节省能耗。</li>
<li>只有外部事件（如定时器、外部中断）或应用程序请求才能将设备从待机状态唤醒。</li>
<li><strong>功耗</strong>：最低。</li>
<li>
<p><strong>使用场景</strong>：无操作时的默认状态。</p>
</li>
<li>
<p><strong>广播状态（Advertising State）</strong></p>
</li>
<li>
<p>描述</p>
</li>
<li>从机通过广播信道（37、38、39）发送广播包，向主机发出存在信号。</li>
<li>广播包中可以包含设备的基本信息（如名称、服务UUID等）。</li>
<li>类型</li>
<li>可连接广播（Connectable Advertising）<ul>
<li>主机可以扫描到广播并请求连接。</li>
</ul>
</li>
<li>不可连接广播（Non-connectable Advertising）<ul>
<li>仅用于发送广播信息，不接受连接请求。</li>
</ul>
</li>
<li>定向广播（Directed Advertising）<ul>
<li>广播仅针对特定的主机地址。</li>
</ul>
</li>
<li>扫描响应广播（Scannable Advertising）<ul>
<li>可被主机扫描，主机收到广播后可以请求额外信息（扫描响应数据）。</li>
</ul>
</li>
<li><strong>功耗</strong>：广播间隔较短时功耗较高，间隔长时功耗较低。</li>
<li>
<p><strong>使用场景</strong>：设备待连接、周期性广播数据等。</p>
</li>
<li>
<p><strong>扫描状态（Scanning State）</strong></p>
</li>
<li>
<p>描述</p>
</li>
<li>主机设备在广播信道上扫描，从广播包中发现附近的BLE设备。</li>
<li>如果扫描到目标设备，可以请求额外信息（扫描响应）。</li>
<li>类型</li>
<li>主动扫描（Active Scanning）<ul>
<li>主机不仅接收广播包，还发送扫描请求，以获取扫描响应数据。</li>
</ul>
</li>
<li>被动扫描（Passive Scanning）<ul>
<li>主机仅接收广播包，不发送任何请求，功耗更低。</li>
</ul>
</li>
<li><strong>功耗</strong>：取决于扫描间隔和扫描窗口的设置。</li>
<li>
<p><strong>使用场景</strong>：主机寻找目标设备。</p>
</li>
<li>
<p><strong>连接状态（Connection State）</strong></p>
</li>
<li>
<p>描述</p>
</li>
<li>主机与从机建立连接后，双方通过已建立的连接信道进行数据通信。</li>
<li>进入此状态后，从机会停止广播，主机会停止扫描。</li>
<li>特性</li>
<li>数据传输使用加密和校验，连接更可靠。</li>
<li>可以通过连接参数（如连接间隔、数据包大小）优化功耗。</li>
<li>功耗</li>
<li>功耗由通信频率（连接间隔）和数据传输量决定，间隔较长时功耗较低。</li>
<li><strong>使用场景</strong>：文件传输、实时数据交互（如传感器数据）。</li>
</ol>
<p><strong>BLE工作状态切换图</strong></p>
<p>以下是典型的状态切换路径：</p>
<ol>
<li>
<p>从机（Slave Device）</p>
</li>
<li>
<p><strong>待机</strong> → <strong>广播</strong> → （主机连接请求） → <strong>连接</strong> → （断开连接） → <strong>广播或待机</strong>。</p>
</li>
<li>
<p>主机（Master Device）</p>
</li>
<li>
<p><strong>待机</strong> → <strong>扫描</strong> → （发现设备） → <strong>连接请求</strong> → <strong>连接</strong> → （断开连接） → <strong>扫描或待机</strong>。</p>
</li>
</ol>
<hr />
<p><strong>BLE状态优化功耗的关键</strong></p>
<ol>
<li><strong>广播优化</strong>：</li>
<li>增大广播间隔（如100ms到几秒）。</li>
<li>选择不可连接广播以降低功耗。</li>
<li><strong>扫描优化</strong>：</li>
<li>使用被动扫描。</li>
<li>增大扫描间隔并缩短扫描窗口。</li>
<li><strong>连接优化</strong>：</li>
<li>增大连接间隔（如100ms以上）。</li>
<li>减少数据传输量。</li>
<li><strong>待机优化</strong>：</li>
<li>
<p>尽可能让设备保持待机状态，使用低功耗定时器唤醒。</p>
</li>
<li>
<p>[x] 实现低功耗广播,广播时间间隔6s，广播时长10ms，</p>
</li>
</ol>
<p>设置广播的间隔时间 6s</p>
<p>sp_start_adv函数中</p>
<pre><code>adv_param.adv_intv_min = 6000;
adv_param.adv_intv_max = 6000;
</code></pre>
<p>睡眠模式时，电流为10uA,唤醒时瞬间最大电流为0.5mA,</p>
<p>gap_start_advertising(); 函数设置广告事件持续时间</p>
<h2 id="20241122">2024/11/22</h2>
<p>电机运行逻辑，蓝牙连接上参数设置（基础率 大剂量  同步时间），将网络时间同步至胰岛素泵，胰岛素泵依据设定基础率与大剂量，自动计算唤醒时间，主动唤醒电机运行，并将日志存储下来，等待下一次连接时将日志数据同步至手机</p>
<p>问题拆解： </p>
<ul>
<li>[x] 进入睡眠时系统rtc应该处于运行状态，蓝牙连接时自动同步系统时间,保证系统时间的准确性 </li>
<li>[x] 蓝牙连接时候正常工作，蓝牙断开时低功耗广播</li>
<li>[ ] 依据设定的各个基础率段，自动计算唤醒时间点，唤醒 电机运行后主动休眠</li>
<li>[ ] 依据设定的大剂量(延长双波大剂量)，更新大剂量所处时间段的唤醒时间，唤醒 电机运行后主动休眠</li>
<li>[ ] 指定时间唤醒设备运行电机</li>
<li>[ ] 每一次唤醒电机，电机运行后将时间，以及输注剂量存储在flash内部, flash的大小至少保证日志存储10天</li>
</ul>
<p>目前存在问题：</p>
<p>第一次休眠时，低功耗正常，启动task后再进入睡眠状态功耗较高，应该是某部分外设未解初始化，</p>
<ul>
<li>获取连接状态</li>
</ul>
<p><strong>bool gap_get_connect_status(uint8_t conidx)</strong>；</p>
<p><img alt="image-20241122084538658" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122084538658.png" /></p>
<ul>
<li>
<p>[x] 实现低功耗逻辑，连接到蓝牙设备时候时mcu进入正常工作模式，此时可进行数据的收发，检测到断开蓝牙的连接时，进入低功耗广播状态， 电流表测量电流正常工作时电流为8.5mA, 断开连接，低功耗状态为10uA,广播时功耗为0.7mA</p>
</li>
<li>
<p>进入睡眠前检测蓝牙是否处于连接状态，蓝牙已连接则关闭睡眠</p>
</li>
</ul>
<p><img alt="image-20241122100005897" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122100005897.png" /></p>
<ul>
<li>检测到蓝牙断开连接，则开启睡眠模式</li>
</ul>
<p><img alt="image-20241122100125104" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122100125104.png" /></p>
<ul>
<li>蓝牙建立连接后启动任务</li>
</ul>
<p>void app_gap_evt_cb(gap_event_t *p_event)</p>
<p><img alt="image-20241122173338237" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241122173338237.png" /></p>
<h2 id="20241123">2024/11/23</h2>
<ul>
<li>
<p>[x] 解决昨天的 第一次休眠时，低功耗正常，启动task后再进入睡眠状态功耗较高，应该是某部分外设未解初始化，</p>
</li>
<li>
<p>原因是在销毁task之前未解初始化adc，在进入睡眠前调用 adc_disable(); 即可关闭adc的调用，实际测试过程中，正常工作模式开启adc的功能会比较耗电，电流为2mA/h左右</p>
</li>
</ul>
<p>依据设定的各个基础率段，自动计算唤醒时间点，唤醒 电机运行后主动休眠</p>
<p>输入数据： 时间段，基础率  ---&gt;    输出功能为    自动计算唤醒时间点，唤醒后电机再次休眠</p>
<ul>
<li>依据输入时间段自动计算唤醒时间点</li>
<li>
<p>在唤醒时间点自动唤醒，启动电机后进入休眠状态   (电机启动时完成一次数据交互，包括时间同步，数据获取，电池电量，剩余液量)</p>
</li>
<li>
<p>[ ] 依据输入时间段自动计算时间点代码完成，测试时 计算时间较长会导致系统卡死</p>
</li>
</ul>
<p>问题所在</p>
<p>//唤醒时间点
typedef struct weak_up_tim{
   uint16_t hh;
   uint16_t min;
   uint16_t s;
}weak_up_tim;</p>
<p>定义结构体数组未指定大小  weak_up_tim  wake_up_times[ ] = {0};</p>
<p>weak_up_tim  wake_up_times[7000 ] = {0};</p>
<p>指定大小后 其数组较大，存储在静态区，没有溢出但系统频繁重启，可能是静态库中的限制</p>
<p>考虑不一次性存储所有时间，每次启动时，只要计算出下一个启动时间即可，（优点，占用ram较少，缺点，每次唤醒启动时都要计算时间，额外增加功耗）</p>
<h2 id="20241125">2024/11/25</h2>
<ul>
<li>[x] 完成单段基础率并实际测试成功，蓝牙连接状态下，蓝牙非连接状态下都可</li>
</ul>
<p>应用：开机时未设置基础率，电机不会运行，开机首先自动同步时间至系统(由APP端完成)，再发送基础率指令，系统开始运行</p>
<p>{
  "sync_tim": {    <br />
    "now_tim": "2024-11-20 20:20:10"
  }
} </p>
<p>{
     "basal_rate": <br />
    {
     "basal_rate_num": "1",
     "speed": "0.5",        <br />
     "basal_rate_tim": "01:30-02:30" 
    }
   }   </p>
<ul>
<li>
<p>[x] 使用C语言实现串口数据的接收，并将原本倒置的数据反过来，并在接收的数据前加上时间戳</p>
</li>
<li>
<p>由于电子秤使用连续发送指令，发过来的数据较快，使用串口上位机接收数据会导致上位机卡死或识别不到串口，更换电子秤的为指令发送较为理想</p>
</li>
</ul>
<p><img alt="" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241125172638976.png" /></p>
<ul>
<li>发送数据较快，打开不了该串口同时数据不好处理</li>
</ul>
<p><img alt="image-20241125171907614" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241125171907614.png" /></p>
<ul>
<li>[ ] 已安装虚拟串口助手，明天调试指令发送的程序，并将数据加上时间戳，保存至日志文件中，换货的电子秤到手就可以用</li>
</ul>
<h2 id="20241126">2024/11/26</h2>
<ul>
<li>
<p>[x] 使用C语言虚拟电子秤作为从机串口通信，</p>
</li>
<li>
<p>发送R时返回一个数据</p>
</li>
</ul>
<p><img alt="image-20241126103208232" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126103208232.png" /></p>
<ul>
<li>[x] PC作为主机，主动发送R获取数据，并将接收数据加上时间戳写入日志文件</li>
</ul>
<p><img alt="image-20241126103349041" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126103349041.png" /></p>
<ul>
<li>日志文件</li>
</ul>
<p><img alt="image-20241126103441844" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126103441844.png" /></p>
<ul>
<li>[ ] 使用python实现数据可视化</li>
</ul>
<p>安装python解释器   https://www.python.org/downloads/</p>
<p>安装依赖库：打开cmd窗口使用命令行安装</p>
<p>E:/software/python3.13/python.exe -m pip install matplotlib    (其中software/python3.13为python解释器的路径，需依据自己的环境更改)</p>
<p>可视化数据分析，横轴应该为时间，纵轴应该为数据，同时显示的数据应该可以设置显示时间间隔，与在screen显示的时间段</p>
<ul>
<li>横轴时间   </li>
<li>纵轴数据</li>
<li>时间间隔调整 </li>
<li>显示时间段调整  </li>
</ul>
<p>该启动程序在master目录下</p>
<p><img alt="image-20241126140715302" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241126140715302.png" /></p>
<h2 id="20241127">2024/11/27</h2>
<ul>
<li>[x] 昨天电子秤上位机bug更改完成</li>
<li>[x] 新增动态数据更新，可实时显示串口数据，新增时间动态调整，左右滑动时网格有动态效果</li>
</ul>
<p><img alt="image-20241127181213622" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241127181213622.png" /></p>
<h2 id="20241128">2024/11/28</h2>
<ul>
<li>[x] 上午：产线拆机</li>
</ul>
<p>​       下午：</p>
<ul>
<li>[x] 多段基础率设置成功 初步测试通过</li>
</ul>
<p>开机启动时，时间为12:00:00，蓝牙连接输入以下指令，将按照不同时间段不同速度运行</p>
<p>{ "basal_rate": { "basal_rate_num": "1", "speed": "30", "basal_rate_tim": "00:00-12:00" } } 
  { "basal_rate": { "basal_rate_num": "2", "speed": "25", "basal_rate_tim": "12:00-12:05" } } 
  { "basal_rate": { "basal_rate_num": "3", "speed": "30", "basal_rate_tim": "12:05-12:10" } } 
  { "basal_rate": { "basal_rate_num": "4", "speed": "25", "basal_rate_tim": "12:10-23:59" } } </p>
<p><img alt="image-20241128173457537" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241128173457537.png" /></p>
<p><img alt="image-20241128173632668" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241128173632668.png" /></p>
<h2 id="20241129">2024/11/29</h2>
<ul>
<li>[x] 了解胰岛素泵中的 “方波” 和 “双波” </li>
</ul>
<p>方波和双波模式主要与<strong>餐后追加胰岛素（Bolus insulin）相关，而非基础率（Basal rate）。它们用于在进餐后根据具体饮食情况调整胰岛素的释放模式，属于额外释放</strong>的剂量，与基础率无直接关系。</p>
<ol>
<li><strong>基础率（Basal rate）</strong></li>
</ol>
<p>基础率是胰岛素泵<strong>持续释放</strong>的微量胰岛素，用于维持身体的基本代谢需求。基础率的作用是覆盖非进餐时间的胰岛素需求，例如夜间和空腹状态下的血糖控制。它是一个背景释放量，并不随着进餐变化而改变。</p>
<hr />
<ol>
<li><strong>方波和双波的作用</strong></li>
</ol>
<p>方波和双波模式属于<strong>追加剂量（Bolus insulin）*<em>的释放方式，专门针对进餐后血糖的波动设计，用来处理餐后血糖上升的问题。它们是餐前根据食物类型和量计算的*</em>额外剂量</strong>，与基础率分开管理。</p>
<ul>
<li><strong>方波（Square Wave Bolus）</strong>： 在进餐后的一段时间内<strong>持续增加释放量</strong>，但这种释放是缓慢且均匀的。适合慢消化、高脂高蛋白的食物。</li>
<li><strong>双波（Dual Wave Bolus）</strong>： 在进餐后，先释放一部分胰岛素（快速处理碳水化合物引起的血糖快速上升），随后再以方波方式缓慢释放剩余胰岛素。适合混合饮食或复杂的进餐场景。</li>
</ul>
<p><strong>是否在基础率上叠加？</strong></p>
<p>不是在基础率上直接叠加，而是<strong>独立计算并额外释放</strong>的剂量。这些模式的设定不会改变基础率，但与基础率的释放是同时进行的：</p>
<ul>
<li><strong>基础率</strong>始终运行，提供背景胰岛素。</li>
<li><strong>方波或双波模式的释放</strong>是针对进餐后短时间内的需求，并由使用者或医生根据具体餐后血糖特点决定。</li>
</ul>
<p>示例场景</p>
<p>假设：</p>
<ul>
<li><strong>基础率</strong>设置为每小时0.5单位胰岛素。</li>
<li>根据进餐食物计算，餐后需要追加10单位的胰岛素。</li>
<li>使用<strong>普通模式</strong>：一次性释放10单位。</li>
<li>使用<strong>方波模式</strong>：10单位在4小时内均匀释放，每小时增加2.5单位，合计每小时释放3单位（0.5基础率 + 2.5方波释放）。</li>
<li>使用<strong>双波模式</strong>：5单位立即释放，剩余5单位以方波方式在4小时内均匀释放，每小时额外增加1.25单位，合计每小时释放1.75单位（0.5基础率 + 1.25方波释放）。</li>
</ul>
<p>总结：大剂量设定的方波，双波与基础率设定无关，与基础率的释放是同时进行的</p>
<ul>
<li>[x] 同类产品的大剂量功能参考</li>
</ul>
<p><strong>参考1</strong></p>
<p>参考链接 https://endo.dxy.cn/specials/hsnfm/article/530629</p>
<p>下图中可以看到，方波设置的参数有  <strong>剂量</strong>  <strong>持续时间</strong></p>
<p><img alt="image-20241129105428127" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129105428127.png" /></p>
<p>下图中可以看到，双波设置的参数有  <strong>剂量</strong>   方波大剂量</p>
<p>双波设定  首先输入总剂量，一半立马释放，剩下的一半作为方波缓慢释放</p>
<p><img alt="image-20241129105731607" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129105731607.png" /></p>
<p>上述可以看到，双波立马会释放一半的量，剩下的一半为方波缓慢释放，双波立马输注的量总是一半么？</p>
<p>查询资料，大剂量的分配可以根据饮食和个体需求调整，以下是常见的比例设定：</p>
<ol>
<li><strong>50% / 50% 分配</strong></li>
<li><strong>50%立即释放</strong>（快速波），<strong>50%缓慢释放</strong>（方波）。</li>
<li>适用于大多数<strong>混合饮食</strong>（含碳水、脂肪和蛋白质）或不确定消化速度的情况。</li>
<li><strong>60% / 40% 分配</strong></li>
<li><strong>60%立即释放</strong>，<strong>40%缓慢释放</strong>。</li>
<li>适用于以碳水化合物为主的饮食，快速升高血糖，但有部分延迟消化的成分。</li>
<li><strong>30% / 70% 分配</strong></li>
<li><strong>30%立即释放</strong>，<strong>70%缓慢释放</strong>。</li>
<li>适用于脂肪含量高、蛋白质比例大的食物（如披萨、芝士蛋糕），这些食物通常导致更缓慢的血糖上升。</li>
</ol>
<p><strong>参考2</strong></p>
<p>参考链接:https://www.sohu.com/a/353194903_621323</p>
<p>上述文章中指出了，有一些型号的胰岛素泵的大剂量输注有3种方式（以福尼亚新二代胰岛素泵为例），分为“<strong>常规大剂量</strong>”、“<strong>方波大剂量”、“双波大剂量”。</strong></p>
<p>“<strong>方波大剂量”、“双波大剂量”。</strong>上述中有说明</p>
<p>常规大剂量适用于餐前立马输注，相当于双波的前一段，该输注方式的特点是在短时间内释放特定的剂量，当你马上需要胰岛素时可以发挥最佳作用。（100%的胰岛素餐前立即注射）</p>
<p><strong>参考3</strong></p>
<p>参考链接：https://zhuanlan.zhihu.com/p/386703926</p>
<p>文章中指出了丹娜胰岛素泵的三种模式，常规，方波，双波，  </p>
<p><img alt="img" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/v2-40893fe585bcad25fe3649c1c4319234_1440w.jpg" /></p>
<p><strong>参考4</strong></p>
<p>https://zhuanlan.zhihu.com/p/81942889</p>
<p>Medtronic 是一家总部位于<strong>美国</strong>的全球医疗技术公司，成立于 1949 年，专注于心脏病学、糖尿病管理、神经科学和其他医疗领域。</p>
<p>文章中指出 Medtronic MiniMed 胰岛素泵的 大剂量有 方波和双波的功能，<strong>与其他胰岛素泵不同之处在于</strong>，<strong>双波可以自定义比例</strong></p>
<p><img alt="image-20241129112726138" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129112726138.png" /></p>
<p><strong>总结：</strong></p>
<p>上述参考，胰岛素泵的大剂量功能可分为三种模式</p>
<ul>
<li>
<p>常规大剂量（餐前立马100%输注）</p>
</li>
<li>
<p>方波大剂量（一定时间内均匀输注）</p>
</li>
<li>
<p>双波形大剂量（立马输注+均匀输注，也可以看作是常规大剂量+方波大剂量，其中双波大剂量的输注比例可调节）</p>
</li>
<li>
<p>[x] 三种大剂量模式的参数定义与数据解析实现</p>
</li>
<li>
<p>常规大剂量指令</p>
</li>
</ul>
<pre><code class="language-json">  { 
  &quot;normal_large_dose&quot;: {        //常规大剂量
  &quot;large_dose_liquid&quot;: &quot;xx.x&quot;   //液量
  }} 


-----example

{&quot;normal_large_dose&quot;: {&quot;large_dose_liquid&quot;: &quot;9.5&quot;}} 

</code></pre>
<p><img alt="image-20241129145804460" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129145804460.png" /></p>
<ul>
<li>方波大剂量指令</li>
</ul>
<pre><code class="language-json">  { 
  &quot;square_wave_large_dose&quot;: {   //方波大剂量 
  &quot;large_dose_liquid&quot;: &quot;xx.x&quot;,  //液量
  &quot;tim_hh&quot;:&quot;xx&quot;,                //时间 h
  &quot;tim_min&quot;:&quot;xx&quot;                //时间 min
  }}  

-----example

{&quot;square_wave_large_dose&quot;:{&quot;large_dose_liquid&quot;:&quot;10.5&quot;,&quot;tim_hh&quot;:&quot;02&quot;,&quot;tim_min&quot;:&quot;30&quot;}}  

</code></pre>
<p><img alt="image-20241129145901952" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129145901952.png" /></p>
<ul>
<li>双波大剂量指令</li>
</ul>
<pre><code class="language-json">{
 &quot;double_wave_large_dose&quot;:{      //双波大剂量
 &quot;all_liquid&quot;:&quot;xx.x&quot;,            //总液量
 &quot;proportion&quot;:&quot;xx&quot;,              //比例
 &quot;tim_hh&quot;:&quot;xx&quot;,                  //时间 h
 &quot;tim_min&quot;:&quot;xx&quot;                  //时间 min 
}}

-----example

{&quot;double_wave_large_dose&quot;:{&quot;all_liquid&quot;:&quot;15&quot;,&quot;proportion&quot;:&quot;50&quot;, &quot;tim_hh&quot;:&quot;1&quot;, &quot;tim_min&quot;:&quot;10&quot;}}  

</code></pre>
<p><img alt="image-20241129145941961" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241129145941961.png" /></p>
<h2 id="2024122">2024/12/2</h2>
<p><img alt="image-20241202094244724" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202094244724.png" /></p>
<p><strong>1.烧录程序步骤</strong></p>
<p>程序使用串口烧录，Micro usb烧录, 板载 USB转 TTL  CH340,</p>
<p>烧录时首先按住 UART_DOWNLOAD 按钮，然后按下并释放 RESET 按钮，最后释放 UART_DOWNLOAD 按钮。</p>
<p><img alt="image-20241202094720340" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202094720340.png" /></p>
<p><strong>2.打印串口</strong></p>
<ul>
<li>打印串口信息使用 micro usb  与下载使用同一个 uart</li>
</ul>
<p><strong>3.烧录程序目前可以用（usb/uart/SWD）</strong></p>
<p>目前可以使用的是 通过micro_usb烧录(usb转TTL)</p>
<p><strong>4.cmos sensor 型号</strong></p>
<p>JXF37P</p>
<p><img alt="image-20241202100244817" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202100244817.png" /></p>
<p><img alt="image-20241202104739478" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202104739478.png" /></p>
<ul>
<li>支持cmos sensor</li>
</ul>
<pre><code class="language-c">#define SENSOR_DUMMY        0x00     //For dummy sensor, no support fast camera start
#define SENSOR_SC2336       0x01
#define SENSOR_GC2053       0x02
#define SENSOR_GC4653       0x03
#define SENSOR_F37          0x04
#define SENSOR_IMX327       0x05
#define SENSOR_F51          0x06
#define SENSOR_PS5258       0x07     //It don't support the multi sensor for PS5258 now.If you want to use the sensor,please remove it.
#define SENSOR_SC301        0x08
#define SENSOR_IMX307       0x09
#define SENSOR_SC2333       0x0A
#define SENSOR_GC4023       0x0B
#define SENSOR_PS5420       0x0C
#define SENSOR_PS5270       0x0D
#define SENSOR_GC5035       0x0E
#define SENSOR_PS5268       0x0F
#define SENSOR_SC2310       0x10
#define SENSOR_PS5420_HDR       0x11
#define SENSOR_PS5270_HDR       0x12

static const struct sensor_params_t sensor_params[] = {
    {1920, 1080, 30}, //DUMMY
    {1920, 1080, 30}, //SC2336
    {1920, 1080, 30}, //GC2053
    {2560, 1440, 15}, //GC4653
    {1920, 1080, 30}, //F37
    {1920, 1080, 30}, //IMX327
    {1536, 1536, 30}, //F51
    {1920, 1080, 30}, //PS5258
    {2048, 1536, 20}, //SC301
    {1920, 1080, 30}, //IMX307
    {1920, 1080, 30}, //SC2333
    {2560, 1440, 15}, //GC4023
    {1952, 1944, 30}, //PS5420
    {1536, 1536, 30}, //PS5270
    {2592, 1944, 30}, //GC5035
    {1920, 1080, 30}, //PS5268
    {1920, 1080, 30}, //SC2310
    {1952, 1944, 30}, //PS5420_HDR
    {1536, 1536, 30}, //PS5270_HDR
};
</code></pre>
<p><strong>5.WPS_KEY</strong></p>
<p><img alt="" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202105906635.png" /></p>
<p>WPS（Wi-Fi Protected Setup）是一种简化无线网络配置的协议，旨在让用户更轻松地将设备连接到无线网络，而不需要手动输入复杂的网络密码。WPS特别适用于普通用户，通过几种便捷的方式实现快速、安全的无线网络连接。</p>
<p>在这个上下文中：</p>
<ol>
<li>
<p><strong>WPS 功能的主要用途</strong>
   WPS 的主要目的是通过一种用户友好的方式将设备（如手机、电脑、智能家居设备）加入到 Wi-Fi 网络中。</p>
</li>
<li>
<p><strong>典型应用场景</strong>：用户购买了新设备，希望快速连接到家中的路由器，而无需输入复杂的密码。</p>
</li>
<li>
<p><strong>支持的 WPS 配置方法</strong>
   文档中提到的配置方法主要有以下几种：</p>
</li>
<li>
<p><strong>WPS_CONFIG_DISPLAY</strong>: 在设备显示屏上显示一个 PIN，用户需要在路由器管理页面输入此 PIN。</p>
</li>
<li><strong>WPS_CONFIG_KEYPAD</strong>: 用户在设备上手动输入路由器的 PIN。</li>
<li>
<p><strong>WPS_CONFIG_PUSHBUTTON</strong>: 用户按下路由器和设备上的 WPS 按钮以自动建立连接（不需要输入密码）。</p>
</li>
<li>
<p><strong>WPS 的函数解释</strong></p>
</li>
<li>
<p>wps_start</p>
<p>启动 WPS 加入流程。用户可以选择 PIN 输入方式（Display/Keypad）或按钮触发方式（PushButton）。</p>
<ul>
<li>Parameters</li>
<li><code>wps_config</code>: 设置 WPS 配置方法。</li>
<li><code>pin</code>: 如果使用 PIN 方式，需要提供对应的 PIN（PushButton 时为 NULL）。</li>
<li><code>channel</code>: 当前未使用，可设置为 0。</li>
<li><code>ssid</code>: 可指定目标网络的 SSID，如果为 NULL，表示不指定网络（由设备自动选择）。</li>
<li>Return</li>
<li><code>0</code>: 表示成功启动 WPS。</li>
<li>非 0: 表示启动失败。</li>
<li>注意：调用 wps_start 之前需要先确保 Wi-Fi 已启用，并在配置中打开 CONFIG_ENABLE_WPS。</li>
</ul>
</li>
<li>
<p>wps_stop</p>
<p>停止 WPS 加入流程。</p>
<ul>
<li>无参数，直接调用即可。</li>
</ul>
</li>
<li>
<p><strong>WPS 使用的注意事项</strong></p>
</li>
<li>
<p>最大会话时间为 120 秒，WPS 流程需要在此时间内完成。</p>
</li>
<li>
<p>如果用户不想继续 WPS，可以随时调用 <code>wps_stop</code> 中止流程。</p>
</li>
<li>
<p><strong>WPS 的安全性问题</strong>
   尽管 WPS 提供了便利性，但需要注意其潜在的安全隐患：</p>
</li>
<li>
<p><strong>PIN 攻击</strong>：一些早期路由器的 WPS 功能对 PIN 攻击较为脆弱，攻击者可能通过暴力破解 PIN 获取网络密码。</p>
</li>
<li><strong>建议</strong>：如果设备支持，最好选择更安全的方式（如 WPA3）来保护网络。</li>
</ol>
<p>在实践中，使用 WPS 能够简化某些设备的连接步骤，但应权衡便利性与安全性的关系。</p>
<ul>
<li>在sdk中查询，未找到api直接调用demo,测试报错</li>
</ul>
<p><strong>6.增加LED PWM</strong></p>
<p>选择使用<strong>PF13</strong> 作为LED PWM  已验证可行</p>
<p><img alt="get-start-2" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/P02.png" /></p>
<p><img alt="image-20241202134439476" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241202134439476.png" /></p>
<ul>
<li>支持cmos sensor</li>
</ul>
<pre><code>#define SENSOR_DUMMY        0x00     //For dummy sensor, no support fast camera start
#define SENSOR_SC2336       0x01
#define SENSOR_GC2053       0x02
#define SENSOR_GC4653       0x03
#define SENSOR_F37          0x04
#define SENSOR_IMX327       0x05
#define SENSOR_F51          0x06
#define SENSOR_PS5258       0x07     //It don't support the multi sensor for PS5258 now.If you want to use the sensor,please remove it.
#define SENSOR_SC301        0x08
#define SENSOR_IMX307       0x09
#define SENSOR_SC2333       0x0A
#define SENSOR_GC4023       0x0B
#define SENSOR_PS5420       0x0C
#define SENSOR_PS5270       0x0D
#define SENSOR_GC5035       0x0E
#define SENSOR_PS5268       0x0F
#define SENSOR_SC2310       0x10
#define SENSOR_PS5420_HDR       0x11
#define SENSOR_PS5270_HDR       0x12

static const struct sensor_params_t sensor_params[] = {
    {1920, 1080, 30}, //DUMMY
    {1920, 1080, 30}, //SC2336
    {1920, 1080, 30}, //GC2053
    {2560, 1440, 15}, //GC4653
    {1920, 1080, 30}, //F37
    //{640, 480, 30},//F37
    {1920, 1080, 30}, //IMX327
    {1536, 1536, 30}, //F51
    {1920, 1080, 30}, //PS5258
    {2048, 1536, 20}, //SC301
    {1920, 1080, 30}, //IMX307
    {1920, 1080, 30}, //SC2333
    {2560, 1440, 15}, //GC4023
    {1952, 1944, 30}, //PS5420
    {1536, 1536, 30}, //PS5270
    {2592, 1944, 30}, //GC5035
    {1920, 1080, 30}, //PS5268
    {1920, 1080, 30}, //SC2310
    {1952, 1944, 30}, //PS5420_HDR
    {1536, 1536, 30}, //PS5270_HDR
};

</code></pre>
<p>胰岛素泵</p>
<ul>
<li>[x] 实现常规大剂量模式 并实际测试通过</li>
</ul>
<h2 id="2024123">2024/12/3</h2>
<p>ubuntu中加密库的使用mbedtls</p>
<p>动态库方式实现</p>
<p>首先确保系统的工具是最新的</p>
<pre><code>sudo apt update
sudo apt install build-essential cmake libssl-dev
</code></pre>
<p>下载mbedtls,使用cmake进行编译，进入mbedtls的目录，在当前目录下创建一个build文件</p>
<pre><code>touch build
cd build
cmake .. -G &quot;Unix Makefiles&quot;
make

安装
sudo make install

配置系统动态链接库
sudo ldconfig
</code></pre>
<p>测试库是否可以正常使用 </p>
<p>aes.c</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;mbedtls/aes.h&quot;

int main() {
    // AES 密钥（128位）
    unsigned char key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 
                              0xab, 0xf7, 0x97, 0x75, 0x46, 0x7e, 0x46, 0x40};  // 128-bit 密钥

    // 明文
    unsigned char input[16] = &quot;Hello, AES Test!&quot;;  // 必须是 16 字节（128 位）的数据块

    // 密文输出
    unsigned char encrypted[16] = {0};

    // 解密后的明文输出
    unsigned char decrypted[16] = {0};

    // 初始化 AES 上下文
    mbedtls_aes_context aes;
    mbedtls_aes_init(&amp;aes);

    // 设置加密密钥
    if (mbedtls_aes_setkey_enc(&amp;aes, key, 128) != 0) {
        printf(&quot;设置加密密钥失败\n&quot;);
        return -1;
    }

    // 执行 AES 加密
    if (mbedtls_aes_crypt_ecb(&amp;aes, MBEDTLS_AES_ENCRYPT, input, encrypted) != 0) {
        printf(&quot;加密失败\n&quot;);
        return -1;
    }

    // 输出加密后的数据
    printf(&quot;加密后的密文：\n&quot;);
    for (int i = 0; i &lt; 16; i++) {
        printf(&quot;%02x &quot;, encrypted[i]);
    }
    printf(&quot;\n&quot;);

    // 设置解密密钥
    if (mbedtls_aes_setkey_dec(&amp;aes, key, 128) != 0) {
        printf(&quot;设置解密密钥失败\n&quot;);
        return -1;
    }

    // 执行 AES 解密
    if (mbedtls_aes_crypt_ecb(&amp;aes, MBEDTLS_AES_DECRYPT, encrypted, decrypted) != 0) {
        printf(&quot;解密失败\n&quot;);
        return -1;
    }

    // 输出解密后的数据
    printf(&quot;解密后的明文：\n&quot;);
    for (int i = 0; i &lt; 16; i++) {
        printf(&quot;%c&quot;, decrypted[i]);
    }
    printf(&quot;\n&quot;);

    // 清理 AES 上下文
    mbedtls_aes_free(&amp;aes);

    return 0;
}
</code></pre>
<p><strong>编译:</strong></p>
<pre><code>gcc -o aes aes.c -lmbedtls -lmbedx509 -lmbedcrypto
</code></pre>
<p><strong>sha256验证</strong></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;mbedtls/sha256.h&gt;
#include &lt;mbedtls/error.h&gt;
#include &lt;stdlib.h&gt;

#define BUFFER_SIZE 1024  // 缓冲区大小

// 计算文件的 SHA-256 校验值
int calculate_sha256(const char *filename, unsigned char *output_hash) {
    FILE *file = fopen(filename, &quot;rb&quot;);
    if (file == NULL) {
        perror(&quot;无法打开文件&quot;);
        return -1;
    }

    // 初始化 SHA-256 上下文
    mbedtls_sha256_context sha256_ctx;
    mbedtls_sha256_init(&amp;sha256_ctx);
    mbedtls_sha256_starts(&amp;sha256_ctx, 0);  // 0 表示进行标准的 SHA-256 计算

    // 逐块读取文件并计算哈希
    unsigned char buffer[BUFFER_SIZE];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) &gt; 0) {
        mbedtls_sha256_update(&amp;sha256_ctx, buffer, bytes_read);
    }

    // 完成哈希计算
    mbedtls_sha256_finish(&amp;sha256_ctx, output_hash);

    // 清理 SHA-256 上下文
    mbedtls_sha256_free(&amp;sha256_ctx);
    fclose(file);

    return 0;
}

// 打印 SHA-256 哈希值
void print_sha256_hash(unsigned char *hash) {
    for (int i = 0; i &lt; 32; i++) {
        printf(&quot;%02x&quot;, hash[i]);
    }
    printf(&quot;\n&quot;);
}

int main() {
    const char *filename = &quot;test.bin&quot;;  // 输入文件名
    unsigned char hash[32];  // SHA-256 哈希值是 32 字节

    // 计算文件的 SHA-256 校验值
    if (calculate_sha256(filename, hash) == 0) {
        printf(&quot;SHA-256 校验值：&quot;);
        print_sha256_hash(hash);
    } else {
        printf(&quot;文件处理失败\n&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<p><strong>编译</strong></p>
<pre><code>gcc -o sha256 sha256.c  -lmbedtls -lmbedx509 -lmbedcrypto
</code></pre>
<p>我想使用mbedtls 库，理解rsa 非对称加密 使用2048 位秘钥长度，我有一个固件test.bin，帮我做一个固件可信 </p>
<p><strong>生成 RSA 密钥对的步骤：</strong></p>
<ol>
<li><strong>安装 OpenSSL</strong>（如果尚未安装）：</li>
</ol>
<p><code>sudo apt update
   sudo apt install openssl</code></p>
<ol>
<li><strong>生成 2048 位 RSA 私钥</strong>： 使用以下命令生成一个私钥文件 <code>private_key.pem</code>：</li>
</ol>
<p><code>openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048</code></p>
<ol>
<li><strong>从私钥提取公钥</strong>： 使用以下命令从生成的私钥中提取公钥，保存为 <code>public_key.pem</code>：</li>
</ol>
<p><code>openssl rsa -pubout -in private_key.pem -out public_key.pem</code></p>
<pre><code>public key:

MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp+8UK6KaexLhXjM0D9jm
nKgIpvOFc0xS9V3Ue7AJsmnM5E/YuwTG8yIPiUkzL97IjX6IJA9S6rNbW/h1E5S2
pEfIZL8SWFGNw7fKmXiYcEERxwKt/lvZsih1Gb+W7B7h0guKMoLJiMMxlQbT5JLz
ZUPuTQHRwedPWDrcAjGCyeyoJGYKu7pk5olvNkMizJdczVSNqabQkDSwCrSPP337
7wV8lMg6FLB+j/esDf0N1oHwZpfSwD+OJMNOTq5AbMDZvWcQ21MrEN/i3ZtTS9Xk
T2scMtc8OVKAbTQ+/+DY3KhVHi6iLcfe/SDRm35CztcJXxGdj+KtZKwbd+XIt74q
xQIDAQAB

private key:

MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCn7xQropp7EuFe
MzQP2OacqAim84VzTFL1XdR7sAmyaczkT9i7BMbzIg+JSTMv3siNfogkD1Lqs1tb
+HUTlLakR8hkvxJYUY3Dt8qZeJhwQRHHAq3+W9myKHUZv5bsHuHSC4oygsmIwzGV
BtPkkvNlQ+5NAdHB509YOtwCMYLJ7KgkZgq7umTmiW82QyLMl1zNVI2pptCQNLAK
tI8/ffvvBXyUyDoUsH6P96wN/Q3WgfBml9LAP44kw05OrkBswNm9ZxDbUysQ3+Ld
m1NL1eRPaxwy1zw5UoBtND7/4NjcqFUeLqItx979INGbfkLO1wlfEZ2P4q1krBt3
5ci3virFAgMBAAECggEAB4WGdRXersMqY5pjgI+JygZ0rMBHf+Hb7VrQg4xfmCVz
pIjhqi637SKKE5oQYtqAR7tybuWzebOi1JG3nLLnzfUxHTdkTkmzfHVPlmQiX79q
WRbeTYA2VevIouiZN+Ys3cg1M7dL6NuP7Z7VVW2Hh/JCSsyuum1DzoMvC3dwO4mo
A7iHNV3KWebtUKmQ+P5Egg0v7FEY3Ha2iedVdKtGazOj+k8fw+TbtsJNebWMbI/J
rP/wVpdt76ZaaWPyg6EzNSXInmF5+cdhU89SWRrlT7AR/agwpCYgffaUfvS80Kyt
Z0n1iO84KwDxQgP2JuWtzjhfQ0R1U4iq4lDcFPChmQKBgQC8uoNibakyL63icfEr
DMKUzfZRA0/HBZo85D7aJ/UB/rxnDsImqZL7ohVR6ukBYciAaUdlnV34xWf0taGS
CWMyHzJFgF9NEx1KR607xcwNpxZfPB1yQ4vlZiP2sicrhpFCHtc7K89uQQ9eEf9E
Y65KOCSNULyo4AWBI8wi6wxSnwKBgQDjyw1AtG00IvLgAQ9eYS8Pt5bPvA3ocE1S
8Z6jIDFRv/bTiVunl5kKJKcVs+Eav9NZIQwM+yHXvCBjcjzF6hsu8VI8FCCMIkV+
byaXobjPZaNCEzMbCfE53TlZUlPGGRXJzKOODzggTfdhfNS9KpP1LMhrvFpaGqh8
Lula3y4MGwKBgQCc12PYqMmzq2wWhBqobDJI9+F78gSaoU1MzWJuakZzIf/wpZM0
DjjYZhrRuSdqvpiiHtv21pEB7Qw3kbp0YtjNDp/4onaQ1xHAaVDOG9M4hWNSQeM2
0muwePHqUqO6yFpvWLIFuqLoPalHxC0f6Lcvdvjpd+9RaNsqN1WuryfOgQKBgQDf
kCkxl+KViLdVobSzrC3D/yrENoxv08gP35MSBkZhNUXJ1sVddit9CPvzENecqSeE
EisBkndkg/5Fm5iJpXmIWM+cpyRKZFhP/kaiCtaWtenEr5M4tklJwRTH1UTi5zu7
Elxyz/0Ft39S7nDcNy1/MrSBCBqk1AUH3AKqbN+EgQKBgQC6c3+CB2JRviu4yLi7
tetaAMi337SWaFRcIGhc3KrbOqxhok7JeRW5SfxSSSgfX32BzbpX6qYUoHGg1be7
vlEsYmrB6RFm+zILSO4YlICnEJxONkFgyeAgdjWx4YvwKHU3IdlTiEvIU0cutmj8
n00y1GxdZzcHjCIddCC5Wr0kMg==
</code></pre>
<p>使用上述生成的公钥与私钥做rsa固件可信</p>
<p>gcc -o sign_firmware sign_firmware.c  -lmbedtls -lmbedx509 -lmbedcrypto</p>
<p>./sign_firmware</p>
<ul>
<li>[ ] 上午实现大剂量模式中的 方波模式大剂量</li>
</ul>
<p>基础率运行的情况下，输入以下指令，将设置 输液量15个单位，在2.5h内均匀输注完成</p>
<pre><code>{&quot;square_wave_large_dose&quot;:{&quot;large_dose_liquid&quot;:&quot;15&quot;,&quot;tim_hh&quot;:&quot;02&quot;,&quot;tim_min&quot;:&quot;30&quot;}}
</code></pre>
<ul>
<li>[ ]  下午 ameba pro2的 wps 连接模式，依据用户指南的api，调用函数后出现堆栈错误，未排查出错误原因</li>
</ul>
<p><img alt="image-20241203173156530" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241203173156530.png" /></p>
<p><strong>err :</strong></p>
<p>地址，R0  R3   LR跳转链接地址存在明显错误</p>
<p><img alt="image-20241203173737036" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241203173737036.png" /></p>
<h2 id="2024124">2024/12/4</h2>
<ul>
<li>[x] 实现AmebaPro2的的WPS，第一次连接时需要长按路由器的wps按钮，记住密码后续将自动连接，无需手动操作  </li>
</ul>
<p>example 编译文件 wlan_scenario </p>
<p><img alt="image-20241204172915206" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241204172915206.png" /></p>
<p><img alt="image-20241204173044445" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241204173044445.png" /></p>
<p><img alt="image-20241204173102960" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241204173102960.png" /></p>
<h2 id="2024125">2024/12/5</h2>
<p><strong>wps 配置</strong></p>
<pre><code class="language-c">void _wps_thread(void *pvParameters)
{
    char *id = pvParameters;
    printf(&quot;\nExample: wlan_scenario \n&quot;);
#if defined(configENABLE_TRUSTZONE) &amp;&amp; (configENABLE_TRUSTZONE == 1)
    rtw_create_secure_context(configMINIMAL_SECURE_STACK_SIZE);
#endif
    // Wait for other task stable.
    vTaskDelay(4000);

    printf(&quot;\n\n[WLAN_SCENARIO_EXAMPLE] Wi-Fi example for authentication...\n&quot;);
    rtw_network_info_t connect_param = {0};

    /*********************************************************************************
    *   1. Enable Wi-Fi with STA mode
    *********************************************************************************/
    printf(&quot;\n\r[WLAN_SCENARIO_EXAMPLE] Enable Wi-Fi\n&quot;);
    if (wifi_on(RTW_MODE_STA) &lt; 0) {
        printf(&quot;\n\r[WLAN_SCENARIO_EXAMPLE] ERROR: wifi_on failed\n&quot;);
        return;
    }
    /*********************************************************************************
    *   2. Connect to AP by different authentications
    *********************************************************************************/
    printf(&quot;\n\r[WLAN_SCENARIO_EXAMPLE] Connect to AP\n&quot;);

    // By WPS-PBC.
    char *argv[2];
    argv[1] = (char *)&quot;pbc&quot;;
    cmd_wps(2, argv);

    /*********************************************************************************
    *   3. Show Wi-Fi information
    *********************************************************************************/
    printf(&quot;\n\r[WLAN_SCENARIO_EXAMPLE] Show Wi-Fi information\n&quot;);
    rtw_wifi_setting_t setting;
    wifi_get_setting(WLAN0_IDX, &amp;setting);
    print_wifi_setting(WLAN0_NAME, &amp;setting);
}


void wps_test(char *id)
{
    if (xTaskCreate(_wps_thread, ((const char *)&quot;_wps_thread&quot;), 1024, (void *const) id, tskIDLE_PRIORITY + 1, NULL) != pdPASS) {
        printf(&quot;\n\r%s xTaskCreate failed\n&quot;, __FUNCTION__);
    }
}
</code></pre>
<p><strong>监控功能分析</strong></p>
<p>TP-link摄像头功能</p>
<p><strong>视频画质调整</strong></p>
<ul>
<li>流畅</li>
<li>超清</li>
</ul>
<p><strong>摄像头声音捕获</strong></p>
<ul>
<li>开启</li>
<li>关闭</li>
</ul>
<p><strong>云台</strong></p>
<ul>
<li>云台调节，摄像头的上下左右移动</li>
</ul>
<p><strong>录像回放</strong></p>
<ul>
<li>时间调整，日期调整</li>
<li>筛选  连续录制，移动录制</li>
<li>截屏，录像，倍速，开启关闭声音</li>
<li>录像保存</li>
<li>录像计划（显示sd卡状态，选择是否启用sd卡录像，sd卡录像计划(全天连续录像，全天活动录像)）</li>
</ul>
<p><strong>对讲</strong></p>
<ul>
<li>
<p>开启麦克风对讲功能</p>
</li>
<li>
<p>按住对讲</p>
</li>
<li>
<p>音量调节（摄像机收音，摄像机扬声）</p>
</li>
</ul>
<p><strong>截图</strong></p>
<ul>
<li>将当前视频画面截图并保存至相册</li>
</ul>
<p><strong>录制</strong></p>
<ul>
<li>将当前视屏录制保存至并保存至相册</li>
</ul>
<p><strong>镜头遮蔽</strong></p>
<ul>
<li>关闭当前摄像头</li>
</ul>
<p><strong>画面翻转</strong></p>
<ul>
<li>不翻转，上下翻转，适用于摄像头正装或者倒装的场景</li>
</ul>
<p><strong>手动报警</strong></p>
<ul>
<li>测试报警声(喇叭)是否正常</li>
</ul>
<p><strong>补光模式</strong></p>
<ul>
<li>
<p>仅白光照明</p>
</li>
<li>
<p>仅红外照明</p>
</li>
<li>
<p>移动侦测全彩</p>
</li>
</ul>
<p><strong>视频参数设置(主码流参数设置，设置清晰度为超清时的参数，子码流参数设置，设置清晰度为流畅时的参数)</strong></p>
<ul>
<li>
<p>分辨率设置  (<strong>2304x1296</strong>   <strong>2048 x 1280</strong>    <strong>1920x1280</strong>  <strong>1280*720</strong>）</p>
</li>
<li>
<p>视频帧率  ( <strong>1 ,10 ,15</strong> )</p>
</li>
<li>
<p>码率类型（<strong>变码率，定码率</strong>）</p>
</li>
<li>
<p>图像质量（<strong>低，中，高</strong>）</p>
</li>
<li>
<p>码率上限（<strong>256 512 1024 2048 Kbps</strong>）</p>
</li>
<li>
<p>视频编码选择（<strong>H.264,H.265</strong>）</p>
</li>
<li>
<p>[x] 实现双波大剂量，接收指令后，立刻输注一定的量，然后剩下的量按照方波进行</p>
</li>
</ul>
<pre><code>{&quot;double_wave_large_dose&quot;:{&quot;all_liquid&quot;:&quot;60&quot;,&quot;proportion&quot;:&quot;50&quot;, &quot;tim_hh&quot;:&quot;1&quot;, &quot;tim_min&quot;:&quot;00&quot;}}  
</code></pre>
<p>上述指令设置 总输注量为60，立马输注量百分比为50%，剩余的量在1h输完</p>
<p>明日任务</p>
<ul>
<li>[ ] Ameba pro 实现将视频流全天录像,以及活动录像 至sd卡 </li>
<li>[ ] 胰岛素泵添加日志功能，记录电机运行状态</li>
</ul>
<h2 id="2024127">2024/12/7</h2>
<p>双通道串流 动态检测  H264 + mjpeg + osd + wps实现</p>
<pre><code class="language-c">static void md_process(void *md_result)
{
    md_result_t *md_res = (md_result_t *) md_result;

#if MD_DRAW
      //mp4 only draw text
        int motion = md_res-&gt;motion_cnt;
        canvas_create_bitmap(V1_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);

      //显示时间
       struct tm now_tim = sntp_gen_system_time_s(8 * 3600);
       snprintf(mp4_filename, sizeof(mp4_filename), &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, now_tim.tm_year, now_tim.tm_mon, now_tim.tm_mday, now_tim.tm_hour, now_tim.tm_min,
                     now_tim.tm_sec);
      // 使用 canvas_set_text 在指定位置绘制时间字符串
      canvas_set_text(V1_CHANNEL, 0, 5, 5, mp4_filename, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置


    if (md_res-&gt;event_cnt &gt;= event_threshold) {

    }

    if (motion) {
        int xmin = (int)(md_res-&gt;md_pos[0].xmin * V2_WIDTH);
        int ymin = (int)(md_res-&gt;md_pos[0].ymin * V2_HEIGHT);
        int xmax = (int)(md_res-&gt;md_pos[0].xmax * V2_WIDTH);
        int ymax = (int)(md_res-&gt;md_pos[0].ymax * V2_HEIGHT);

        canvas_set_rect(V1_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
    }
    canvas_update(V1_CHANNEL, 0, 1);


    canvas_create_bitmap(V2_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
    if (md_res-&gt;event_cnt &gt;= event_threshold) {
        // canvas_set_text(V2_CHANNEL, 0, 5, 5, (char *)&quot;Motion Detect&quot;, COLOR_GREEN);   
    }
        canvas_set_text(V2_CHANNEL, 0, 5, 5, mp4_filename, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置

    if (motion) {
        int xmin = (int)(md_res-&gt;md_pos[0].xmin * V2_WIDTH);
        int ymin = (int)(md_res-&gt;md_pos[0].ymin * V2_HEIGHT);
        int xmax = (int)(md_res-&gt;md_pos[0].xmax * V2_WIDTH);
        int ymax = (int)(md_res-&gt;md_pos[0].ymax * V2_HEIGHT);

        canvas_set_rect(V2_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
        canvas_set_rect(V1_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
    }
    canvas_update(V2_CHANNEL, 0, 1);

#endif
}



void mmf2_video_example_md_mp4_init(void)
{
  atcmd_userctrl_init();

#if defined(ENABLE_META_INFO)
    unsigned char uuid[16] = {0xc7, 0x98, 0x2c, 0x28, 0x0a, 0xfc, 0x49, 0xe6, 0xaa, 0xe4, 0x7f, 0x8f, 0x64, 0xee, 0x65, 0x01};
    video_pre_init_params_t init_params;
    memset(&amp;init_params, 0x00, sizeof(video_pre_init_params_t));
    init_params.meta_enable = 1;
    init_params.meta_size = VIDEO_META_USER_SIZE;
    memcpy(init_params.video_meta_uuid, uuid, VIDEO_META_UUID_SIZE);
    video_pre_init_setup_parameters(&amp;init_params);//It only setup one time.
    video_v1_params.meta_enable = 1;
    video_v2_params.meta_enable = 1;
    for (int i = 0; i &lt; 64; i++) {
        meta_user_buf[i] = i;
    }
#endif

    /*sensor capacity check &amp; video parameter setting*/
    video_v1_params.resolution = VIDEO_VGA;
    video_v1_params.width = 1280;
    video_v1_params.height = 720;
    video_v1_params.fps = sensor_params[USE_SENSOR].sensor_fps/2 ;
    video_v1_params.gop = sensor_params[USE_SENSOR].sensor_fps/2 ;

    video_v2_params.resolution = VIDEO_VGA;
    video_v2_params.width = 1280;
    video_v2_params.height = 720;
    video_v2_params.fps = 15;
    video_v2_params.gop = 15;

    video_v4_params.width = MD_WIDTH;
    video_v4_params.height = MD_HEIGHT;
    video_v4_params.fps = MD_FPS;
    video_v4_params.gop = MD_FPS;
    video_v4_params.roi.xmax = sensor_params[USE_SENSOR].sensor_width;
    video_v4_params.roi.ymax = sensor_params[USE_SENSOR].sensor_height;

    /* rtsp parameter setting */
    rtsp2_v1_params.u.v.fps = sensor_params[USE_SENSOR].sensor_fps / 2;
    rtsp2_v2_params.u.v.fps = sensor_params[USE_SENSOR].sensor_fps;

    int voe_heap_size = video_voe_presetting(1, video_v1_params.width, video_v1_params.height, V1_BPS, 0,
                        1, video_v2_params.width, video_v2_params.height, V2_BPS, 0,
                        0, 0, 0, 0, 0,
                        1, MD_WIDTH, MD_HEIGHT);  

    printf(&quot;\r\n voe heap size = %d\r\n&quot;, voe_heap_size);
    if (voe_boot_fsc_status()) {
        video_v1_params.fcs = 1;
    }

    // ------ Channel 1--------------
    video_v1_ctx = mm_module_open(&amp;video_module);
    if (video_v1_ctx) {
        mm_module_ctrl(video_v1_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v1_params);
        mm_module_ctrl(video_v1_ctx, MM_CMD_SET_QUEUE_LEN, video_v1_params.fps * 3);
        mm_module_ctrl(video_v1_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
#if defined(ENABLE_META_INFO)
        if (video_v1_params.meta_enable) {
            mm_module_ctrl(video_v1_ctx, CMD_VIDEO_META_CB, (int)video_meta_cb);
        }
#endif
    } else {
        rt_printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    // ------ Channel 2--------------
    video_v2_ctx = mm_module_open(&amp;video_module);
    if (video_v2_ctx) {
        mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v2_params);
        mm_module_ctrl(video_v2_ctx, MM_CMD_SET_QUEUE_LEN, video_v2_params.fps * 3);
        mm_module_ctrl(video_v2_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
#if defined(ENABLE_META_INFO)
        if (video_v2_params.meta_enable) {
            mm_module_ctrl(video_v2_ctx, CMD_VIDEO_META_CB, (int)video_meta_cb2);
        }
#endif
    } else {
        rt_printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    //------ Channel 4--------------
    video_rgb_ctx = mm_module_open(&amp;video_module);
    if (video_rgb_ctx) {
        mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v4_params);
        mm_module_ctrl(video_rgb_ctx, MM_CMD_SET_QUEUE_LEN, 2);
        mm_module_ctrl(video_rgb_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
    } else {
        printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    md_ctx  = mm_module_open(&amp;eip_module);
    if (md_ctx) {
        md_config_t md_config;
        mm_module_ctrl(md_ctx, CMD_EIP_GET_MD_CONFIG, (int)&amp;md_config); //get default md config
        md_config.md_obj_sensitivity = md_sensitivity;
        mm_module_ctrl(md_ctx, CMD_EIP_SET_PARAMS, (int)&amp;md_param);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_DISPPOST, (int)md_process);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_CONFIG, (int)&amp;md_config);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_EN, 1);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_STATUS, EIP_STATUS_START);
    } else {
        printf(&quot;md_ctx open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    sntp_init();

    //--------------Audio --------------
    audio_ctx = mm_module_open(&amp;audio_module);
    if (audio_ctx) {
#if !USE_DEFAULT_AUDIO_SET
        mm_module_ctrl(audio_ctx, CMD_AUDIO_SET_PARAMS, (int)&amp;audio_params);
#endif
        mm_module_ctrl(audio_ctx, MM_CMD_SET_QUEUE_LEN, 6);
        mm_module_ctrl(audio_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_STATIC);
        mm_module_ctrl(audio_ctx, CMD_AUDIO_APPLY, 0);
    } else {
        rt_printf(&quot;audio open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    aac_ctx = mm_module_open(&amp;aac_module);
    if (aac_ctx) {
        mm_module_ctrl(aac_ctx, CMD_AAC_SET_PARAMS, (int)&amp;aac_params);
        mm_module_ctrl(aac_ctx, MM_CMD_SET_QUEUE_LEN, 16);
        mm_module_ctrl(aac_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
        mm_module_ctrl(aac_ctx, CMD_AAC_INIT_MEM_POOL, 0);
        mm_module_ctrl(aac_ctx, CMD_AAC_APPLY, 0);
    } else {
        rt_printf(&quot;AAC open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    //--------------RTSP---------------
    rtsp2_v1_ctx = mm_module_open(&amp;rtsp2_module);
    if (rtsp2_v1_ctx) {
        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SELECT_STREAM, 0);
        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_v1_params);
        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_APPLY, 0);

        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SELECT_STREAM, 1);
        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_a_params);
        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_APPLY, 0);

        mm_module_ctrl(rtsp2_v1_ctx, CMD_RTSP2_SET_STREAMMING, ON);
    } else {
        rt_printf(&quot;RTSP2 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }


    rtsp2_v2_ctx = mm_module_open(&amp;rtsp2_module);
    if (rtsp2_v2_ctx) {
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 0);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_v2_params);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);

        //mjpeg audio --&gt; rtsp2
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 1);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_a_params);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);

        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);
    } else {
        rt_printf(&quot;RTSP2 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }


    //--------------Link---------------------------
    siso_audio_aac = siso_create();
    if (siso_audio_aac) {
        siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_INPUT, (uint32_t)audio_ctx, 0);
        siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_OUTPUT, (uint32_t)aac_ctx, 0);
        siso_ctrl(siso_audio_aac, MMIC_CMD_SET_STACKSIZE, 44 * 1024, 0);
        siso_start(siso_audio_aac);
    } else {
        rt_printf(&quot;siso1 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    rt_printf(&quot;siso started\n\r&quot;);

    mimo_2v_1a_rtsp = mimo_create();
    if (mimo_2v_1a_rtsp) {
#if defined(configENABLE_TRUSTZONE) &amp;&amp; (configENABLE_TRUSTZONE == 1)
        mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
        mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_INPUT0, (uint32_t)video_v1_ctx, 0);
        mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_INPUT1, (uint32_t)video_v2_ctx, 0);
        mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_INPUT2, (uint32_t)aac_ctx, 0);
        mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_OUTPUT0, (uint32_t)rtsp2_v1_ctx, MMIC_DEP_INPUT0 | MMIC_DEP_INPUT2);
        mimo_ctrl(mimo_2v_1a_rtsp, MMIC_CMD_ADD_OUTPUT1, (uint32_t)rtsp2_v2_ctx, MMIC_DEP_INPUT1 | MMIC_DEP_INPUT2);
        mimo_start(mimo_2v_1a_rtsp);
    } else {
        rt_printf(&quot;mimo open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    mm_module_ctrl(video_v1_ctx, CMD_VIDEO_APPLY, V1_CHANNEL);
    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_APPLY, V2_CHANNEL);
    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SNAPSHOT, 2); 
    rt_printf(&quot;mimo started\n\r&quot;);

// ------------siso rgb md-----------------
    siso_rgb_md = siso_create();
    if (siso_rgb_md) {
#if defined(configENABLE_TRUSTZONE) &amp;&amp; (configENABLE_TRUSTZONE == 1)
        siso_ctrl(siso_rgb_md, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
        siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_INPUT, (uint32_t)video_rgb_ctx, 0);
        siso_ctrl(siso_rgb_md, MMIC_CMD_SET_STACKSIZE, (uint32_t)1024 * 64, 0);
        siso_ctrl(siso_rgb_md, MMIC_CMD_SET_TASKPRIORITY, 3, 0);
        siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_OUTPUT, (uint32_t)md_ctx, 0);
        siso_start(siso_rgb_md);
    } else {
        printf(&quot;siso_rgb_md open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }
    printf(&quot;siso_rgb_md started\n\r&quot;);
    mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_APPLY, MD_CHANNEL); // start channel 4
    mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_YUV, 2);


    #if MD_DRAW
     int ch_enable[3] = {1, 1, 0};
     int char_resize_w[3] = {16, 16, 0}, char_resize_h[3] = {32, 32, 0};
     int ch_width[3] = {video_v1_params.width, video_v2_params.width, 0};
     int ch_height[3] = {video_v1_params.height, video_v2_params.height, 0};
     osd_render_dev_init(ch_enable, char_resize_w, char_resize_h);
     osd_render_task_start(ch_enable, ch_width, ch_height);
    #endif


    return;
mmf2_video_example_md_mp4_fail:

    return;
}

</code></pre>
<ul>
<li>
<p>[x] 运行检测视频保存至sd卡完成</p>
</li>
<li>
<p>[x] WPS + 双通道串流 + 运动检测 + 运行视频保存  合并完成</p>
</li>
</ul>
<p>四个通道使用情况如下： </p>
<pre><code>channel_1   video_save        
channel_2   H264              
channel_3   MJPEG             
channel_4   motion detection  
</code></pre>
<p>两个视频流 端口号 554 ----&gt;h264      555 ----&gt;mjpeg</p>
<ul>
<li>[ ] bug，在串流的视频上显示时间，保存视频将受到影响</li>
</ul>
<p><img alt="image-20241206175907779" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/zhongke/image-20241206175907779.png" /></p>
<h2 id="2024127_1">2024/12/7</h2>
<ul>
<li>[x] 昨天bug 解决，</li>
<li>[ ] 实测试  在V3通道上显示osd会造成  canvas_send_msg: idx larger than available block</li>
</ul>
<p>昨天bug解决了保存视频至sd卡的问题，但串流显示</p>
<h2 id="2024129">2024/12/9</h2>
<ul>
<li>[x] 双通道串流实现 + osd + 动态检测实现</li>
</ul>
<pre><code class="language-c">/******************************************************************************
*
* Copyright(c) 2007 - 2023 Realtek Corporation. All rights reserved.
*
******************************************************************************/
#include &quot;mmf2_link.h&quot;
#include &quot;mmf2_siso.h&quot;
#include &quot;mmf2_mimo.h&quot;

#include &quot;module_video.h&quot;
#include &quot;module_rtsp2.h&quot;
#include &quot;module_audio.h&quot;
#include &quot;module_aac.h&quot;
#include &quot;module_mp4.h&quot;
#include &quot;module_eip.h&quot;
#include &quot;module_queue.h&quot;
#include &quot;mmf2_pro2_video_config.h&quot;
#include &quot;video_example_media_framework.h&quot;
#include &quot;log_service.h&quot;
#include &quot;sensor.h&quot;
#include &lt;sntp/sntp.h&gt;

/*****************************************************************************
* ISP channel : 0,1
* Video type  : H264/HEVC
*****************************************************************************/

#define V1_CHANNEL 0
#define V1_BPS 2*1024*1024
#define V1_RCMODE 2 // 1: CBR, 2: VBR
#define V1_FPS 15

#define V2_CHANNEL 1
#define V2_BPS 2*1024*1024
#define V2_RCMODE 2 // 1: CBR, 2: VBR
#define V2_FPS 15
#define V2_WIDTH    1280
#define V2_HEIGHT   720

#define V3_CHANNEL 2
#define V3_BPS     2*1024*1024
#define V3_RCMODE  2 // 1: CBR, 2: VBR
#define V3_FPS     15
#define V3_WIDTH   1280
#define V3_HEIGHT  720

#define MD_CHANNEL 4
#define MD_GOP MD_FPS
#define MD_BPS 1024*1024
#define MD_TYPE VIDEO_RGB
#define MD_WIDTH    640
#define MD_HEIGHT   480

#define USE_H265 0
#if USE_H265
#include &quot;sample_h265.h&quot;
#define VIDEO_TYPE VIDEO_HEVC
#define VIDEO_CODEC AV_CODEC_ID_H265
#else
#include &quot;sample_h264.h&quot;
#define VIDEO_TYPE VIDEO_H264
#define VIDEO_CODEC AV_CODEC_ID_H264
#endif

static void atcmd_userctrl_init(void);
static mm_context_t *video_v1_ctx           = NULL;
static mm_context_t *video_v2_ctx           = NULL;
static mm_context_t *video_v3_ctx           = NULL;


static mm_context_t *video_rgb_ctx          = NULL;

static mm_context_t *rtsp2_v1_ctx           = NULL;
static mm_context_t *rtsp2_v2_ctx           = NULL;
static mm_context_t *rtsp2_v3_ctx           = NULL;

static mm_context_t *audio_ctx              = NULL;
static mm_context_t *aac_ctx                = NULL;
static mm_context_t *mp4_ctx                = NULL;
static mm_context_t *queue_ctx              = NULL;
static mm_context_t *md_ctx                 = NULL;

static mm_siso_t *siso_audio_aac            = NULL;
static mm_mimo_t *mimo_2v_1a_rtsp_queue     = NULL;
static mm_siso_t *siso_queue_mp4            = NULL;
static mm_siso_t *siso_rgb_md               = NULL;
static mm_mimo_t *mimo_2v_1a_rtsp           = NULL;

static video_params_t video_v1_params = {
    .stream_id = V1_CHANNEL,
    .type = VIDEO_TYPE,
    .bps = V1_BPS,
    .rc_mode = V1_RCMODE,
    .use_static_addr = 1,
};

static video_params_t video_v2_params = {
    .stream_id = V2_CHANNEL,
    .type = VIDEO_JPEG,
    .use_static_addr = 1
};



static video_params_t video_v3_params = {
    .stream_id = V3_CHANNEL,
    .type = VIDEO_TYPE,
    .bps = V1_BPS,
    .rc_mode = V1_RCMODE,
    .use_static_addr = 1,
};

static video_params_t video_v4_params = {
    .stream_id      = MD_CHANNEL,
    .type           = MD_TYPE,
    .fps            = MD_FPS,
    .gop            = MD_GOP,
    .direct_output  = 0,
    .use_static_addr = 1,
    .use_roi = 1,
    .roi = {
        .xmin = 0,
        .ymin = 0,
    }
};

#if !USE_DEFAULT_AUDIO_SET
static audio_params_t audio_params = {
    .sample_rate = ASR_8KHZ,
    .word_length = WL_16BIT,
    .mic_gain    = MIC_0DB,
    .dmic_l_gain    = DMIC_BOOST_24DB,
    .dmic_r_gain    = DMIC_BOOST_24DB,
    .use_mic_type   = USE_AUDIO_AMIC,
    .channel     = 1,
    .enable_aec  = 0//1
};
#endif

static aac_params_t aac_params = {
    .sample_rate = 8000,
    .channel = 1,
    .trans_type = AAC_TYPE_ADTS,
    .object_type = AAC_AOT_LC,
    .bitrate = 32000,

    .mem_total_size = 10 * 1024,
    .mem_block_size = 128,
    .mem_frame_size = 1024
};



static rtsp2_params_t rtsp2_v1_params = {
    .type = AVMEDIA_TYPE_VIDEO,
    .u = {
        .v = {
            .codec_id = VIDEO_CODEC,
            .bps      = V1_BPS
        }
    }
};



static rtsp2_params_t rtsp2_v2_params = {
    .type = AVMEDIA_TYPE_VIDEO,
    .u = {
        .v = {
            .codec_id = AV_CODEC_ID_MJPEG,
        }
    }
};


static rtsp2_params_t rtsp2_v3_params = {
    .type = AVMEDIA_TYPE_VIDEO,
    .u = {
        .v = {
            .codec_id = VIDEO_CODEC,
            .bps      = V1_BPS
        }
    }
};

static rtsp2_params_t rtsp2_a_params = {
    .type = AVMEDIA_TYPE_AUDIO,
    .u = {
        .a = {
            .codec_id   = AV_CODEC_ID_MP4A_LATM,
            .channel    = 1,
            .samplerate = 8000
        }
    }
};

static mp4_params_t mp4_v1_params = {
    .sample_rate = 8000,
    .channel = 1,
    .record_length = 305, //5 min 5sec
    .record_type = STORAGE_ALL,
    .record_file_num = 1,
    .record_file_name = &quot;AmebaPro_recording&quot;,
    .fatfs_buf_size = 224 * 1024, /* 32kb multiple */
};

#define MD_COL 32
#define MD_ROW 32

static eip_param_t md_param = {
    .image_width = MD_WIDTH,
    .image_height = MD_HEIGHT,
    .eip_row = MD_ROW,
    .eip_col = MD_COL
};

//--------------------------------------------
// Draw Rect
//--------------------------------------------
#define MD_DRAW 1

#if MD_DRAW
#include &quot;osd_render.h&quot;
#endif

static int event_threshold = 7;
static int md_sensitivity = 75;
static char mp4_filename[128];

static char osd_tim[128];

static TimerHandle_t mp4_stop_record_timer = NULL;

static void mp4_stop_record_callback(TimerHandle_t xTimer)
{
    (void)xTimer;
    printf(&quot;no motion for 10 seconds\r\n&quot;);
    mm_module_ctrl(mp4_ctx, CMD_MP4_STOP, 0);
}


static void md_process(void *md_result)
{
    md_result_t *md_res = (md_result_t *) md_result;

    if (md_res-&gt;event_cnt &gt;= event_threshold) {
        int record_status = 0;
        mm_module_ctrl(mp4_ctx, CMD_MP4_GET_STATUS, (int)&amp;record_status);
        if (record_status) {
            xTimerReset(mp4_stop_record_timer, 10);
        } else {
            struct tm tm_now = sntp_gen_system_time_s(8 * 3600);
            snprintf(mp4_filename, sizeof(mp4_filename), &quot;%04d%02d%02d%02d%02d%02d&quot;, tm_now.tm_year, tm_now.tm_mon, tm_now.tm_mday, tm_now.tm_hour, tm_now.tm_min,
                     tm_now.tm_sec);
            printf(&quot;start recording %s\r\n&quot;, mp4_filename);
            mm_module_ctrl(mp4_ctx, CMD_MP4_SET_RECORD_FILE_NAME, (int)mp4_filename);
            mm_module_ctrl(mp4_ctx, CMD_MP4_START, 1);
            xTimerStart(mp4_stop_record_timer, 10);
        }
    }

#if MD_DRAW
        //mp4 only draw text
        int motion = md_res-&gt;motion_cnt;  
        //显示时间
        struct tm now_tim = sntp_gen_system_time_s(8 * 3600);
        snprintf(osd_tim, sizeof(osd_tim), &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, now_tim.tm_year, now_tim.tm_mon, now_tim.tm_mday, now_tim.tm_hour, now_tim.tm_min,
                     now_tim.tm_sec);

        canvas_create_bitmap(V1_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
        canvas_set_text(V1_CHANNEL, 0, 5, 5, osd_tim, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置

        if (motion) {
        int xmin = (int)(md_res-&gt;md_pos[0].xmin * V2_WIDTH);
        int ymin = (int)(md_res-&gt;md_pos[0].ymin * V2_HEIGHT);
        int xmax = (int)(md_res-&gt;md_pos[0].xmax * V2_WIDTH);
        int ymax = (int)(md_res-&gt;md_pos[0].ymax * V2_HEIGHT);

        canvas_set_rect(V1_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
       }
        canvas_update(V1_CHANNEL, 0, 1);


    canvas_create_bitmap(V2_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
    canvas_set_text(V2_CHANNEL, 0, 5, 5, osd_tim, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置
      if (motion) {

        int xmin = (int)(md_res-&gt;md_pos[0].xmin * V2_WIDTH);
        int ymin = (int)(md_res-&gt;md_pos[0].ymin * V2_HEIGHT);
        int xmax = (int)(md_res-&gt;md_pos[0].xmax * V2_WIDTH);
        int ymax = (int)(md_res-&gt;md_pos[0].ymax * V2_HEIGHT);

        canvas_set_rect(V2_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
       }
    canvas_update(V2_CHANNEL, 0, 1);


    canvas_create_bitmap(V3_CHANNEL, 0, RTS_OSD2_BLK_FMT_1BPP);
    canvas_set_text(V3_CHANNEL, 0, 5, 5, osd_tim, COLOR_WHITE);  // 将文本设置为白色，并显示在(10,10)位置
      if (motion) {

        int xmin = (int)(md_res-&gt;md_pos[0].xmin * V2_WIDTH);
        int ymin = (int)(md_res-&gt;md_pos[0].ymin * V2_HEIGHT);
        int xmax = (int)(md_res-&gt;md_pos[0].xmax * V2_WIDTH);
        int ymax = (int)(md_res-&gt;md_pos[0].ymax * V2_HEIGHT);

        canvas_set_rect(V3_CHANNEL, 0, xmin, ymin, xmax, ymax, 2, COLOR_WHITE);
       }
    canvas_update(V3_CHANNEL, 0, 1);



#endif
}



void mmf2_video_example_md_mp4_init(void)
{
  atcmd_userctrl_init();

#if defined(ENABLE_META_INFO)
    unsigned char uuid[16] = {0xc7, 0x98, 0x2c, 0x28, 0x0a, 0xfc, 0x49, 0xe6, 0xaa, 0xe4, 0x7f, 0x8f, 0x64, 0xee, 0x65, 0x01};
    video_pre_init_params_t init_params;
    memset(&amp;init_params, 0x00, sizeof(video_pre_init_params_t));
    init_params.meta_enable = 1;
    init_params.meta_size = VIDEO_META_USER_SIZE;
    memcpy(init_params.video_meta_uuid, uuid, VIDEO_META_UUID_SIZE);
    video_pre_init_setup_parameters(&amp;init_params);//It only setup one time.
    video_v1_params.meta_enable = 1;
    video_v2_params.meta_enable = 1;
    for (int i = 0; i &lt; 64; i++) {
        meta_user_buf[i] = i;
    }
#endif

    video_v1_params.resolution = VIDEO_FHD;
    video_v1_params.width = sensor_params[USE_SENSOR].sensor_width;
    video_v1_params.height = sensor_params[USE_SENSOR].sensor_height;
    video_v1_params.fps = V1_FPS;
    video_v1_params.gop = V1_FPS;

    video_v2_params.resolution = VIDEO_HD;
    video_v2_params.width = 1280;
    video_v2_params.height = 720;
    video_v2_params.fps = 15;
    video_v2_params.gop = 15;

    video_v3_params.resolution = VIDEO_HD;
    video_v3_params.width = 1280;
    video_v3_params.height = 720;
    video_v3_params.fps = 15 ;
    video_v3_params.gop = 15 ;

    video_v4_params.width = MD_WIDTH;
    video_v4_params.height = MD_HEIGHT;
    video_v4_params.fps = MD_FPS;
    video_v4_params.gop = MD_FPS;
    video_v4_params.roi.xmax = sensor_params[USE_SENSOR].sensor_width;
    video_v4_params.roi.ymax = sensor_params[USE_SENSOR].sensor_height;

    /*mp4 parameter setting*/
    mp4_v1_params.fps = V1_FPS;
    mp4_v1_params.gop = V1_FPS;
    mp4_v1_params.width = sensor_params[USE_SENSOR].sensor_width;
    mp4_v1_params.height = sensor_params[USE_SENSOR].sensor_height;

    /* rtsp parameter setting */
    rtsp2_v1_params.u.v.fps = 15;
    rtsp2_v2_params.u.v.fps = 15;
    rtsp2_v3_params.u.v.fps = 15;

    int voe_heap_size = video_voe_presetting(1, video_v1_params.width, video_v1_params.height, V1_BPS, 0,
                        1, video_v2_params.width, video_v2_params.height, V2_BPS, 0,
                        1, video_v3_params.width, video_v3_params.height, V3_BPS, 0,
                        1, MD_WIDTH, MD_HEIGHT);  

    printf(&quot;\r\n voe heap size = %d\r\n&quot;, voe_heap_size);
    if (voe_boot_fsc_status()) {
        video_v1_params.fcs = 1;
    }

    // ---------- Channel 1--------------
    video_v1_ctx = mm_module_open(&amp;video_module);
    if (video_v1_ctx) {
        mm_module_ctrl(video_v1_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v1_params);
        mm_module_ctrl(video_v1_ctx, MM_CMD_SET_QUEUE_LEN, video_v1_params.fps);
        mm_module_ctrl(video_v1_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);

    } else {
        rt_printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    // ----------- Channel 2--------------
    video_v2_ctx = mm_module_open(&amp;video_module);
    if (video_v2_ctx) {
        mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v2_params);
        mm_module_ctrl(video_v2_ctx, MM_CMD_SET_QUEUE_LEN, video_v2_params.fps * 3);
        mm_module_ctrl(video_v2_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);

    } else {
        rt_printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    //------------ Channel 3--------------
    video_v3_ctx = mm_module_open(&amp;video_module);
    if (video_v3_ctx) {
        mm_module_ctrl(video_v3_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v3_params);
        mm_module_ctrl(video_v3_ctx, MM_CMD_SET_QUEUE_LEN, video_v3_params.fps);
        mm_module_ctrl(video_v3_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);

    } else {
        rt_printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    //------ Channel 4--------------
    video_rgb_ctx = mm_module_open(&amp;video_module);
    if (video_rgb_ctx) {
        mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_SET_PARAMS, (int)&amp;video_v4_params);
        mm_module_ctrl(video_rgb_ctx, MM_CMD_SET_QUEUE_LEN, 2);
        mm_module_ctrl(video_rgb_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
    } else {
        printf(&quot;video open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    md_ctx  = mm_module_open(&amp;eip_module);
    if (md_ctx) {
        md_config_t md_config;
        mm_module_ctrl(md_ctx, CMD_EIP_GET_MD_CONFIG, (int)&amp;md_config); //get default md config
        md_config.md_obj_sensitivity = md_sensitivity;
        mm_module_ctrl(md_ctx, CMD_EIP_SET_PARAMS, (int)&amp;md_param);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_DISPPOST, (int)md_process);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_CONFIG, (int)&amp;md_config);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_EN, 1);
        mm_module_ctrl(md_ctx, CMD_EIP_SET_STATUS, EIP_STATUS_START);
    } else {
        printf(&quot;md_ctx open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }



    //--------------MP4---------------
    mp4_ctx = mm_module_open(&amp;mp4_module);
    if (mp4_ctx) {
        mm_module_ctrl(mp4_ctx, CMD_MP4_SET_PARAMS, (int)&amp;mp4_v1_params);
        mm_module_ctrl(mp4_ctx, CMD_MP4_LOOP_MODE, 0);
    } else {
        printf(&quot;MP4 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }
    mp4_stop_record_timer = xTimerCreate(&quot;mp4_stop_record_timer&quot;, 10000 / portTICK_PERIOD_MS, pdFALSE, NULL, mp4_stop_record_callback);

    sntp_init();

    queue_ctx = mm_module_open(&amp;queue_module);
    if (queue_ctx) {
        int audio_queue_len = mp4_v1_params.sample_rate / 1024;
        mm_module_ctrl(queue_ctx, MM_CMD_SET_QUEUE_LEN, (video_v1_params.fps + audio_queue_len) * 3); //mp4 init takes 2.5s, buffer 3 seconds video and audio
        mm_module_ctrl(queue_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
        mm_module_ctrl(queue_ctx, CMD_QUEUE_SET_VQUEUE_LEN, video_v1_params.fps * 5); //buffer 5 second video
        mm_module_ctrl(queue_ctx, CMD_QUEUE_SET_AQUEUE_LEN, audio_queue_len * 5); //buffer 5 second audio
    } else {
        printf(&quot;QUEUE open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    //--------------Audio --------------
    audio_ctx = mm_module_open(&amp;audio_module);
    if (audio_ctx) {
#if !USE_DEFAULT_AUDIO_SET
        mm_module_ctrl(audio_ctx, CMD_AUDIO_SET_PARAMS, (int)&amp;audio_params);
#endif
        mm_module_ctrl(audio_ctx, MM_CMD_SET_QUEUE_LEN, 6);
        mm_module_ctrl(audio_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_STATIC);
        mm_module_ctrl(audio_ctx, CMD_AUDIO_APPLY, 0);
    } else {
        rt_printf(&quot;audio open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    aac_ctx = mm_module_open(&amp;aac_module);
    if (aac_ctx) {
        mm_module_ctrl(aac_ctx, CMD_AAC_SET_PARAMS, (int)&amp;aac_params);
        mm_module_ctrl(aac_ctx, MM_CMD_SET_QUEUE_LEN, 16);
        mm_module_ctrl(aac_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_DYNAMIC);
        mm_module_ctrl(aac_ctx, CMD_AAC_INIT_MEM_POOL, 0);
        mm_module_ctrl(aac_ctx, CMD_AAC_APPLY, 0);
    } else {
        rt_printf(&quot;AAC open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    //--------------RTSP---------------

    rtsp2_v2_ctx = mm_module_open(&amp;rtsp2_module);
    if (rtsp2_v2_ctx) {
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 0);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_v2_params);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);

        //mjpeg audio --&gt; rtsp2
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SELECT_STREAM, 1);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_a_params);
        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_APPLY, 0);

        mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, ON);
    } else {
        rt_printf(&quot;RTSP2 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }


    rtsp2_v3_ctx = mm_module_open(&amp;rtsp2_module); 
    if (rtsp2_v3_ctx) {
        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SELECT_STREAM, 0);
        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_v3_params);
        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_APPLY, 0);

        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SELECT_STREAM, 1);
        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_PARAMS, (int)&amp;rtsp2_a_params);
        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_APPLY, 0);

        mm_module_ctrl(rtsp2_v3_ctx, CMD_RTSP2_SET_STREAMMING, ON);
    } else {
        rt_printf(&quot;RTSP2 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }



    //--------------Link---------------------------
    siso_audio_aac = siso_create();
    if (siso_audio_aac) {
        siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_INPUT, (uint32_t)audio_ctx, 0);
        siso_ctrl(siso_audio_aac, MMIC_CMD_ADD_OUTPUT, (uint32_t)aac_ctx, 0);
        siso_ctrl(siso_audio_aac, MMIC_CMD_SET_STACKSIZE, 44 * 1024, 0);
        siso_start(siso_audio_aac);
    } else {
        rt_printf(&quot;siso1 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    rt_printf(&quot;siso started\n\r&quot;);

    mimo_2v_1a_rtsp_queue = mimo_create();
    if (mimo_2v_1a_rtsp_queue) {
#if defined(configENABLE_TRUSTZONE) &amp;&amp; (configENABLE_TRUSTZONE == 1)
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT0, (uint32_t)video_v1_ctx, 0);
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT1, (uint32_t)video_v2_ctx, 0);
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT2, (uint32_t)video_v3_ctx, 0);
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_INPUT3, (uint32_t)aac_ctx, 0);

        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_OUTPUT0, (uint32_t)queue_ctx, MMIC_DEP_INPUT0 | MMIC_DEP_INPUT3);
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_OUTPUT1, (uint32_t)rtsp2_v2_ctx, MMIC_DEP_INPUT1 | MMIC_DEP_INPUT3);
        mimo_ctrl(mimo_2v_1a_rtsp_queue, MMIC_CMD_ADD_OUTPUT2, (uint32_t)rtsp2_v3_ctx, MMIC_DEP_INPUT2 | MMIC_DEP_INPUT3);

        mimo_start(mimo_2v_1a_rtsp_queue);
    } else {
        rt_printf(&quot;mimo open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }

    mm_module_ctrl(video_v1_ctx, CMD_VIDEO_APPLY, V1_CHANNEL);

    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_APPLY, V2_CHANNEL);   
    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_SNAPSHOT, 2);   // jpeg串流不可删除

    mm_module_ctrl(video_v3_ctx, CMD_VIDEO_APPLY, V3_CHANNEL);


    rt_printf(&quot;mimo started\n\r&quot;);

// ------------siso rgb md-----------------
    siso_rgb_md = siso_create();
    if (siso_rgb_md) {
#if defined(configENABLE_TRUSTZONE) &amp;&amp; (configENABLE_TRUSTZONE == 1)
        siso_ctrl(siso_rgb_md, MMIC_CMD_SET_SECURE_CONTEXT, 1, 0);
#endif
        siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_INPUT, (uint32_t)video_rgb_ctx, 0);
        siso_ctrl(siso_rgb_md, MMIC_CMD_SET_STACKSIZE, (uint32_t)1024 * 64, 0);
        siso_ctrl(siso_rgb_md, MMIC_CMD_SET_TASKPRIORITY, 3, 0);
        siso_ctrl(siso_rgb_md, MMIC_CMD_ADD_OUTPUT, (uint32_t)md_ctx, 0);
        siso_start(siso_rgb_md);
    } else {
        printf(&quot;siso_rgb_md open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }
    printf(&quot;siso_rgb_md started\n\r&quot;);
    mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_APPLY, MD_CHANNEL); // start channel 4
    mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_YUV, 2);

    // ------------siso  mp4-----------------
    siso_queue_mp4 = siso_create();
    if (siso_queue_mp4) {
        siso_ctrl(siso_queue_mp4, MMIC_CMD_ADD_INPUT, (uint32_t)queue_ctx, 0);
        siso_ctrl(siso_queue_mp4, MMIC_CMD_ADD_OUTPUT, (uint32_t)mp4_ctx, 0);
        siso_start(siso_queue_mp4);
    } else {
        printf(&quot;siso2 open fail\n\r&quot;);
        goto mmf2_video_example_md_mp4_fail;
    }
    printf(&quot;siso_queue_mp4 started\n\r&quot;);

    #if MD_DRAW

     int ch_enable[4] = {1, 1, 1,0};
     int char_resize_w[4] = {16, 16, 16,0}, char_resize_h[4] = {32, 32, 32,0};
     int ch_width[4] = {video_v1_params.width, video_v2_params.width, video_v3_params.width,0};
     int ch_height[4] = {video_v1_params.height, video_v2_params.height, video_v3_params.height,0};
     osd_render_dev_init(ch_enable, char_resize_w, char_resize_h);
     osd_render_task_start(ch_enable, ch_width, ch_height);
    #endif

    return;
mmf2_video_example_md_mp4_fail:

    return;
}






static const char *example = &quot;mmf2_video_example_md_mp4_init&quot;;
static void example_deinit(void)
{
    sntp_stop();
    xTimerDelete(mp4_stop_record_timer, 0xFFFFFFFF);
    mm_module_ctrl(md_ctx, CMD_EIP_SET_STATUS, EIP_STATUS_STOP);

#if MD_DRAW
    osd_render_task_stop();
    osd_render_dev_deinit_all();
#endif

    //Pause Linker
    siso_pause(siso_audio_aac);
    mimo_pause(mimo_2v_1a_rtsp_queue, MM_OUTPUT0 | MM_OUTPUT1);
    siso_pause(siso_rgb_md);
    siso_pause(siso_queue_mp4);

    //Stop module
    mm_module_ctrl(rtsp2_v2_ctx, CMD_RTSP2_SET_STREAMMING, OFF);
    mm_module_ctrl(aac_ctx, CMD_AAC_STOP, 0);
    mm_module_ctrl(audio_ctx, CMD_AUDIO_SET_TRX, 0);
    mm_module_ctrl(mp4_ctx, CMD_MP4_STOP, 0);
    mm_module_ctrl(video_rgb_ctx, CMD_VIDEO_STREAM_STOP, 0);
    mm_module_ctrl(video_v1_ctx, CMD_VIDEO_STREAM_STOP, 0);
    mm_module_ctrl(video_v2_ctx, CMD_VIDEO_STREAM_STOP, 0);

    //Delete linker
    siso_delete(siso_queue_mp4);
    siso_delete(siso_rgb_md);
    mimo_delete(mimo_2v_1a_rtsp_queue);
    siso_delete(siso_audio_aac);

    //Close module
    rtsp2_v2_ctx = mm_module_close(rtsp2_v2_ctx);
    aac_ctx = mm_module_close(aac_ctx);
    audio_ctx = mm_module_close(audio_ctx);
    mp4_ctx = mm_module_close(mp4_ctx);
    queue_ctx = mm_module_close(queue_ctx);
    md_ctx = mm_module_close(md_ctx);
    video_rgb_ctx = mm_module_close(video_rgb_ctx);
    video_v2_ctx = mm_module_close(video_v2_ctx);
    video_v1_ctx = mm_module_close(video_v1_ctx);

    //Video Deinit
    video_deinit();
}



static void fUC(void *arg)
{
    static uint32_t user_cmd = 0;

    if (!strcmp(arg, &quot;TD&quot;)) {
        if (user_cmd &amp; USR_CMD_EXAMPLE_DEINIT) {
            printf(&quot;invalid state, can not do %s deinit!\r\n&quot;, example);
        } else {
            example_deinit();
            user_cmd = USR_CMD_EXAMPLE_DEINIT;
            printf(&quot;deinit %s\r\n&quot;, example);
        }
    } else if (!strcmp(arg, &quot;TSR&quot;)) {
        if (user_cmd &amp; USR_CMD_EXAMPLE_DEINIT) {
            printf(&quot;reinit %s\r\n&quot;, example);
            sys_reset();
        } else {
            printf(&quot;invalid state, can not do %s init!\r\n&quot;, example);
        }
    } else {
        printf(&quot;invalid cmd&quot;);
    }

    printf(&quot;user command 0x%x\r\n&quot;, user_cmd);
}

#define MAX_ARGC 18

static void fMD(void *arg)
{
    char *argv[MAX_ARGC] = {0};
    if (!arg) {
        return;
    }

    parse_param(arg, argv);

    if (strcmp(argv[1], &quot;sen&quot;) == 0) {
        int sen = atoi(argv[2]);
        if (md_ctx) {
            mm_module_ctrl(md_ctx, CMD_EIP_SET_MD_SENSITIVITY, sen);
            printf(&quot;Set MD sensitivity %d\r\n&quot;, sen);
        }
    } else if (strcmp(argv[1], &quot;thr&quot;) == 0) {
        int event = atoi(argv[2]);
        if (event &lt; MD_FPS) {
            event_threshold = event;
            printf(&quot;Set event threshold %d\r\n&quot;, event_threshold);
        } else {
            printf(&quot;Event threshold out of range (0-%d)\r\n&quot;, MD_FPS);
        }
    }
    return;
}

static log_item_t userctrl_items[] = {
    {&quot;UC&quot;, fUC, },
    {&quot;MD&quot;, fMD, },
};

static void atcmd_userctrl_init(void)
{
    log_service_add_table(userctrl_items, sizeof(userctrl_items) / sizeof(userctrl_items[0]));
}
</code></pre>
<p>定义日志存储空间200k</p>
<ul>
<li>连接时间日志</li>
</ul>
<pre><code>{connect:&quot;2024/12/12 20:32:20&quot;}
</code></pre>
<ul>
<li>断开连接日志</li>
</ul>
<pre><code>{disconnect:&quot;2024/12/12 20:32:20&quot;}
</code></pre>
<ul>
<li></li>
</ul>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul>
<li><a href="#_1">日志</a></li>
<li><a href="#20241112">2024/11/12</a></li>
<li><a href="#20241113">2024/11/13</a></li>
<li><a href="#20241115">2024/11/15</a></li>
<li><a href="#20241119">2024//11/19</a></li>
<li><a href="#20241120">2024/11/20</a></li>
<li><a href="#20241121">2024/11/21</a></li>
<li><a href="#20241122">2024/11/22</a></li>
<li><a href="#20241123">2024/11/23</a></li>
<li><a href="#20241125">2024/11/25</a></li>
<li><a href="#20241126">2024/11/26</a></li>
<li><a href="#20241127">2024/11/27</a></li>
<li><a href="#20241128">2024/11/28</a></li>
<li><a href="#20241129">2024/11/29</a></li>
<li><a href="#2024122">2024/12/2</a></li>
<li><a href="#2024123">2024/12/3</a></li>
<li><a href="#2024124">2024/12/4</a></li>
<li><a href="#2024125">2024/12/5</a></li>
<li><a href="#2024127">2024/12/7</a></li>
<li><a href="#2024127_1">2024/12/7</a></li>
<li><a href="#2024129">2024/12/9</a></li>
</ul>
</div>

</div>
</body>
</html>

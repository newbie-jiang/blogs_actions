
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>busybox制作根文件系统</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h1 id="busybox">busybox根文件系统制作</h1>
<p>（不推荐，可以简单了解一下，使用手工解决依赖问题，麻烦，推荐buildroot）</p>
<h2 id="1">1. 交叉编译工具链准备</h2>
<ul>
<li><strong>获取交叉编译工具链</strong>（如<code>arm-linux-gnueabihf-gcc</code>等），确保在开发机上可用，且<code>$PATH</code>已包含其bin目录。</li>
</ul>
<pre><code>export CROSS_COMPILE=arm-linux-gnueabihf-
export ARCH=arm
</code></pre>
<h2 id="2-busybox">2. 编译BusyBox</h2>
<ol>
<li><strong>下载源码</strong></li>
</ol>
<p><code>wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2
   tar xjf busybox-1.36.1.tar.bz2
   cd busybox-1.36.1</code></p>
<ol>
<li><strong>配置BusyBox</strong>
    推荐用<code>make menuconfig</code>，可以自定义功能：</li>
</ol>
<p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
   # 选择"Build static binary"（静态编译更方便裸机移植）</code></p>
<ol>
<li><strong>编译并安装</strong></li>
</ol>
<p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j$(nproc)
   make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install</code></p>
<p>安装后生成<code>_install/</code>目录，里面是已编译好的BusyBox应用软链接。</p>
<hr />
<h2 id="3">3. 根文件系统目录结构搭建</h2>
<ul>
<li>按照Linux Filesystem Hierarchy Standard(FHS)创建基本目录结构。例如：</li>
</ul>
<p><code>mkdir -p rootfs/{bin,sbin,etc,proc,sys,usr/{bin,sbin},dev,tmp,var,lib,mnt,home}</code></p>
<ul>
<li>将BusyBox的输出内容复制到根文件系统：</li>
</ul>
<p><code>cp -a busybox-1.36.1/_install/* rootfs/</code></p>
<hr />
<h2 id="4">4. 设备节点创建</h2>
<ul>
<li>必须有基本设备节点，如<code>/dev/console</code>和<code>/dev/null</code>，可用<code>sudo mknod</code>在PC下创建：</li>
</ul>
<p><code>sudo mknod -m 600 rootfs/dev/console c 5 1
  sudo mknod -m 666 rootfs/dev/null c 1 3</code></p>
<hr />
<h2 id="5">5. 基本配置文件准备</h2>
<ul>
<li><strong>/etc/inittab</strong>（BusyBox init的启动配置）：</li>
</ul>
<p><code>cat &gt; rootfs/etc/inittab &lt;&lt;EOF
  ::sysinit:/etc/init.d/rcS
  ::askfirst:-/bin/sh
  ::ctrlaltdel:/sbin/reboot
  ::shutdown:/sbin/swapoff -a
  ::shutdown:/bin/umount -a -r
  ::shutdown:/sbin/reboot
  EOF</code></p>
<ul>
<li><strong>/etc/init.d/rcS</strong>（启动脚本，务必加执行权限）：</li>
</ul>
<p><code>mkdir -p rootfs/etc/init.d
  cat &gt; rootfs/etc/init.d/rcS &lt;&lt;EOF
  #!/bin/sh
  mount -t proc none /proc
  mount -t sysfs none /sys
  # 可选：mount -t tmpfs none /tmp
  EOF
  chmod +x rootfs/etc/init.d/rcS</code></p>
<ul>
<li>其他如<code>/etc/passwd</code>, <code>/etc/group</code>可以简单创建，避免启动报错。</li>
</ul>
<hr />
<h2 id="6">6. 库文件准备（仅动态编译需做）</h2>
<ul>
<li>如果BusyBox为<strong>静态编译</strong>，可跳过此步。</li>
<li>动态编译需将交叉工具链下的对应<code>lib/ld-linux*.so*</code>, <code>lib/libc.so*</code>等库复制到<code>rootfs/lib</code>或<code>rootfs/lib64</code>。</li>
</ul>
<hr />
<h2 id="7">7. 其它（可选）</h2>
<ul>
<li>可添加自己的应用程序或脚本到<code>rootfs/bin</code>、<code>rootfs/sbin</code>等目录。</li>
<li>可配置<code>/etc/fstab</code>、<code>/etc/profile</code>等以便于挂载和环境变量设置。</li>
</ul>
<hr />
<h2 id="8">8. 打包成文件系统映像</h2>
<ul>
<li><strong>制作cpio/initramfs镜像</strong></li>
</ul>
<p><code>cd rootfs
  find . | cpio -o -H newc &gt; ../rootfs.cpio</code></p>
<ul>
<li><strong>制作squashfs/ext4镜像</strong></li>
</ul>
<p><code># ext4（适合SD/EMMC/flash，挂载为rootfs）
  dd if=/dev/zero of=../rootfs.ext4 bs=1M count=32
  mkfs.ext4 ../rootfs.ext4
  sudo mount -o loop ../rootfs.ext4 /mnt
  sudo cp -a * /mnt
  sudo umount /mnt</code></p>
<hr />
<h2 id="9">9. 挂载/测试</h2>
<ul>
<li>用QEMU或开发板挂载根文件系统（initramfs, NFS, SD/EMMC/flash等），启动测试。</li>
<li>可以通过串口或控制台观察<code>init</code>流程。</li>
</ul>
<hr />
<h2 id="_1">总结表格</h2>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>工具链准备</td>
<td>交叉编译器、PATH设置</td>
</tr>
<tr>
<td>编译BusyBox</td>
<td>配置、静态/动态编译、安装</td>
</tr>
<tr>
<td>构建rootfs结构</td>
<td>创建标准目录、复制应用</td>
</tr>
<tr>
<td>创建设备节点</td>
<td>mknod生成console/null等</td>
</tr>
<tr>
<td>编辑配置文件</td>
<td>inittab、rcS等启动脚本</td>
</tr>
<tr>
<td>准备库文件</td>
<td>动态库复制（动态编译需做）</td>
</tr>
<tr>
<td>可选添加</td>
<td>自定义程序、脚本、配置</td>
</tr>
<tr>
<td>打包成映像</td>
<td>cpio、ext4、squashfs等</td>
</tr>
<tr>
<td>挂载测试</td>
<td>QEMU/开发板启动测试</td>
</tr>
</tbody>
</table>
<h2 id="busybox_1">BusyBox 制作根文件系统，使用动态库与使用静态库有什么优缺点？</h2>
<h2 id="1-vs">1. 动态库 vs 静态库概念</h2>
<ul>
<li><strong>静态库（Static linking）</strong>
   BusyBox及其他程序在编译时，所有依赖的库代码都被打包进可执行文件，运行时不再依赖外部库文件。</li>
<li><strong>动态库（Dynamic linking）</strong>
   可执行文件本身只包含主程序，依赖的库（如libc.so、ld-linux.so等）在运行时由系统动态加载，需要根文件系统中有这些库。</li>
</ul>
<hr />
<h2 id="2">2. 对比表</h2>
<table>
<thead>
<tr>
<th>对比项</th>
<th>静态库 BusyBox</th>
<th>动态库 BusyBox</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>体积</strong></td>
<td>单个可执行文件较大</td>
<td>可执行文件小，但需额外的库</td>
</tr>
<tr>
<td><strong>依赖</strong></td>
<td>无需libc等外部库，移植简单</td>
<td>需提供glibc/musl等动态库</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>更易跨平台、裸机适用</td>
<td>依赖库版本、架构等匹配</td>
</tr>
<tr>
<td><strong>RAM消耗</strong></td>
<td>多个静态编译程序各自带一份库，RAM占用多</td>
<td>多个程序共享内存的库，占用少</td>
</tr>
<tr>
<td><strong>升级维护</strong></td>
<td>升级需整体重编译替换程序</td>
<td>可单独升级库或应用</td>
</tr>
<tr>
<td><strong>调试定位</strong></td>
<td>问题定位更简单</td>
<td>需考虑库兼容性与加载问题</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>漏洞需重编所有程序</td>
<td>升级库即可全局修复</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>稍快（无需加载库）</td>
<td>略慢（要加载库）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3_1">3. 优缺点详细说明</h2>
<h3 id="_2">静态库优缺点</h3>
<p><strong>优点：</strong></p>
<ul>
<li>整个可执行文件自足（只有BusyBox一个文件），适合初学和极简/只读/ROM型系统。</li>
<li>移植极其简单，只要有/bin/busybox即可跑起来，出错点少。</li>
<li>避免“动态库找不到/版本不符”等问题。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>文件体积比动态版大（一般600~1000KB，动态版可&lt;300KB）。</li>
<li>RAM利用率低（如多个程序用同样的库，都各自独立占内存）。</li>
<li>更新或修复某一库漏洞，要重编整个可执行程序。</li>
</ul>
<h3 id="_3">动态库优缺点</h3>
<p><strong>优点：</strong></p>
<ul>
<li>可执行文件体积小。</li>
<li>RAM效率高，多个程序共享libc等库。</li>
<li>维护简单：升级glibc或musl等库即可全系统生效，无需重编所有应用。</li>
<li>更接近标准Linux发行版做法，便于日后增加自定义程序。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>根文件系统<strong>必须包含所有依赖的动态库</strong>（glibc、ld-linux等），否则启动报错。</li>
<li>需要处理库版本、路径、软链接等细节（对新手不友好）。</li>
<li>初次移植时易因库文件缺失或不匹配导致“找不到libc.so.6”等错误。</li>
</ul>
<hr />
<h2 id="4_1">4. 实践建议</h2>
<ul>
<li><strong>极简环境/初学实验/单一BusyBox场景</strong>：优先用<strong>静态库</strong>。</li>
<li><strong>多应用/维护升级/正式发行</strong>：优先用<strong>动态库</strong>。</li>
<li><strong>存储极度有限/裸机/无libc</strong>：只能用静态库。</li>
<li><strong>如需将busybox和自编小工具都静态编译，移植最方便，但整体文件大。</strong></li>
</ul>
<hr />
<h2 id="5_1">5. 总结</h2>
<blockquote>
<p><strong>静态库更简单，动态库更灵活高效。嵌入式首推静态库，小型Linux发行/后续扩展优选动态库。</strong></p>
</blockquote>
<p>如果你要移植到资源很有限（比如SDRAM很小、flash很小、只要一个shell）的系统，静态BusyBox是首选；如果你要后续装更多程序或升级维护，建议搞动态库rootfs，把常用库一次拷全，后续可维护性好。</p>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul>
<li><a href="#busybox">busybox根文件系统制作</a><ul>
<li><a href="#1">1. 交叉编译工具链准备</a></li>
<li><a href="#2-busybox">2. 编译BusyBox</a></li>
<li><a href="#3">3. 根文件系统目录结构搭建</a></li>
<li><a href="#4">4. 设备节点创建</a></li>
<li><a href="#5">5. 基本配置文件准备</a></li>
<li><a href="#6">6. 库文件准备（仅动态编译需做）</a></li>
<li><a href="#7">7. 其它（可选）</a></li>
<li><a href="#8">8. 打包成文件系统映像</a></li>
<li><a href="#9">9. 挂载/测试</a></li>
<li><a href="#_1">总结表格</a></li>
<li><a href="#busybox_1">BusyBox 制作根文件系统，使用动态库与使用静态库有什么优缺点？</a></li>
<li><a href="#1-vs">1. 动态库 vs 静态库概念</a></li>
<li><a href="#2">2. 对比表</a></li>
<li><a href="#3_1">3. 优缺点详细说明</a><ul>
<li><a href="#_2">静态库优缺点</a></li>
<li><a href="#_3">动态库优缺点</a></li>
</ul>
</li>
<li><a href="#4_1">4. 实践建议</a></li>
<li><a href="#5_1">5. 总结</a></li>
</ul>
</li>
</ul>
</div>

</div>
</body>
</html>

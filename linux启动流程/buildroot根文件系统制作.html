
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>buildroot根文件系统制作</title>
<style>
body { margin: 0; padding: 0; font-family: sans-serif; background: #f5f5f5; }
#wrapper { max-width: 950px; margin: 0 auto; padding-right: 300px; }
#content {
    background: #fff;
    padding: 40px;
    min-height: 100vh;
    box-shadow: 0 2px 14px #eee;
}
#content img {
    display: block;
    margin: 24px auto;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 12px #eee;
    background: #fff;
}
#content pre {
    background: #fafbfc;
    border-radius: 6px;
    padding: 16px;
    margin: 20px 0;
    overflow-x: auto;
    font-size: 16px;
}
#content pre:empty {
    display: none;
}
#content div:empty {
    min-height: 0 !important;
    background: none !important;
}
#toc {
    position: fixed;
    top: 0;
    right: 0;
    width: 270px;
    height: 100vh;
    overflow-y: auto;
    background: #f8f8f8;
    border-left: 1px solid #e0e0e0;
    padding: 32px 16px 32px 24px;
    box-shadow: -3px 0 7px 0 #eee;
    z-index: 100;
}
#toc ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}
#toc ul ul {
    padding-left: 18px;
    border-left: 2px solid #e0e0e0;
    margin-left: 8px;
}
#toc li {
    margin-bottom: 3px;
}
#toc a {
    color: #222;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s;
}
#toc a:hover {
    color: #1a73e8;
}
@media (max-width: 1200px) {
    #toc { display: none; }
    #wrapper { padding-right: 0; }
}
</style>
</head>
<body>
<div id="wrapper">
    <div id="content">
        <h1 id="buildroot">buildroot根文件系统制作</h1>
<h2 id="_1">前言</h2>
<p>一般来说都是使用动态库来做，但是使用busybox需要手工去找动态库的依赖，很难搞，所以就有其他根文件系统制作工具，比如Buildroot</p>
<ol>
<li>
<p>BusyBox “动态库依赖” 的问题</p>
</li>
<li>
<p><strong>手动制作 rootfs 时</strong>，如果你用动态链接编译 BusyBox，必须自己把 BusyBox 运行时所需的所有动态库（如 <code>libc.so.6</code>、<code>ld-linux.so.*</code> 等）都找到，并拷贝到根文件系统合适目录（通常 <code>/lib</code> 或 <code>/lib64</code>）。</p>
</li>
<li>这就需要你：</li>
<li>确认 BusyBox 需要哪些库（可以用 <code>ldd busybox</code> 查看）。</li>
<li>确认库的具体版本和软链接是否正确。</li>
<li>还要考虑依赖链（glibc、libm、ld-linux等），缺一个就报错。</li>
<li>这种“手工找库拷贝”是初学者常见的麻烦事。</li>
</ol>
<hr />
<ol>
<li>
<p>Buildroot 的优势</p>
</li>
<li>
<p><strong>Buildroot 之所以更简单</strong>，就在于它是全自动构建环境：</p>
</li>
<li>你在配置 Buildroot 菜单时，选上 BusyBox（默认就是动态库模式）、选择工具链，它<strong>自动分析依赖</strong>，把所需的库都自动放进你的 rootfs。</li>
<li><strong>你无需手工找库。</strong></li>
<li>Buildroot 会自动搞定：<ul>
<li>libc、libm、ld-linux 等所有依赖库</li>
<li>必要的库文件软链接</li>
<li>目录结构</li>
<li>甚至动态库依赖的后续依赖（递归处理）</li>
</ul>
</li>
<li>只要你的 buildroot 配置没问题，编译完的 rootfs 用于目标板（架构一致），通常不会遇到“找不到库”的错误。</li>
</ol>
<hr />
<ol>
<li>
<p>为什么 Buildroot 能自动搞定？</p>
</li>
<li>
<p>Buildroot 懂得你的工具链用的是哪种 C 库（如 glibc、musl、uClibc），并知道它们要复制哪些库文件到 rootfs。</p>
</li>
<li>同时，Buildroot 用“包描述+依赖自动解析”机制，确保所选 BusyBox 的依赖一并处理。</li>
<li>所以最终生成的文件系统，已经自带完整动态库链。</li>
</ol>
<hr />
<ol>
<li>总结：手工 vs Buildroot</li>
</ol>
<table>
<thead>
<tr>
<th>方式</th>
<th>依赖库处理</th>
<th>容易出错</th>
<th>推荐用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>手工制作 rootfs</td>
<td>需自己查找、复制所有依赖库</td>
<td>容易</td>
<td>教学/极简实验</td>
</tr>
<tr>
<td>Buildroot</td>
<td>自动分析、复制所有依赖库</td>
<td>很少</td>
<td>工程/量产/开发</td>
</tr>
</tbody>
</table>
<hr />
<ol>
<li>
<p>补充</p>
</li>
<li>
<p><strong>Yocto</strong> 也有类似机制，但比 Buildroot 更灵活、复杂、可自定义。</p>
</li>
<li>如果未来想轻松加包或升级，Buildroot 的自动化带来的简洁、可靠体验，是手动方式很难比的。</li>
</ol>
<p><strong>结论</strong></p>
<blockquote>
<p><strong>Buildroot</strong> 极大简化了动态库依赖处理流程，生成的 rootfs 直接可用，省去手工查找和复制动态库的麻烦，非常适合嵌入式Linux实际项目。</p>
</blockquote>
<h2 id="buildroot_1">Buildroot使用方法</h2>
<h2 id="1-buildroot">1. 获取 Buildroot 源码</h2>
<p>官网下载稳定版或使用 git：</p>
<pre><code>sh复制编辑git clone https://git.busybox.net/buildroot
cd buildroot
# 或下载指定版本
# wget https://buildroot.org/downloads/buildroot-2024.02.tar.gz
# tar xzf buildroot-2024.02.tar.gz
</code></pre>
<hr />
<h2 id="2">2. 选择目标平台（架构和处理器）</h2>
<p>Buildroot 支持 ARM、MIPS、RISC-V、x86、PowerPC 等。可选预置板卡，也可自定义。</p>
<hr />
<h2 id="3-buildroot">3. 配置 Buildroot</h2>
<pre><code>make menuconfig
</code></pre>
<p>会弹出图形界面（ncurses），你可以完成以下设置：</p>
<ul>
<li><strong>Target Architecture</strong>：选择目标架构（如 ARM Cortex-A7、A53等）</li>
<li><strong>Toolchain</strong>：选择自带工具链（推荐初学者用 Buildroot 自动下载工具链）</li>
<li><strong>Target packages</strong>：选择需要的组件（如 BusyBox、Dropbear、OpenSSH、Python 等）</li>
<li><strong>Filesystem images</strong>：选择文件系统类型（如 ext4、squashfs、cpio、tar）</li>
<li><strong>Kernel</strong>：可选集成 Linux 内核，指定源码、配置、补丁</li>
<li><strong>Bootloader</strong>：可选集成 u-boot 等</li>
</ul>
<p><strong>Tips</strong>：</p>
<ul>
<li>菜单内每一项都可详细配置。</li>
<li>可保存当前配置为 <code>.config</code> 文件，方便后续复用。</li>
</ul>
<hr />
<h2 id="4">4. 开始构建</h2>
<pre><code>make -j$(nproc)
</code></pre>
<ul>
<li>首次构建会下载/编译工具链、所有源码和依赖，耐心等待。</li>
<li>中途断网可能导致失败，建议用国内镜像源（可配置）。</li>
</ul>
<hr />
<h2 id="5">5. 编译结果在哪里？</h2>
<p>编译完成后，主要输出文件在 <code>output/images/</code> 目录：</p>
<ul>
<li><code>rootfs.ext4</code>、<code>rootfs.squashfs</code> 等：根文件系统镜像</li>
<li><code>zImage</code>、<code>uImage</code>、<code>Image</code>：内核镜像（如果配置了内核）</li>
<li><code>bootloader</code>相关文件（如有）</li>
<li><code>rootfs.cpio</code>：用于initramfs启动</li>
<li>也可能有 dtb、u-boot等</li>
</ul>
<hr />
<h2 id="6">6. 烧录/测试</h2>
<ul>
<li>
<p>可以把 <code>rootfs.ext4</code> 烧到 SD 卡/EMMC（适合开发板启动）</p>
</li>
<li>
<p>可将 <code>rootfs.cpio</code> 作为 initramfs 用于 QEMU 或开发板</p>
</li>
<li>
<p>可用 QEMU 虚拟机直接测试镜像
   示例（ARM QEMU）：</p>
</li>
</ul>
<p><code>qemu-system-arm -M vexpress-a9 -kernel output/images/zImage \
    -dtb output/images/vexpress-v2p-ca9.dtb \
    -initrd output/images/rootfs.cpio \
    -append "console=ttyAMA0" -serial stdio -nographic</code></p>
<hr />
<h2 id="7">7. 常用高级技巧</h2>
<ul>
<li><code>make clean</code>：清理目标产物</li>
<li><code>make menuconfig</code>：随时修改配置</li>
<li><code>make savedefconfig</code>：保存自定义配置（<code>defconfig</code> 文件）</li>
<li><code>make &lt;package&gt;-menuconfig</code>：定制某个包的配置（如 <code>make busybox-menuconfig</code>）</li>
<li><code>output/target/</code>：实际的根文件系统目录，可以手动加文件</li>
</ul>
<hr />
<h2 id="8">8. 配置保存与复用</h2>
<ul>
<li>保存配置：</li>
</ul>
<p><code>sh复制编辑make savedefconfig
  # 得到 defconfig 文件</code></p>
<ul>
<li>加载配置：</li>
</ul>
<p><code>sh复制编辑make defconfig
  # 会恢复 defconfig 为 .config</code></p>
<hr />
<h2 id="9">9. 其它说明</h2>
<ul>
<li>Buildroot 不能动态管理包（不像 Ubuntu apt/yum），所有包需编译期选定。</li>
<li>如需添加自定义包，可以写自定义包描述文件（package 目录）。</li>
<li>适合用于“固件生成”、“生产环境rootfs打包”，不适合开发板本地软件调试。</li>
</ul>
<hr />
<h1 id="_2">总结</h1>
<table>
<thead>
<tr>
<th>步骤</th>
<th>命令/要点</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取源码</td>
<td><code>git clone</code>/解压tar包</td>
</tr>
<tr>
<td>选择架构和配置</td>
<td><code>make menuconfig</code></td>
</tr>
<tr>
<td>开始编译</td>
<td><code>make -j$(nproc)</code></td>
</tr>
<tr>
<td>查找产物</td>
<td><code>output/images/</code></td>
</tr>
<tr>
<td>烧录/测试</td>
<td>烧卡/QEMU/开发板启动</td>
</tr>
</tbody>
</table>
<h2 id="_3">实践</h2>
<p>下载链接   https://git.busybox.net/buildroot  </p>
<ul>
<li>选一个稳定版</li>
</ul>
<p><img alt="image-20250806003701094" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250806003701094.png" /></p>
<p>解压到buildroot目录</p>
<pre><code>mkdir buildroot
tar --strip-components=1 -xjf buildroot-2025.05.tar.bz2 -C buildroot
</code></pre>
<p>查看</p>
<pre><code>hdj@hdj-virtual-machine:~/buildroot$ tree -L 1
.
├── arch
├── board
├── boot
├── CHANGES
├── Config.in
├── Config.in.legacy
├── configs
├── COPYING
├── DEVELOPERS
├── docs
├── fs
├── linux
├── Makefile
├── Makefile.legacy
├── package
├── README
├── support
├── system
├── toolchain
└── utils

12 directories, 8 files

</code></pre>
<pre><code>make menuconfig
</code></pre>
<p><img alt="image-20250806004421325" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250806004421325.png" /></p>
<p>imx6ull为例子配置</p>
<h2 id="target-options">Target options</h2>
<p><img alt="image-20250806005238886" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250806005238886.png" /></p>
<h2 id="toolchain">Toolchain</h2>
<p><img alt="image-20250806005726401" src="https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250806005726401.png" /></p>
<ol>
<li>
<p><strong>Toolchain type</strong></p>
</li>
<li>
<p><code>(Buildroot toolchain)</code>：<strong>保留默认即可</strong>（Buildroot 自动构建交叉工具链），新手推荐这种。</p>
</li>
</ol>
<hr />
<ol>
<li>
<p><strong>C library (glibc/uClibc/musl)</strong></p>
</li>
<li>
<p><strong>推荐 <code>glibc</code> 或 <code>musl</code></strong></p>
</li>
<li><code>glibc</code>：兼容性最好，和主流Linux桌面系统一致，体积较大。</li>
<li><code>musl</code>：极简，体积小，现代嵌入式也很常用，兼容性稍差，但非常适合极简系统。</li>
<li>如果你对C库没有特殊需求，<strong>开发板性能充裕就选 glibc，追求小体积选 musl</strong>。</li>
</ol>
<hr />
<ol>
<li>
<p><strong>Kernel Headers</strong></p>
</li>
<li>
<p><code>(Linux 6.14.x kernel headers)</code>：默认即可。这个只是用来编译库和应用，不影响你实际烧录的内核版本。</p>
</li>
</ol>
<hr />
<ol>
<li>
<p><strong>Binutils / GCC 版本</strong></p>
</li>
<li>
<p>默认最新版通常都可用。</p>
</li>
<li>可以指定稳定老版本，但 Cortex-A7 用新版本没问题。</li>
</ol>
<hr />
<ol>
<li>
<p><strong>Enable C++/Fortran/OpenMP/Graphite support</strong></p>
</li>
<li>
<p>一般只勾 <code>Enable C++ support</code>（如果你有C++应用）。</p>
</li>
<li>其余如不需要 Fortran/OpenMP/Graphite 都可以不勾。</li>
</ol>
<hr />
<ol>
<li>
<p><strong>Host GDB / gconv libraries / Extra toolchain libraries</strong></p>
</li>
<li>
<p>一般开发可不勾选 GDB（除非你要调试）。</p>
</li>
<li><code>gconv libraries</code> 只对国际化有需求时才需拷贝。</li>
</ol>
<hr />
<ol>
<li>
<p><strong>Target Optimizations</strong></p>
</li>
<li>
<p>可以为空，默认就好。</p>
</li>
<li>进阶玩家可填优化选项如：<code>-O2 -mcpu=cortex-a7 -mfpu=vfpv4-d16 -mfloat-abi=hard -mthumb</code></li>
</ol>
<hr />
<ol>
<li>
<p><strong>Bare metal toolchain</strong></p>
</li>
<li>
<p>不要勾选（你做的是Linux，不是裸机应用）。</p>
</li>
</ol>
<p><strong>最关键的建议：</strong></p>
<p><strong>前面你问过 ABI/floating point/vfp/thumb2 这些问题，这些高级设置在 Buildroot “Toolchain” 菜单的后续选项（如 Target ABI, Floating Point, Instruction Set）中会有详细选择。你应该重点关注这些</strong>，如果没找到，可以在 Toolchain 下级菜单逐项查找，
 常见设置如下：</p>
<ul>
<li><strong>Target ABI</strong>：选 <code>EABIHF</code></li>
<li><strong>Floating Point Strategy</strong>：选 <code>hardware (VFP)</code></li>
<li><strong>FPU type</strong>：选 <code>vfpv4-d16</code></li>
<li><strong>Instruction Set</strong>：用户空间推荐 <code>Thumb2</code></li>
</ul>
<hr />
<h3 id="_4"><strong>结论：</strong></h3>
<ul>
<li>保留默认 <code>Buildroot toolchain</code></li>
<li>C库选 glibc（或 musl）</li>
<li>其余选项按默认或根据实际需求勾选</li>
<li>编译优化、高级ABI/FPU/指令集选项后面继续补充/微调</li>
</ul>
    </div>
</div>
<div id="toc">
    <div style="font-weight:bold;margin-bottom:12px;">目录</div>
    <div class="toc">
<ul>
<li><a href="#buildroot">buildroot根文件系统制作</a><ul>
<li><a href="#_1">前言</a></li>
<li><a href="#buildroot_1">Buildroot使用方法</a></li>
<li><a href="#1-buildroot">1. 获取 Buildroot 源码</a></li>
<li><a href="#2">2. 选择目标平台（架构和处理器）</a></li>
<li><a href="#3-buildroot">3. 配置 Buildroot</a></li>
<li><a href="#4">4. 开始构建</a></li>
<li><a href="#5">5. 编译结果在哪里？</a></li>
<li><a href="#6">6. 烧录/测试</a></li>
<li><a href="#7">7. 常用高级技巧</a></li>
<li><a href="#8">8. 配置保存与复用</a></li>
<li><a href="#9">9. 其它说明</a></li>
</ul>
</li>
<li><a href="#_2">总结</a><ul>
<li><a href="#_3">实践</a></li>
<li><a href="#target-options">Target options</a></li>
<li><a href="#toolchain">Toolchain</a><ul>
<li><a href="#_4">结论：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

</div>
</body>
</html>
